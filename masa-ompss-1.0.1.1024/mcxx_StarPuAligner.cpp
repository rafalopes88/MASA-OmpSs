struct __attribute__((aligned(8)))  cell_t
{
    int h;
    union 
    {
        int f;
        int e;
    };
};
struct  match_result_t
{
    bool found;
    int k;
    int score;
    int type;
};
struct  score_t
{
    int i;
    int j;
    int score;
};
struct  score_params_t
{
    int match;
    int mismatch;
    int gap_open;
    int gap_ext;
};
class  Partition
{
    int i0;
    int j0;
    int i1;
    int j1;
  public:
    Partition();
    Partition(int i0, int j0, int i1, int j1);
    Partition(const ::Partition &partition, int i_offset, int j_offset);
    virtual ~Partition();
    int getI0() const ;
    void setI0(int i0);
    int getI1() const ;
    void setI1(int i1);
    int getJ0() const ;
    void setJ0(int j0);
    int getJ1() const ;
    void setJ1(int j1);
    int getHeight() const ;
    int getWidth() const ;
    bool hasZeroArea() const ;
};
class  IManager
{
  public:
    virtual int getRecurrenceType() const  = 0 ;
    virtual int getSpecialRowInterval() const  = 0 ;
    virtual int getSpecialColumnInterval() const  = 0 ;
    virtual int getFirstColumnInitType() = 0 ;
    virtual int getFirstRowInitType() = 0 ;
    virtual ::Partition getSuperPartition() = 0 ;
    virtual void receiveFirstRow(::cell_t *buffer, int len) = 0 ;
    virtual void receiveFirstColumn(::cell_t *buffer, int len) = 0 ;
    virtual void dispatchColumn(int j, const ::cell_t *buffer, int len) = 0 ;
    virtual void dispatchRow(int i, const ::cell_t *buffer, int len) = 0 ;
    virtual void dispatchScore(::score_t score, int bx  = ( -1), int by  = ( -1)) = 0 ;
    virtual bool mustContinue() = 0 ;
    virtual bool mustDispatchLastCell() = 0 ;
    virtual bool mustDispatchLastRow() = 0 ;
    virtual bool mustDispatchLastColumn() = 0 ;
    virtual bool mustDispatchSpecialRows() = 0 ;
    virtual bool mustDispatchSpecialColumns() = 0 ;
    virtual bool mustDispatchScores() = 0 ;
    virtual bool mustPruneBlocks() = 0 ;
  protected:
    inline ~IManager()
    {
    }
    inline IManager()
    {
    }
  public:
};
typedef unsigned long int size_t;
extern "C"
{
  extern inline void *memcpy(void *__restrict __dest, const void *__restrict __src, ::size_t __len) throw() __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline void *memmove(void *__dest, const void *__src, ::size_t __len) throw() __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern void *memccpy(void *__restrict __dest, const void *__restrict __src, int __c, ::size_t __n) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern inline void *memset(void *__dest, int __ch, ::size_t __len) throw() __attribute__((__nonnull__(1))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern int memcmp(const void *__s1, const void *__s2, ::size_t __n) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
}
extern inline void *memchr(void *__s, int __c, ::size_t __n) throw() __asm("memchr") __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__));
extern inline const void *memchr(const void *__s, int __c, ::size_t __n) throw() __asm("memchr") __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__));
extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) void *memchr(void *__s, int __c, ::size_t __n) throw()
{
  return __builtin_memchr(__s, __c, __n);
}
extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) const void *memchr(const void *__s, int __c, ::size_t __n) throw()
{
  return __builtin_memchr(__s, __c, __n);
}
void *rawmemchr(void *__s, int __c) throw() __asm("rawmemchr") __attribute__((__pure__)) __attribute__((__nonnull__(1)));
const void *rawmemchr(const void *__s, int __c) throw() __asm("rawmemchr") __attribute__((__pure__)) __attribute__((__nonnull__(1)));
void *memrchr(void *__s, int __c, ::size_t __n) throw() __asm("memrchr") __attribute__((__pure__)) __attribute__((__nonnull__(1)));
const void *memrchr(const void *__s, int __c, ::size_t __n) throw() __asm("memrchr") __attribute__((__pure__)) __attribute__((__nonnull__(1)));
extern "C"
{
  extern inline char *strcpy(char *__restrict __dest, const char *__restrict __src) throw() __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline char *strncpy(char *__restrict __dest, const char *__restrict __src, ::size_t __len) throw() __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline char *strcat(char *__restrict __dest, const char *__restrict __src) throw() __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline char *strncat(char *__restrict __dest, const char *__restrict __src, ::size_t __len) throw() __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern int strcmp(const char *__s1, const char *__s2) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int strncmp(const char *__s1, const char *__s2, ::size_t __n) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int strcoll(const char *__s1, const char *__s2) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern ::size_t strxfrm(char *__restrict __dest, const char *__restrict __src, ::size_t __n) throw() __attribute__((__nonnull__(2)));
}
struct __locale_data;
struct  __locale_struct
{
    ::__locale_data *__locales[13L];
    const unsigned short int *__ctype_b;
    const int *__ctype_tolower;
    const int *__ctype_toupper;
    const char *__names[13L];
};
typedef ::__locale_struct *__locale_t;
typedef ::__locale_t locale_t;
extern "C"
{
  extern int strcoll_l(const char *__s1, const char *__s2, ::locale_t __l) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1, 2, 3)));
}
extern "C"
{
  extern ::size_t strxfrm_l(char *__dest, const char *__src, ::size_t __n, ::locale_t __l) throw() __attribute__((__nonnull__(2, 4)));
}
extern "C"
{
  extern char *strdup(const char *__s) throw() __attribute__((__malloc__)) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern char *strndup(const char *__string, ::size_t __n) throw() __attribute__((__malloc__)) __attribute__((__nonnull__(1)));
}
extern inline char *strchr(char *__s, int __c) throw() __asm("strchr") __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__));
extern inline const char *strchr(const char *__s, int __c) throw() __asm("strchr") __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__));
extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) char *strchr(char *__s, int __c) throw()
{
  return __builtin_strchr(__s, __c);
}
extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) const char *strchr(const char *__s, int __c) throw()
{
  return __builtin_strchr(__s, __c);
}
extern inline char *strrchr(char *__s, int __c) throw() __asm("strrchr") __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__));
extern inline const char *strrchr(const char *__s, int __c) throw() __asm("strrchr") __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__));
extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) char *strrchr(char *__s, int __c) throw()
{
  return __builtin_strrchr(__s, __c);
}
extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) const char *strrchr(const char *__s, int __c) throw()
{
  return __builtin_strrchr(__s, __c);
}
char *strchrnul(char *__s, int __c) throw() __asm("strchrnul") __attribute__((__pure__)) __attribute__((__nonnull__(1)));
const char *strchrnul(const char *__s, int __c) throw() __asm("strchrnul") __attribute__((__pure__)) __attribute__((__nonnull__(1)));
extern "C"
{
  extern ::size_t strcspn(const char *__s, const char *__reject) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern ::size_t strspn(const char *__s, const char *__accept) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
}
extern inline char *strpbrk(char *__s, const char *__accept) throw() __asm("strpbrk") __attribute__((__pure__)) __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__));
extern inline const char *strpbrk(const char *__s, const char *__accept) throw() __asm("strpbrk") __attribute__((__pure__)) __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__));
extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) char *strpbrk(char *__s, const char *__accept) throw()
{
  return __builtin_strpbrk(__s, __accept);
}
extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) const char *strpbrk(const char *__s, const char *__accept) throw()
{
  return __builtin_strpbrk(__s, __accept);
}
extern inline char *strstr(char *__haystack, const char *__needle) throw() __asm("strstr") __attribute__((__pure__)) __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__));
extern inline const char *strstr(const char *__haystack, const char *__needle) throw() __asm("strstr") __attribute__((__pure__)) __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__));
extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) char *strstr(char *__haystack, const char *__needle) throw()
{
  return __builtin_strstr(__haystack, __needle);
}
extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) const char *strstr(const char *__haystack, const char *__needle) throw()
{
  return __builtin_strstr(__haystack, __needle);
}
extern "C"
{
  extern char *strtok(char *__restrict __s, const char *__restrict __delim) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern char *__strtok_r(char *__restrict __s, const char *__restrict __delim, char **__restrict __save_ptr) throw() __attribute__((__nonnull__(2, 3)));
}
extern "C"
{
  extern char *strtok_r(char *__restrict __s, const char *__restrict __delim, char **__restrict __save_ptr) throw() __attribute__((__nonnull__(2, 3)));
}
char *strcasestr(char *__haystack, const char *__needle) throw() __asm("strcasestr") __attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
const char *strcasestr(const char *__haystack, const char *__needle) throw() __asm("strcasestr") __attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
extern "C"
{
  extern void *memmem(const void *__haystack, ::size_t __haystacklen, const void *__needle, ::size_t __needlelen) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern void *__mempcpy(void *__restrict __dest, const void *__restrict __src, ::size_t __n) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern inline void *mempcpy(void *__restrict __dest, const void *__restrict __src, ::size_t __len) throw() __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern ::size_t strlen(const char *__s) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern ::size_t strnlen(const char *__string, ::size_t __maxlen) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern char *strerror(int __errnum) throw();
}
extern "C"
{
  extern char *strerror_r(int __errnum, char *__buf, ::size_t __buflen) throw() __attribute__((__nonnull__(2))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern char *strerror_l(int __errnum, ::locale_t __l) throw();
}
extern "C"
{
  extern int bcmp(const void *__s1, const void *__s2, ::size_t __n) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern inline void bcopy(const void *__src, void *__dest, ::size_t __len) throw() __attribute__((__nonnull__(1, 2))) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline void bzero(void *__dest, ::size_t __len) throw() __attribute__((__nonnull__(1))) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern inline char *index(char *__s, int __c) throw() __asm("index") __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__));
extern inline const char *index(const char *__s, int __c) throw() __asm("index") __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__));
extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) char *index(char *__s, int __c) throw()
{
  return __builtin_index(__s, __c);
}
extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) const char *index(const char *__s, int __c) throw()
{
  return __builtin_index(__s, __c);
}
extern inline char *rindex(char *__s, int __c) throw() __asm("rindex") __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__));
extern inline const char *rindex(const char *__s, int __c) throw() __asm("rindex") __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__));
extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) char *rindex(char *__s, int __c) throw()
{
  return __builtin_rindex(__s, __c);
}
extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) const char *rindex(const char *__s, int __c) throw()
{
  return __builtin_rindex(__s, __c);
}
extern "C"
{
  extern int ffs(int __i) throw() __attribute__((__const__));
}
extern "C"
{
  extern int ffsl(long int __l) throw() __attribute__((__const__));
}
extern "C"
{
  extern int ffsll(long long int __ll) throw() __attribute__((__const__));
}
extern "C"
{
  extern int strcasecmp(const char *__s1, const char *__s2) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int strncasecmp(const char *__s1, const char *__s2, ::size_t __n) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int strcasecmp_l(const char *__s1, const char *__s2, ::locale_t __loc) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1, 2, 3)));
}
extern "C"
{
  extern int strncasecmp_l(const char *__s1, const char *__s2, ::size_t __n, ::locale_t __loc) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1, 2, 4)));
}
extern "C"
{
  extern inline __attribute__((__nonnull__(1, 2))) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) void bcopy(const void *__src, void *__dest, ::size_t __len) throw()
  {
    (void)__builtin___memmove_chk(__dest, __src, __len, __builtin_object_size(__dest, 0));
  }
}
extern "C"
{
  extern inline __attribute__((__nonnull__(1))) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) void bzero(void *__dest, ::size_t __len) throw()
  {
    (void)__builtin___memset_chk(__dest, '\000', __len, __builtin_object_size(__dest, 0));
  }
}
extern "C"
{
  extern inline void explicit_bzero(void *__dest, ::size_t __len) throw() __attribute__((__nonnull__(1))) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern char *strsep(char **__restrict __stringp, const char *__restrict __delim) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern char *strsignal(int __sig) throw();
}
extern "C"
{
  extern char *__stpcpy(char *__restrict __dest, const char *__restrict __src) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern inline char *stpcpy(char *__restrict __dest, const char *__restrict __src) throw() __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern char *__stpncpy(char *__restrict __dest, const char *__restrict __src, ::size_t __n) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern inline char *stpncpy(char *__restrict __dest, const char *__restrict __src, ::size_t __n) throw() __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern int strverscmp(const char *__s1, const char *__s2) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern char *strfry(char *__string) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern void *memfrob(void *__s, ::size_t __n) throw() __attribute__((__nonnull__(1)));
}
char *basename(char *__filename) throw() __asm("basename") __attribute__((__nonnull__(1)));
const char *basename(const char *__filename) throw() __asm("basename") __attribute__((__nonnull__(1)));
extern "C"
{
  extern inline __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) void *memcpy(void *__restrict __dest, const void *__restrict __src, ::size_t __len) throw()
  {
    return __builtin___memcpy_chk(__dest, __src, __len, __builtin_object_size(__dest, 0));
  }
}
extern "C"
{
  extern inline __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) void *memmove(void *__dest, const void *__src, ::size_t __len) throw()
  {
    return __builtin___memmove_chk(__dest, __src, __len, __builtin_object_size(__dest, 0));
  }
}
extern "C"
{
  extern inline __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) void *mempcpy(void *__restrict __dest, const void *__restrict __src, ::size_t __len) throw()
  {
    return __builtin___mempcpy_chk(__dest, __src, __len, __builtin_object_size(__dest, 0));
  }
}
extern "C"
{
  extern inline __attribute__((__nonnull__(1))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) void *memset(void *__dest, int __ch, ::size_t __len) throw()
  {
    return __builtin___memset_chk(__dest, __ch, __len, __builtin_object_size(__dest, 0));
  }
}
extern "C"
{
  void __explicit_bzero_chk(void *__dest, ::size_t __len, ::size_t __destlen) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern inline __attribute__((__nonnull__(1))) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) void explicit_bzero(void *__dest, ::size_t __len) throw()
  {
    ::__explicit_bzero_chk(__dest, __len, __builtin_object_size(__dest, 0));
  }
}
extern "C"
{
  extern inline __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) char *strcpy(char *__restrict __dest, const char *__restrict __src) throw()
  {
    return __builtin___strcpy_chk(__dest, __src, __builtin_object_size(__dest, 2 > 1));
  }
}
extern "C"
{
  extern inline __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) char *stpcpy(char *__restrict __dest, const char *__restrict __src) throw()
  {
    return __builtin___stpcpy_chk(__dest, __src, __builtin_object_size(__dest, 2 > 1));
  }
}
extern "C"
{
  extern inline __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) char *strncpy(char *__restrict __dest, const char *__restrict __src, ::size_t __len) throw()
  {
    return __builtin___strncpy_chk(__dest, __src, __len, __builtin_object_size(__dest, 2 > 1));
  }
}
extern "C"
{
  extern char *__stpncpy_chk(char *__dest, const char *__src, ::size_t __n, ::size_t __destlen) throw();
}
extern "C"
{
  extern char *__stpncpy_alias(char *__dest, const char *__src, ::size_t __n) throw() __asm("""stpncpy");
}
extern "C"
{
  extern inline __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) char *stpncpy(char *__dest, const char *__src, ::size_t __n) throw()
  {
    if (__builtin_object_size(__dest, 2 > 1) != (::size_t) -1 && (!__builtin_constant_p(__n) || __n > __builtin_object_size(__dest, 2 > 1)))
      {
        return ::__stpncpy_chk(__dest, __src, __n, __builtin_object_size(__dest, 2 > 1));
      }
    return ::__stpncpy_alias(__dest, __src, __n);
  }
}
extern "C"
{
  extern inline __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) char *strcat(char *__restrict __dest, const char *__restrict __src) throw()
  {
    return __builtin___strcat_chk(__dest, __src, __builtin_object_size(__dest, 2 > 1));
  }
}
extern "C"
{
  extern inline __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) char *strncat(char *__restrict __dest, const char *__restrict __src, ::size_t __len) throw()
  {
    return __builtin___strncat_chk(__dest, __src, __len, __builtin_object_size(__dest, 2 > 1));
  }
}
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short int __int16_t;
typedef unsigned short int __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long int __int64_t;
typedef unsigned long int __uint64_t;
typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
struct  __fsid_t
{
    int __val[2L];
};
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef int __daddr_t;
typedef int __key_t;
typedef int __clockid_t;
typedef void *__timer_t;
typedef long int __blksize_t;
typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;
typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;
typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;
typedef long int __fsword_t;
typedef long int __ssize_t;
typedef long int __syscall_slong_t;
typedef unsigned long int __syscall_ulong_t;
typedef ::__off64_t __loff_t;
typedef char *__caddr_t;
typedef long int __intptr_t;
typedef unsigned int __socklen_t;
typedef int __sig_atomic_t;
struct _IO_FILE;
typedef ::_IO_FILE __FILE;
typedef ::_IO_FILE FILE;
struct  __mbstate_t
{
    int __count;
    union  mcc_union_anon_7
    {
        unsigned int __wch;
        char __wchb[4L];
    };
    ::__mbstate_t::mcc_union_anon_7 __value;
};
struct  _G_fpos_t
{
    ::__off_t __pos;
    ::__mbstate_t __state;
};
struct  _G_fpos64_t
{
    ::__off64_t __pos;
    ::__mbstate_t __state;
};
typedef ::__builtin_va_list __gnuc_va_list;
struct _IO_jump_t;
typedef void _IO_lock_t;
struct _IO_marker;
struct  _IO_marker
{
    ::_IO_marker *_next;
    ::_IO_FILE *_sbuf;
    int _pos;
};
enum __codecvt_result
{
  __codecvt_ok = 0,
  __codecvt_partial = 1,
  __codecvt_error = 2,
  __codecvt_noconv = 3
};
struct  _IO_FILE
{
    int _flags;
    char *_IO_read_ptr;
    char *_IO_read_end;
    char *_IO_read_base;
    char *_IO_write_base;
    char *_IO_write_ptr;
    char *_IO_write_end;
    char *_IO_buf_base;
    char *_IO_buf_end;
    char *_IO_save_base;
    char *_IO_backup_base;
    char *_IO_save_end;
    ::_IO_marker *_markers;
    ::_IO_FILE *_chain;
    int _fileno;
    int _flags2;
    ::__off_t _old_offset;
    unsigned short int _cur_column;
    signed char _vtable_offset;
    char _shortbuf[1L];
    ::_IO_lock_t *_lock;
    ::__off64_t _offset;
    void *__pad1;
    void *__pad2;
    void *__pad3;
    void *__pad4;
    ::size_t __pad5;
    int _mode;
    char _unused2[20L];
};
struct _IO_FILE_plus;
extern "C"
{
  extern ::_IO_FILE_plus _IO_2_1_stdin_;
}
extern "C"
{
  extern ::_IO_FILE_plus _IO_2_1_stdout_;
}
extern "C"
{
  extern ::_IO_FILE_plus _IO_2_1_stderr_;
}
typedef ::__ssize_t __io_read_fn(void *, char *, ::size_t);
typedef ::__ssize_t __io_write_fn(void *, const char *, ::size_t);
typedef int __io_seek_fn(void *, ::__off64_t *, int);
typedef int __io_close_fn(void *);
typedef ::__io_read_fn cookie_read_function_t;
typedef ::__io_write_fn cookie_write_function_t;
typedef ::__io_seek_fn cookie_seek_function_t;
typedef ::__io_close_fn cookie_close_function_t;
struct  _IO_cookie_io_functions_t
{
    ::__io_read_fn (*read);
    ::__io_write_fn (*write);
    ::__io_seek_fn (*seek);
    ::__io_close_fn (*close);
};
typedef ::_IO_cookie_io_functions_t cookie_io_functions_t;
struct _IO_cookie_file;
extern "C"
{
  extern void _IO_cookie_init(::_IO_cookie_file *__cfile, int __read_write, void *__cookie, ::_IO_cookie_io_functions_t __fns);
}
extern "C"
{
  extern int __underflow(::_IO_FILE *);
}
extern "C"
{
  extern int __uflow(::_IO_FILE *);
}
extern "C"
{
  extern int __overflow(::_IO_FILE *, int);
}
extern "C"
{
  extern int _IO_getc(::_IO_FILE *__fp);
}
extern "C"
{
  extern int _IO_putc(int __c, ::_IO_FILE *__fp);
}
extern "C"
{
  extern int _IO_feof(::_IO_FILE *__fp) throw();
}
extern "C"
{
  extern int _IO_ferror(::_IO_FILE *__fp) throw();
}
extern "C"
{
  extern int _IO_peekc_locked(::_IO_FILE *__fp);
}
extern "C"
{
  extern void _IO_flockfile(::_IO_FILE *) throw();
}
extern "C"
{
  extern void _IO_funlockfile(::_IO_FILE *) throw();
}
extern "C"
{
  extern int _IO_ftrylockfile(::_IO_FILE *) throw();
}
extern "C"
{
  extern int _IO_vfscanf(::_IO_FILE *__restrict , const char *__restrict , ::__gnuc_va_list, int *__restrict );
}
extern "C"
{
  extern int _IO_vfprintf(::_IO_FILE *__restrict , const char *__restrict , ::__gnuc_va_list);
}
extern "C"
{
  extern ::__ssize_t _IO_padn(::_IO_FILE *, int, ::__ssize_t);
}
extern "C"
{
  extern ::size_t _IO_sgetn(::_IO_FILE *, void *, ::size_t);
}
extern "C"
{
  extern ::__off64_t _IO_seekoff(::_IO_FILE *, ::__off64_t, int, int);
}
extern "C"
{
  extern ::__off64_t _IO_seekpos(::_IO_FILE *, ::__off64_t, int);
}
extern "C"
{
  extern void _IO_free_backup_area(::_IO_FILE *) throw();
}
typedef ::__gnuc_va_list va_list;
typedef ::__off_t off_t;
typedef ::__off64_t off64_t;
typedef ::__ssize_t ssize_t;
typedef ::_G_fpos_t fpos_t;
typedef ::_G_fpos64_t fpos64_t;
extern "C"
{
  extern ::_IO_FILE *stdin;
}
extern "C"
{
  extern ::_IO_FILE *stdout;
}
extern "C"
{
  extern ::_IO_FILE *stderr;
}
extern "C"
{
  extern int remove(const char *__filename) throw();
}
extern "C"
{
  extern int rename(const char *__old, const char *__new) throw();
}
extern "C"
{
  extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new) throw();
}
extern "C"
{
  extern ::FILE *tmpfile() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::FILE *tmpfile64() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern char *tmpnam(char *__s) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern char *tmpnam_r(char *__s) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern char *tempnam(const char *__dir, const char *__pfx) throw() __attribute__((__malloc__)) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int fclose(::FILE *__stream);
}
extern "C"
{
  extern int fflush(::FILE *__stream);
}
extern "C"
{
  extern int fflush_unlocked(::FILE *__stream);
}
extern "C"
{
  extern int fcloseall();
}
extern "C"
{
  extern ::FILE *fopen(const char *__restrict __filename, const char *__restrict __modes) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::FILE *freopen(const char *__restrict __filename, const char *__restrict __modes, ::FILE *__restrict __stream) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::FILE *fopen64(const char *__restrict __filename, const char *__restrict __modes) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::FILE *freopen64(const char *__restrict __filename, const char *__restrict __modes, ::FILE *__restrict __stream) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::FILE *fdopen(int __fd, const char *__modes) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::FILE *fopencookie(void *__restrict __magic_cookie, const char *__restrict __modes, ::_IO_cookie_io_functions_t __io_funcs) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::FILE *fmemopen(void *__s, ::size_t __len, const char *__modes) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::FILE *open_memstream(char **__bufloc, ::size_t *__sizeloc) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern void setbuf(::FILE *__restrict __stream, char *__restrict __buf) throw();
}
extern "C"
{
  extern int setvbuf(::FILE *__restrict __stream, char *__restrict __buf, int __modes, ::size_t __n) throw();
}
extern "C"
{
  extern void setbuffer(::FILE *__restrict __stream, char *__restrict __buf, ::size_t __size) throw();
}
extern "C"
{
  extern void setlinebuf(::FILE *__stream) throw();
}
extern "C"
{
  extern inline int fprintf(::FILE *__restrict __stream, const char *__restrict __fmt, ...) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline int printf(const char *__restrict __fmt, ...) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline int sprintf(char *__restrict __s, const char *__restrict __fmt, ...) throw() __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline int vfprintf(::FILE *__restrict __stream, const char *__restrict __fmt, ::__gnuc_va_list __ap) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline int vprintf(const char *__restrict __fmt, ::__gnuc_va_list __ap) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline int vsprintf(char *__restrict __s, const char *__restrict __fmt, ::__gnuc_va_list __ap) throw() __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline int snprintf(char *__restrict __s, ::size_t __n, const char *__restrict __fmt, ...) throw() __attribute__((__format__(__printf__, 3, 4))) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline int vsnprintf(char *__restrict __s, ::size_t __n, const char *__restrict __fmt, ::__gnuc_va_list __ap) throw() __attribute__((__format__(__printf__, 3, 0))) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline int vasprintf(char **__restrict __ptr, const char *__restrict __fmt, ::__gnuc_va_list __ap) throw() __attribute__((__format__(__printf__, 2, 0))) __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline int __asprintf(char **__restrict __ptr, const char *__restrict __fmt, ...) throw() __attribute__((__format__(__printf__, 2, 3))) __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline int asprintf(char **__restrict __ptr, const char *__restrict __fmt, ...) throw() __attribute__((__format__(__printf__, 2, 3))) __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline int vdprintf(int __fd, const char *__restrict __fmt, ::__gnuc_va_list __ap) __attribute__((__format__(__printf__, 2, 0))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline int dprintf(int __fd, const char *__restrict __fmt, ...) __attribute__((__format__(__printf__, 2, 3))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern int fscanf(::FILE *__restrict __stream, const char *__restrict __format, ...) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int scanf(const char *__restrict __format, ...) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int sscanf(const char *__restrict __s, const char *__restrict __format, ...) throw();
}
extern "C"
{
  extern int vfscanf(::FILE *__restrict __s, const char *__restrict __format, ::__gnuc_va_list __arg) __attribute__((__format__(__scanf__, 2, 0))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int vscanf(const char *__restrict __format, ::__gnuc_va_list __arg) __attribute__((__format__(__scanf__, 1, 0))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int vsscanf(const char *__restrict __s, const char *__restrict __format, ::__gnuc_va_list __arg) throw() __attribute__((__format__(__scanf__, 2, 0)));
}
extern "C"
{
  extern int fgetc(::FILE *__stream);
}
extern "C"
{
  extern int getc(::FILE *__stream);
}
extern "C"
{
  extern inline int getchar() __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int getc_unlocked(::FILE *__fp) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int getchar_unlocked() __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int fgetc_unlocked(::FILE *__fp) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern int fputc(int __c, ::FILE *__stream);
}
extern "C"
{
  extern int putc(int __c, ::FILE *__stream);
}
extern "C"
{
  extern inline int putchar(int __c) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int fputc_unlocked(int __c, ::FILE *__stream) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int putc_unlocked(int __c, ::FILE *__stream) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int putchar_unlocked(int __c) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern int getw(::FILE *__stream);
}
extern "C"
{
  extern int putw(int __w, ::FILE *__stream);
}
extern "C"
{
  extern inline char *fgets(char *__restrict __s, int __n, ::FILE *__restrict __stream) __attribute__((__warn_unused_result__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline char *gets(char *__str) __attribute__((__warn_unused_result__)) __attribute__((__deprecated__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline char *fgets_unlocked(char *__restrict __s, int __n, ::FILE *__restrict __stream) __attribute__((__warn_unused_result__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern ::__ssize_t __getdelim(char **__restrict __lineptr, ::size_t *__restrict __n, int __delimiter, ::FILE *__restrict __stream) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::__ssize_t getdelim(char **__restrict __lineptr, ::size_t *__restrict __n, int __delimiter, ::FILE *__restrict __stream) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern inline ::__ssize_t getline(char **__restrict __lineptr, ::size_t *__restrict __n, ::FILE *__restrict __stream) __attribute__((__warn_unused_result__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern int fputs(const char *__restrict __s, ::FILE *__restrict __stream);
}
extern "C"
{
  extern int puts(const char *__s);
}
extern "C"
{
  extern int ungetc(int __c, ::FILE *__stream);
}
extern "C"
{
  extern inline ::size_t fread(void *__restrict __ptr, ::size_t __size, ::size_t __n, ::FILE *__restrict __stream) __attribute__((__warn_unused_result__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern ::size_t fwrite(const void *__restrict __ptr, ::size_t __size, ::size_t __n, ::FILE *__restrict __s);
}
extern "C"
{
  extern int fputs_unlocked(const char *__restrict __s, ::FILE *__restrict __stream);
}
extern "C"
{
  extern inline ::size_t fread_unlocked(void *__restrict __ptr, ::size_t __size, ::size_t __n, ::FILE *__restrict __stream) __attribute__((__warn_unused_result__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern ::size_t fwrite_unlocked(const void *__restrict __ptr, ::size_t __size, ::size_t __n, ::FILE *__restrict __stream);
}
extern "C"
{
  extern int fseek(::FILE *__stream, long int __off, int __whence);
}
extern "C"
{
  extern long int ftell(::FILE *__stream) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern void rewind(::FILE *__stream);
}
extern "C"
{
  extern int fseeko(::FILE *__stream, ::__off_t __off, int __whence);
}
extern "C"
{
  extern ::__off_t ftello(::FILE *__stream) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int fgetpos(::FILE *__restrict __stream, ::fpos_t *__restrict __pos);
}
extern "C"
{
  extern int fsetpos(::FILE *__stream, const ::fpos_t *__pos);
}
extern "C"
{
  extern int fseeko64(::FILE *__stream, ::__off64_t __off, int __whence);
}
extern "C"
{
  extern ::__off64_t ftello64(::FILE *__stream) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int fgetpos64(::FILE *__restrict __stream, ::fpos64_t *__restrict __pos);
}
extern "C"
{
  extern int fsetpos64(::FILE *__stream, const ::fpos64_t *__pos);
}
extern "C"
{
  extern void clearerr(::FILE *__stream) throw();
}
extern "C"
{
  extern int feof(::FILE *__stream) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int ferror(::FILE *__stream) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern void clearerr_unlocked(::FILE *__stream) throw();
}
extern "C"
{
  extern inline int feof_unlocked(::FILE *__stream) throw() __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int ferror_unlocked(::FILE *__stream) throw() __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern void perror(const char *__s);
}
extern "C"
{
  extern int sys_nerr;
}
extern "C"
{
  extern const char *const sys_errlist[];
}
extern "C"
{
  extern int _sys_nerr;
}
extern "C"
{
  extern const char *const _sys_errlist[];
}
extern "C"
{
  extern int fileno(::FILE *__stream) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int fileno_unlocked(::FILE *__stream) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::FILE *popen(const char *__command, const char *__modes) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int pclose(::FILE *__stream);
}
extern "C"
{
  extern char *ctermid(char *__s) throw();
}
extern "C"
{
  extern char *cuserid(char *__s);
}
struct obstack;
extern "C"
{
  extern inline int obstack_printf(::obstack *__restrict __obstack, const char *__restrict __fmt, ...) throw() __attribute__((__format__(__printf__, 2, 3))) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline int obstack_vprintf(::obstack *__restrict __obstack, const char *__restrict __fmt, ::__gnuc_va_list __ap) throw() __attribute__((__format__(__printf__, 2, 0))) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern void flockfile(::FILE *__stream) throw();
}
extern "C"
{
  extern int ftrylockfile(::FILE *__stream) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern void funlockfile(::FILE *__stream) throw();
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int getchar()
  {
    return ::_IO_getc(::stdin);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int fgetc_unlocked(::FILE *__fp)
  {
    return __builtin_expect((*__fp)._IO_read_ptr >= (*__fp)._IO_read_end, 0) ? ::__uflow(__fp) : *((unsigned char *)(*__fp)._IO_read_ptr++);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int getc_unlocked(::FILE *__fp)
  {
    return __builtin_expect((*__fp)._IO_read_ptr >= (*__fp)._IO_read_end, 0) ? ::__uflow(__fp) : *((unsigned char *)(*__fp)._IO_read_ptr++);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int getchar_unlocked()
  {
    return __builtin_expect((*::stdin)._IO_read_ptr >= (*::stdin)._IO_read_end, 0) ? ::__uflow(::stdin) : *((unsigned char *)(*::stdin)._IO_read_ptr++);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int putchar(int __c)
  {
    return ::_IO_putc(__c, ::stdout);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int fputc_unlocked(int __c, ::FILE *__stream)
  {
    return __builtin_expect((*__stream)._IO_write_ptr >= (*__stream)._IO_write_end, 0) ? ::__overflow(__stream, (unsigned char)__c) : (unsigned char)(*(*__stream)._IO_write_ptr++ = __c);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int putc_unlocked(int __c, ::FILE *__stream)
  {
    return __builtin_expect((*__stream)._IO_write_ptr >= (*__stream)._IO_write_end, 0) ? ::__overflow(__stream, (unsigned char)__c) : (unsigned char)(*(*__stream)._IO_write_ptr++ = __c);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int putchar_unlocked(int __c)
  {
    return __builtin_expect((*::stdout)._IO_write_ptr >= (*::stdout)._IO_write_end, 0) ? ::__overflow(::stdout, (unsigned char)__c) : (unsigned char)(*(*::stdout)._IO_write_ptr++ = __c);
  }
}
extern "C"
{
  extern inline __attribute__((__warn_unused_result__)) __attribute__((__gnu_inline__)) ::__ssize_t getline(char **__lineptr, ::size_t *__n, ::FILE *__stream)
  {
    return ::__getdelim(__lineptr, __n, '\n', __stream);
  }
}
extern "C"
{
  extern inline __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) int feof_unlocked(::FILE *__stream) throw()
  {
    return ((*__stream)._flags & 16) != 0;
  }
}
extern "C"
{
  extern inline __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) int ferror_unlocked(::FILE *__stream) throw()
  {
    return ((*__stream)._flags & 32) != 0;
  }
}
extern "C"
{
  extern int __sprintf_chk(char *__restrict __s, int __flag, ::size_t __slen, const char *__restrict __format, ...) throw();
}
extern "C"
{
  extern int __vsprintf_chk(char *__restrict __s, int __flag, ::size_t __slen, const char *__restrict __format, ::__gnuc_va_list __ap) throw();
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int sprintf(char *__restrict __s, const char *__restrict __fmt, ...) throw()
  {
    return __builtin___sprintf_chk(__s, 2 - 1, __builtin_object_size(__s, 2 > 1), __fmt, __builtin_va_arg_pack());
  }
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int vsprintf(char *__restrict __s, const char *__restrict __fmt, ::__gnuc_va_list __ap) throw()
  {
    return __builtin___vsprintf_chk(__s, 2 - 1, __builtin_object_size(__s, 2 > 1), __fmt, __ap);
  }
}
extern "C"
{
  extern int __snprintf_chk(char *__restrict __s, ::size_t __n, int __flag, ::size_t __slen, const char *__restrict __format, ...) throw();
}
extern "C"
{
  extern int __vsnprintf_chk(char *__restrict __s, ::size_t __n, int __flag, ::size_t __slen, const char *__restrict __format, ::__gnuc_va_list __ap) throw();
}
extern "C"
{
  extern inline __attribute__((__format__(__printf__, 3, 4))) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int snprintf(char *__restrict __s, ::size_t __n, const char *__restrict __fmt, ...) throw()
  {
    return __builtin___snprintf_chk(__s, __n, 2 - 1, __builtin_object_size(__s, 2 > 1), __fmt, __builtin_va_arg_pack());
  }
}
extern "C"
{
  extern inline __attribute__((__format__(__printf__, 3, 0))) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int vsnprintf(char *__restrict __s, ::size_t __n, const char *__restrict __fmt, ::__gnuc_va_list __ap) throw()
  {
    return __builtin___vsnprintf_chk(__s, __n, 2 - 1, __builtin_object_size(__s, 2 > 1), __fmt, __ap);
  }
}
extern "C"
{
  extern int __fprintf_chk(::FILE *__restrict __stream, int __flag, const char *__restrict __format, ...);
}
extern "C"
{
  extern int __printf_chk(int __flag, const char *__restrict __format, ...);
}
extern "C"
{
  extern int __vfprintf_chk(::FILE *__restrict __stream, int __flag, const char *__restrict __format, ::__gnuc_va_list __ap);
}
extern "C"
{
  extern int __vprintf_chk(int __flag, const char *__restrict __format, ::__gnuc_va_list __ap);
}
extern "C"
{
  extern inline __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int fprintf(::FILE *__restrict __stream, const char *__restrict __fmt, ...)
  {
    return ::__fprintf_chk(__stream, 2 - 1, __fmt, __builtin_va_arg_pack());
  }
}
extern "C"
{
  extern inline __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int printf(const char *__restrict __fmt, ...)
  {
    return ::__printf_chk(2 - 1, __fmt, __builtin_va_arg_pack());
  }
}
extern "C"
{
  extern inline __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int vprintf(const char *__restrict __fmt, ::__gnuc_va_list __ap)
  {
    return ::__vfprintf_chk(::stdout, 2 - 1, __fmt, __ap);
  }
}
extern "C"
{
  extern inline __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int vfprintf(::FILE *__restrict __stream, const char *__restrict __fmt, ::__gnuc_va_list __ap)
  {
    return ::__vfprintf_chk(__stream, 2 - 1, __fmt, __ap);
  }
}
extern "C"
{
  extern int __dprintf_chk(int __fd, int __flag, const char *__restrict __fmt, ...) __attribute__((__format__(__printf__, 3, 4)));
}
extern "C"
{
  extern int __vdprintf_chk(int __fd, int __flag, const char *__restrict __fmt, ::__gnuc_va_list __arg) __attribute__((__format__(__printf__, 3, 0)));
}
extern "C"
{
  extern inline __attribute__((__format__(__printf__, 2, 3))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int dprintf(int __fd, const char *__restrict __fmt, ...)
  {
    return ::__dprintf_chk(__fd, 2 - 1, __fmt, __builtin_va_arg_pack());
  }
}
extern "C"
{
  extern inline __attribute__((__format__(__printf__, 2, 0))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int vdprintf(int __fd, const char *__restrict __fmt, ::__gnuc_va_list __ap)
  {
    return ::__vdprintf_chk(__fd, 2 - 1, __fmt, __ap);
  }
}
extern "C"
{
  extern int __asprintf_chk(char **__restrict __ptr, int __flag, const char *__restrict __fmt, ...) throw() __attribute__((__format__(__printf__, 3, 4))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int __vasprintf_chk(char **__restrict __ptr, int __flag, const char *__restrict __fmt, ::__gnuc_va_list __arg) throw() __attribute__((__format__(__printf__, 3, 0))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int __obstack_printf_chk(::obstack *__restrict __obstack, int __flag, const char *__restrict __format, ...) throw() __attribute__((__format__(__printf__, 3, 4)));
}
extern "C"
{
  extern int __obstack_vprintf_chk(::obstack *__restrict __obstack, int __flag, const char *__restrict __format, ::__gnuc_va_list __args) throw() __attribute__((__format__(__printf__, 3, 0)));
}
extern "C"
{
  extern inline __attribute__((__format__(__printf__, 2, 3))) __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int asprintf(char **__restrict __ptr, const char *__restrict __fmt, ...) throw()
  {
    return ::__asprintf_chk(__ptr, 2 - 1, __fmt, __builtin_va_arg_pack());
  }
}
extern "C"
{
  extern inline __attribute__((__format__(__printf__, 2, 3))) __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int __asprintf(char **__restrict __ptr, const char *__restrict __fmt, ...) throw()
  {
    return ::__asprintf_chk(__ptr, 2 - 1, __fmt, __builtin_va_arg_pack());
  }
}
extern "C"
{
  extern inline __attribute__((__format__(__printf__, 2, 3))) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int obstack_printf(::obstack *__restrict __obstack, const char *__restrict __fmt, ...) throw()
  {
    return ::__obstack_printf_chk(__obstack, 2 - 1, __fmt, __builtin_va_arg_pack());
  }
}
extern "C"
{
  extern inline __attribute__((__format__(__printf__, 2, 0))) __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int vasprintf(char **__restrict __ptr, const char *__restrict __fmt, ::__gnuc_va_list __ap) throw()
  {
    return ::__vasprintf_chk(__ptr, 2 - 1, __fmt, __ap);
  }
}
extern "C"
{
  extern inline __attribute__((__format__(__printf__, 2, 0))) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int obstack_vprintf(::obstack *__restrict __obstack, const char *__restrict __fmt, ::__gnuc_va_list __ap) throw()
  {
    return ::__obstack_vprintf_chk(__obstack, 2 - 1, __fmt, __ap);
  }
}
extern "C"
{
  extern char *__gets_chk(char *__str, ::size_t) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern char *__gets_warn(char *__str) __asm("""gets") __attribute__((__warn_unused_result__)) __attribute__((__warning__("please use fgets or getline instead, gets can't ""specify buffer size")));
}
extern "C"
{
  extern inline __attribute__((__warn_unused_result__)) __attribute__((__deprecated__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) char *gets(char *__str)
  {
    if (__builtin_object_size(__str, 2 > 1) != (::size_t) -1)
      {
        return ::__gets_chk(__str, __builtin_object_size(__str, 2 > 1));
      }
    return ::__gets_warn(__str);
  }
}
extern "C"
{
  extern char *__fgets_chk(char *__restrict __s, ::size_t __size, int __n, ::FILE *__restrict __stream) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern char *__fgets_alias(char *__restrict __s, int __n, ::FILE *__restrict __stream) __asm("""fgets") __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern char *__fgets_chk_warn(char *__restrict __s, ::size_t __size, int __n, ::FILE *__restrict __stream) __asm("""__fgets_chk") __attribute__((__warn_unused_result__)) __attribute__((__warning__("fgets called with bigger size than length ""of destination buffer")));
}
extern "C"
{
  extern inline __attribute__((__warn_unused_result__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) char *fgets(char *__restrict __s, int __n, ::FILE *__restrict __stream)
  {
    if (__builtin_object_size(__s, 2 > 1) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__n) || __n <= 0)
          {
            return ::__fgets_chk(__s, __builtin_object_size(__s, 2 > 1), __n, __stream);
          }
        if ((::size_t)__n > __builtin_object_size(__s, 2 > 1))
          {
            return ::__fgets_chk_warn(__s, __builtin_object_size(__s, 2 > 1), __n, __stream);
          }
      }
    return ::__fgets_alias(__s, __n, __stream);
  }
}
extern "C"
{
  extern ::size_t __fread_chk(void *__restrict __ptr, ::size_t __ptrlen, ::size_t __size, ::size_t __n, ::FILE *__restrict __stream) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::size_t __fread_alias(void *__restrict __ptr, ::size_t __size, ::size_t __n, ::FILE *__restrict __stream) __asm("""fread") __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::size_t __fread_chk_warn(void *__restrict __ptr, ::size_t __ptrlen, ::size_t __size, ::size_t __n, ::FILE *__restrict __stream) __asm("""__fread_chk") __attribute__((__warn_unused_result__)) __attribute__((__warning__("fread called with bigger size * nmemb than length ""of destination buffer")));
}
extern "C"
{
  extern inline __attribute__((__warn_unused_result__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) ::size_t fread(void *__restrict __ptr, ::size_t __size, ::size_t __n, ::FILE *__restrict __stream)
  {
    if (__builtin_object_size(__ptr, 0) != (::size_t) -1)
      {
        if ((!__builtin_constant_p(__size) || !__builtin_constant_p(__n)) || (__size | __n) >= (::size_t)1 << 8 * sizeof(::size_t) / 2)
          {
            return ::__fread_chk(__ptr, __builtin_object_size(__ptr, 0), __size, __n, __stream);
          }
        if (__size * __n > __builtin_object_size(__ptr, 0))
          {
            return ::__fread_chk_warn(__ptr, __builtin_object_size(__ptr, 0), __size, __n, __stream);
          }
      }
    return ::__fread_alias(__ptr, __size, __n, __stream);
  }
}
extern "C"
{
  extern char *__fgets_unlocked_chk(char *__restrict __s, ::size_t __size, int __n, ::FILE *__restrict __stream) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern char *__fgets_unlocked_alias(char *__restrict __s, int __n, ::FILE *__restrict __stream) __asm("""fgets_unlocked") __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern char *__fgets_unlocked_chk_warn(char *__restrict __s, ::size_t __size, int __n, ::FILE *__restrict __stream) __asm("""__fgets_unlocked_chk") __attribute__((__warn_unused_result__)) __attribute__((__warning__("fgets_unlocked called with bigger size than length ""of destination buffer")));
}
extern "C"
{
  extern inline __attribute__((__warn_unused_result__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) char *fgets_unlocked(char *__restrict __s, int __n, ::FILE *__restrict __stream)
  {
    if (__builtin_object_size(__s, 2 > 1) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__n) || __n <= 0)
          {
            return ::__fgets_unlocked_chk(__s, __builtin_object_size(__s, 2 > 1), __n, __stream);
          }
        if ((::size_t)__n > __builtin_object_size(__s, 2 > 1))
          {
            return ::__fgets_unlocked_chk_warn(__s, __builtin_object_size(__s, 2 > 1), __n, __stream);
          }
      }
    return ::__fgets_unlocked_alias(__s, __n, __stream);
  }
}
extern "C"
{
  extern ::size_t __fread_unlocked_chk(void *__restrict __ptr, ::size_t __ptrlen, ::size_t __size, ::size_t __n, ::FILE *__restrict __stream) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::size_t __fread_unlocked_alias(void *__restrict __ptr, ::size_t __size, ::size_t __n, ::FILE *__restrict __stream) __asm("""fread_unlocked") __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::size_t __fread_unlocked_chk_warn(void *__restrict __ptr, ::size_t __ptrlen, ::size_t __size, ::size_t __n, ::FILE *__restrict __stream) __asm("""__fread_unlocked_chk") __attribute__((__warn_unused_result__)) __attribute__((__warning__("fread_unlocked called with bigger size * nmemb than ""length of destination buffer")));
}
extern "C"
{
  extern inline __attribute__((__warn_unused_result__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) ::size_t fread_unlocked(void *__restrict __ptr, ::size_t __size, ::size_t __n, ::FILE *__restrict __stream)
  {
    if (__builtin_object_size(__ptr, 0) != (::size_t) -1)
      {
        if ((!__builtin_constant_p(__size) || !__builtin_constant_p(__n)) || (__size | __n) >= (::size_t)1 << 8 * sizeof(::size_t) / 2)
          {
            return ::__fread_unlocked_chk(__ptr, __builtin_object_size(__ptr, 0), __size, __n, __stream);
          }
        if (__size * __n > __builtin_object_size(__ptr, 0))
          {
            return ::__fread_unlocked_chk_warn(__ptr, __builtin_object_size(__ptr, 0), __size, __n, __stream);
          }
      }
    if (((__builtin_constant_p(__size) && __builtin_constant_p(__n)) && (__size | __n) < (::size_t)1 << 8 * sizeof(::size_t) / 2) && __size * __n <= 8)
      {
        ::size_t __cnt(__size * __n);
        char *__cptr((char *)__ptr);
        if (__cnt == 0)
          {
            return 0;
          }
        for (; __cnt > 0;  --__cnt)
          {
            int __c(__builtin_expect((*__stream)._IO_read_ptr >= (*__stream)._IO_read_end, 0) ? ::__uflow(__stream) : *((unsigned char *)(*__stream)._IO_read_ptr++));
            if (__c ==  -1)
              {
                break;
              }
            *__cptr++ = __c;
          }
        return (__cptr - (char *)__ptr) / __size;
      }
    return ::__fread_unlocked_alias(__ptr, __size, __n, __stream);
  }
}
extern "C"
{
  extern char *optarg;
}
extern "C"
{
  extern int optind;
}
extern "C"
{
  extern int opterr;
}
extern "C"
{
  extern int optopt;
}
extern "C"
{
  extern int getopt(int ___argc, char *const *___argv, const char *__shortopts) throw() __attribute__((__nonnull__(2, 3)));
}
struct  option
{
    const char *name;
    int has_arg;
    int *flag;
    int val;
};
extern "C"
{
  extern int getopt_long(int ___argc, char *const *___argv, const char *__shortopts, const ::option *__longopts, int *__longind) throw() __attribute__((__nonnull__(2, 3)));
}
extern "C"
{
  extern int getopt_long_only(int ___argc, char *const *___argv, const char *__shortopts, const ::option *__longopts, int *__longind) throw() __attribute__((__nonnull__(2, 3)));
}
class  IAlignerParameters
{
  public:
    virtual void printUsage() const  = 0 ;
    virtual int processArgument(int argc, char **argv) = 0 ;
    virtual const char *getLastError() const  = 0 ;
    virtual int getForkId() const  = 0 ;
    virtual void setForkId(int forkId) = 0 ;
  protected:
    inline ~IAlignerParameters()
    {
    }
    inline IAlignerParameters()
    {
    }
  public:
};
class  AbstractAlignerParameters : public ::IAlignerParameters
{
  public:
    AbstractAlignerParameters();
    virtual ~AbstractAlignerParameters();
    virtual const char *getLastError() const ;
    virtual int getForkId() const ;
    virtual void setForkId(int forkId);
  protected:
    void setForkCount(const int forkCount, const int *forkWeights  = (0L));
    void setLastError(const char *error);
    static void printFormattedUsage(const char *header, const char *text);
    static int callGetOpt(int argc, char **argv, ::option *arguments);
  private:
    char lastError[500L];
    int forkId;
    const ::option *arguments;
  public:
};
struct  aligner_capabilities_t
{
    bool customize_first_column;
    bool customize_first_row;
    bool dispatch_last_column;
    bool dispatch_last_row;
    bool dispatch_last_cell;
    bool dispatch_special_column;
    bool dispatch_special_row;
    bool dispatch_best_score;
    bool dispatch_scores;
    bool dispatch_block_scores;
    bool process_partition;
    bool variable_penalties;
    bool block_pruning;
    bool needleman_wunsch;
    bool smith_waterman;
    bool fork_processes;
    int maximum_seq0_len;
    int maximum_seq1_len;
    inline aligner_capabilities_t()
    {
      ::memset(this, 0, sizeof(::aligner_capabilities_t));
    }
};
class Grid;
class  Grid
{
  public:
    Grid(::Partition partition);
    virtual ~Grid();
    void setBlockHeight(int blockHeight);
    void setBlockWidth(int blockWidth);
    void splitGridVertically(int count);
    void splitGridHorizontally(int count);
    void splitGridVertically(int count, int *splits);
    void splitGridHorizontally(int count, int *splits);
    void getBlockPosition(int bx, int by, int *i0, int *j0, int *i1  = (0L), int *j1  = (0L)) const ;
    void setMinBlockSize(int minBlockWidth, int minBlockHeight);
    void setAdjustment(int adjustment);
    int getBlockAdjustment(int bx, int by) const ;
    int getGridWidth() const ;
    int getGridHeight() const ;
    int getBlockWidth(int bx, int by) const ;
    int getBlockHeight(int bx, int by) const ;
    int getHeight() const ;
    int getWidth() const ;
    const int *getBlockSplitHorizontal() const ;
    const int *getBlockSplitVertical() const ;
  private:
    int blockWidth;
    int blockHeight;
    int adjustment;
    int minBlockWidth;
    int minBlockHeight;
    int blockCountHorizontal;
    int *blockSplitHorizontal;
    int blockCountVertical;
    int *blockSplitVertical;
    int width;
    int height;
    ::Partition partition;
    void getBlockPositionH(int bx, int by, int *j0, int *j1) const ;
    void getBlockPositionV(int bx, int by, int *i0, int *i1) const ;
  public:
};
class  IAligner
{
  public:
    virtual ::aligner_capabilities_t getCapabilities() = 0 ;
    virtual void setManager(::IManager *manager) = 0 ;
    virtual const int *getForkWeights() = 0 ;
    virtual ::IAlignerParameters *getParameters() = 0 ;
    virtual const ::score_params_t *getScoreParameters() = 0 ;
    virtual void initialize() = 0 ;
    virtual void setSequences(const char *seq0, const char *seq1, int seq0_len, int seq1_len) = 0 ;
    virtual void unsetSequences() = 0 ;
    virtual void alignPartition(::Partition partition) = 0 ;
    virtual void finalize() = 0 ;
    virtual ::match_result_t matchLastColumn(const ::cell_t *buffer, const ::cell_t *base, int len, int goalScore) = 0 ;
    virtual const ::Grid *getGrid() const  = 0 ;
    virtual void clearStatistics() = 0 ;
    virtual void printInitialStatistics(::FILE *file) = 0 ;
    virtual void printStageStatistics(::FILE *file) = 0 ;
    virtual void printFinalStatistics(::FILE *file) = 0 ;
    virtual void printStatistics(::FILE *file) = 0 ;
    virtual const char *getProgressString() const  = 0 ;
    virtual long long int getProcessedCells() = 0 ;
  protected:
    inline ~IAligner()
    {
    }
    inline IAligner()
    {
    }
  public:
};
class AbstractAligner;
namespace std __attribute__((__visibility__("default"))) {
  typedef unsigned long int size_t;
  typedef long int ptrdiff_t;
  template < typename __type_tpl__param_1_0__ >
  class allocator;
  template <>
  class allocator<void>;
  template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
  struct uses_allocator;
  template < typename _CharT >
  struct char_traits;
  template <>
  struct char_traits<char>;
  template <>
  struct char_traits<wchar_t>;
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    template < typename _CharT, typename _Traits = ::std::char_traits<_CharT>, typename _Alloc = ::std::allocator<_CharT> >
    class basic_string;
    typedef ::std::__cxx11::basic_string<char> string;
    typedef ::std::__cxx11::basic_string<wchar_t> wstring;
  }
  void __throw_bad_exception() __attribute__((__noreturn__));
  void __throw_bad_alloc() __attribute__((__noreturn__));
  void __throw_bad_cast() __attribute__((__noreturn__));
  void __throw_bad_typeid() __attribute__((__noreturn__));
  void __throw_logic_error(const char *) __attribute__((__noreturn__));
  void __throw_domain_error(const char *) __attribute__((__noreturn__));
  void __throw_invalid_argument(const char *) __attribute__((__noreturn__));
  void __throw_length_error(const char *) __attribute__((__noreturn__));
  void __throw_out_of_range(const char *) __attribute__((__noreturn__));
  void __throw_out_of_range_fmt(const char *, ...) __attribute__((__noreturn__)) __attribute__((__format__(__gnu_printf__, 1, 2)));
  void __throw_runtime_error(const char *) __attribute__((__noreturn__));
  void __throw_range_error(const char *) __attribute__((__noreturn__));
  void __throw_overflow_error(const char *) __attribute__((__noreturn__));
  void __throw_underflow_error(const char *) __attribute__((__noreturn__));
  void __throw_ios_failure(const char *) __attribute__((__noreturn__));
  void __throw_system_error(int) __attribute__((__noreturn__));
  void __throw_future_error(int) __attribute__((__noreturn__));
  void __throw_bad_function_call() __attribute__((__noreturn__));
  struct  __true_type
  {
  };
  struct  __false_type
  {
  };
  template < bool __nontype_tpl_param_1_0__ >
  struct  __truth_type
  {
      typedef ::std::__false_type __type;
  };
  template <>
  struct  __truth_type<true>
  {
      typedef ::std::__true_type __type;
  };
  template < typename _Sp, typename _Tp >
  struct  __traitor
  {
      enum mcc_enum_anon_0
      {
        __value = bool(_Sp::__value) || bool(_Tp::__value)
      };
      typedef typename ::std::__truth_type< ::std::__traitor<_Sp, _Tp>::__value>::__type __type;
  };
  template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
  struct  __are_same
  {
      enum mcc_enum_anon_1
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template < typename _Tp >
  struct  __are_same<_Tp, _Tp>
  {
      enum mcc_enum_anon_2
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_void
  {
      enum mcc_enum_anon_3
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template <>
  struct  __is_void<void>
  {
      enum mcc_enum_anon_4
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_integer
  {
      enum mcc_enum_anon_5
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template <>
  struct  __is_integer<bool>
  {
      enum mcc_enum_anon_6
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<char>
  {
      enum mcc_enum_anon_7
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<signed char>
  {
      enum mcc_enum_anon_8
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<unsigned char>
  {
      enum mcc_enum_anon_9
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<wchar_t>
  {
      enum mcc_enum_anon_10
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<short int>
  {
      enum mcc_enum_anon_11
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<unsigned short int>
  {
      enum mcc_enum_anon_12
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<int>
  {
      enum mcc_enum_anon_13
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<unsigned int>
  {
      enum mcc_enum_anon_14
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<long int>
  {
      enum mcc_enum_anon_15
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<unsigned long int>
  {
      enum mcc_enum_anon_16
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<long long int>
  {
      enum mcc_enum_anon_17
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<unsigned long long int>
  {
      enum mcc_enum_anon_18
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<__int128>
  {
      enum mcc_enum_anon_19
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<unsigned __int128>
  {
      enum mcc_enum_anon_20
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_floating
  {
      enum mcc_enum_anon_21
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template <>
  struct  __is_floating<float>
  {
      enum mcc_enum_anon_22
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_floating<double>
  {
      enum mcc_enum_anon_23
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_floating<long double>
  {
      enum mcc_enum_anon_24
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_pointer
  {
      enum mcc_enum_anon_25
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template < typename _Tp >
  struct  __is_pointer<_Tp *>
  {
      enum mcc_enum_anon_26
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_arithmetic : ::std::__traitor< ::std::__is_integer<_Tp>, ::std::__is_floating<_Tp> >
  {
  };
  template < typename _Tp >
  struct  __is_scalar : ::std::__traitor< ::std::__is_arithmetic<_Tp>, ::std::__is_pointer<_Tp> >
  {
  };
  template < typename _Tp >
  struct  __is_char
  {
      enum mcc_enum_anon_27
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template <>
  struct  __is_char<char>
  {
      enum mcc_enum_anon_28
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_char<wchar_t>
  {
      enum mcc_enum_anon_29
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_byte
  {
      enum mcc_enum_anon_30
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template <>
  struct  __is_byte<char>
  {
      enum mcc_enum_anon_31
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_byte<signed char>
  {
      enum mcc_enum_anon_32
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_byte<unsigned char>
  {
      enum mcc_enum_anon_33
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_move_iterator
  {
      enum mcc_enum_anon_34
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template < typename _Iterator >
  inline _Iterator __miter_base(_Iterator __it);
  template < typename _Iterator >
  inline _Iterator __miter_base(_Iterator __it)
  {
    return __it;
  }
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  template < bool __nontype_tpl_param_1_0__, typename __type_tpl__param_1_1__ >
  struct  __enable_if
  {
  };
  template < typename _Tp >
  struct  __enable_if<true, _Tp>
  {
      typedef _Tp __type;
  };
  template < bool _Cond, typename _Iftrue, typename _Iffalse >
  struct  __conditional_type
  {
      typedef _Iftrue __type;
  };
  template < typename _Iftrue, typename _Iffalse >
  struct  __conditional_type<false, _Iftrue, _Iffalse>
  {
      typedef _Iffalse __type;
  };
  template < typename _Tp >
  struct  __add_unsigned
  {
    private:
      typedef ::__gnu_cxx::__enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
    public:
      typedef typename ::__gnu_cxx::__enable_if<std::__is_integer<_Tp>::__value, _Tp>::__type __type;
  };
  template <>
  struct  __add_unsigned<char>
  {
      typedef unsigned char __type;
  };
  template <>
  struct  __add_unsigned<signed char>
  {
      typedef unsigned char __type;
  };
  template <>
  struct  __add_unsigned<short int>
  {
      typedef unsigned short int __type;
  };
  template <>
  struct  __add_unsigned<int>
  {
      typedef unsigned int __type;
  };
  template <>
  struct  __add_unsigned<long int>
  {
      typedef unsigned long int __type;
  };
  template <>
  struct  __add_unsigned<long long int>
  {
      typedef unsigned long long int __type;
  };
  template <>
  struct __add_unsigned<bool>;
  template <>
  struct __add_unsigned<wchar_t>;
  template < typename _Tp >
  struct  __remove_unsigned
  {
    private:
      typedef ::__gnu_cxx::__enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
    public:
      typedef typename ::__gnu_cxx::__enable_if<std::__is_integer<_Tp>::__value, _Tp>::__type __type;
  };
  template <>
  struct  __remove_unsigned<char>
  {
      typedef signed char __type;
  };
  template <>
  struct  __remove_unsigned<unsigned char>
  {
      typedef signed char __type;
  };
  template <>
  struct  __remove_unsigned<unsigned short int>
  {
      typedef short int __type;
  };
  template <>
  struct  __remove_unsigned<unsigned int>
  {
      typedef int __type;
  };
  template <>
  struct  __remove_unsigned<unsigned long int>
  {
      typedef long int __type;
  };
  template <>
  struct  __remove_unsigned<unsigned long long int>
  {
      typedef long long int __type;
  };
  template <>
  struct __remove_unsigned<bool>;
  template <>
  struct __remove_unsigned<wchar_t>;
  template < typename _Type >
  inline bool __is_null_pointer(_Type *__ptr);
  template < typename _Type >
  inline bool __is_null_pointer(_Type *__ptr)
  {
    return __ptr == 0;
  }
  template < typename _Type >
  inline bool __is_null_pointer(_Type);
  template < typename _Type >
  inline bool __is_null_pointer(_Type)
  {
    return false;
  }
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = std::__is_integer<_Tp>::__value >
  struct  __promote
  {
      typedef double __type;
  };
  template < typename _Tp >
  struct  __promote<_Tp, false>
  {
  };
 /* Instantiation of class template '::std::__is_integer<long double>' */ 
  template <>
  struct  __promote<long double>
  {
      typedef long double __type;
  };
 /* Instantiation of class template '::std::__is_integer<double>' */ 
  template <>
  struct  __promote<double>
  {
      typedef double __type;
  };
 /* Instantiation of class template '::std::__is_integer<float>' */ 
  template <>
  struct  __promote<float>
  {
      typedef float __type;
  };
  template < typename _Tp, typename _Up, typename _Tp2 = typename ::__gnu_cxx::__promote<_Tp>::__type, typename _Up2 = typename ::__gnu_cxx::__promote<_Up>::__type >
  struct  __promote_2
  {
      typedef __typeof__(_Tp2() + _Up2()) __type;
  };
  template < typename _Tp, typename _Up, typename _Vp, typename _Tp2 = typename ::__gnu_cxx::__promote<_Tp>::__type, typename _Up2 = typename ::__gnu_cxx::__promote<_Up>::__type, typename _Vp2 = typename ::__gnu_cxx::__promote<_Vp>::__type >
  struct  __promote_3
  {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
  };
  template < typename _Tp, typename _Up, typename _Vp, typename _Wp, typename _Tp2 = typename ::__gnu_cxx::__promote<_Tp>::__type, typename _Up2 = typename ::__gnu_cxx::__promote<_Up>::__type, typename _Vp2 = typename ::__gnu_cxx::__promote<_Vp>::__type, typename _Wp2 = typename ::__gnu_cxx::__promote<_Wp>::__type >
  struct  __promote_4
  {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
  };
  template < typename _Value >
  struct  __numeric_traits_integer
  {
      static const _Value __min = ((_Value) -1 < 0 ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value) -1 < 0)) : (_Value)0);
      static const _Value __max = ((_Value) -1 < 0 ? ((((_Value)1 << (sizeof(_Value) * 8 - ((_Value) -1 < 0) - 1)) - 1) << 1) + 1 : ~((_Value)0));
      static const bool __is_signed = (_Value) -1 < 0;
      static const int __digits = sizeof(_Value) * 8 - ((_Value) -1 < 0);
  };
  template < typename _Value >
  const _Value __numeric_traits_integer<_Value>::__min;
  template < typename _Value >
  const _Value __numeric_traits_integer<_Value>::__max;
  template < typename _Value >
  const bool __numeric_traits_integer<_Value>::__is_signed;
  template < typename _Value >
  const int __numeric_traits_integer<_Value>::__digits;
  template < typename _Value >
  struct  __numeric_traits_floating
  {
      static const int __max_digits10 = 2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136;
      static const bool __is_signed = true;
      static const int __digits10 = std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18;
      static const int __max_exponent10 = std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932;
  };
  template < typename _Value >
  const int __numeric_traits_floating<_Value>::__max_digits10;
  template < typename _Value >
  const bool __numeric_traits_floating<_Value>::__is_signed;
  template < typename _Value >
  const int __numeric_traits_floating<_Value>::__digits10;
  template < typename _Value >
  const int __numeric_traits_floating<_Value>::__max_exponent10;
  template < typename _Value >
  struct  __numeric_traits : ::__gnu_cxx::__conditional_type<std::__is_integer<_Value>::__value, ::__gnu_cxx::__numeric_traits_integer<_Value>, ::__gnu_cxx::__numeric_traits_floating<_Value> >::__type
  {
  };
}
namespace std __attribute__((__visibility__("default"))) {
  template < typename _Tp >
  inline _Tp *__addressof(_Tp &__r);
  template < typename _Tp >
  inline _Tp *__addressof(_Tp &__r)
  {
    return __builtin_addressof(__r);
  }
  template < typename _Tp >
  inline void swap(_Tp &__a, _Tp &__b);
  template < typename _Tp >
  inline void swap(_Tp &__a, _Tp &__b)
  {
    _Tp __tmp = (__a);
    __a = __b;
    __b = __tmp;
  }
  template < typename _Tp, ::std::size_t _Nm >
  inline void swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]);
  template < typename _Tp, ::std::size_t _Nm >
  inline void swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
  {
    for (::std::size_t __n(0); __n < _Nm;  ++__n)
      {
        swap(__a[__n], __b[__n]);
      }
  }
  template < typename _U1, typename _U2 >
  class  __pair_base
  {
  };
  template < typename _T1, typename _T2 >
  struct  pair : private ::std::__pair_base<_T1, _T2>
  {
      typedef _T1 first_type;
      typedef _T2 second_type;
      _T1 first;
      _T2 second;
      inline pair()
        : first(), second()
      {
      }
      inline pair(const _T1 &__a, const _T2 &__b)
        : first(__a), second(__b)
      {
      }
      template < typename _U1, typename _U2 >
      inline pair(const ::std::pair<_U1, _U2> &__p)
        : first(__p.first), second(__p.second)
      {
      }
  };
  template < typename _T1, typename _T2 >
  inline bool operator ==(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y);
  template < typename _T1, typename _T2 >
  inline bool operator ==(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y)
  {
    return __x.first == __y.first && __x.second == __y.second;
  }
  template < typename _T1, typename _T2 >
  inline bool operator <(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y);
  template < typename _T1, typename _T2 >
  inline bool operator <(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y)
  {
    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
  }
  template < typename _T1, typename _T2 >
  inline bool operator !=(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y);
  template < typename _T1, typename _T2 >
  inline bool operator !=(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y)
  {
    return !(__x == __y);
  }
  template < typename _T1, typename _T2 >
  inline bool operator >(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y);
  template < typename _T1, typename _T2 >
  inline bool operator >(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y)
  {
    return __y < __x;
  }
  template < typename _T1, typename _T2 >
  inline bool operator <=(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y);
  template < typename _T1, typename _T2 >
  inline bool operator <=(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y)
  {
    return !(__y < __x);
  }
  template < typename _T1, typename _T2 >
  inline bool operator >=(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y);
  template < typename _T1, typename _T2 >
  inline bool operator >=(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y)
  {
    return !(__x < __y);
  }
  template < typename _T1, typename _T2 >
  inline ::std::pair<_T1, _T2> make_pair(_T1 __x, _T2 __y);
  template < typename _T1, typename _T2 >
  inline ::std::pair<_T1, _T2> make_pair(_T1 __x, _T2 __y)
  {
    return ::std::pair<_T1, _T2>(__x, __y);
  }
  struct  input_iterator_tag
  {
  };
  struct  output_iterator_tag
  {
  };
  struct  forward_iterator_tag : ::std::input_iterator_tag
  {
  };
  struct  bidirectional_iterator_tag : ::std::forward_iterator_tag
  {
  };
  struct  random_access_iterator_tag : ::std::bidirectional_iterator_tag
  {
  };
  template < typename _Category, typename _Tp, typename _Distance = ::std::ptrdiff_t, typename _Pointer = _Tp *, typename _Reference = _Tp & >
  struct  iterator
  {
      typedef _Category iterator_category;
      typedef _Tp value_type;
      typedef _Distance difference_type;
      typedef _Pointer pointer;
      typedef _Reference reference;
  };
  template < typename _Iterator >
  struct  iterator_traits
  {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
  };
  template < typename _Tp >
  struct  iterator_traits<_Tp *>
  {
      typedef ::std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef _Tp *pointer;
      typedef _Tp &reference;
  };
  template < typename _Tp >
  struct  iterator_traits<const _Tp *>
  {
      typedef ::std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef const _Tp *pointer;
      typedef const _Tp &reference;
  };
  template < typename _Iter >
  inline typename ::std::iterator_traits<_Iter>::iterator_category __iterator_category(const _Iter &);
  template < typename _Iter >
  inline typename ::std::iterator_traits<_Iter>::iterator_category __iterator_category(const _Iter &)
  {
    return typename ::std::iterator_traits<_Iter>::iterator_category();
  }
  template < typename _Iterator, bool _HasBase >
  struct  _Iter_base
  {
      typedef _Iterator iterator_type;
      static inline typename ::std::_Iter_base<_Iterator, _HasBase>::iterator_type _S_base(_Iterator __it)
      {
        return __it;
      }
  };
  template < typename _Iterator >
  struct  _Iter_base<_Iterator, true>
  {
      typedef typename _Iterator::iterator_type iterator_type;
      static inline typename ::std::_Iter_base<_Iterator, true>::iterator_type _S_base(_Iterator __it)
      {
        return __it.base();
      }
  };
  template < typename __type_tpl__param_1_0__ >
  struct _List_iterator;
  template < typename __type_tpl__param_1_0__ >
  struct _List_const_iterator;
  template < typename _InputIterator >
  inline typename ::std::iterator_traits<_InputIterator>::difference_type __distance(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag);
  template < typename _InputIterator >
  inline typename ::std::iterator_traits<_InputIterator>::difference_type __distance(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag)
  {
    typename ::std::iterator_traits<_InputIterator>::difference_type __n = 0;
    while (__first != __last)
      {
         ++__first;
         ++__n;
      }
    return __n;
  }
  template < typename _RandomAccessIterator >
  inline typename ::std::iterator_traits<_RandomAccessIterator>::difference_type __distance(_RandomAccessIterator __first, _RandomAccessIterator __last, ::std::random_access_iterator_tag);
  template < typename _RandomAccessIterator >
  inline typename ::std::iterator_traits<_RandomAccessIterator>::difference_type __distance(_RandomAccessIterator __first, _RandomAccessIterator __last, ::std::random_access_iterator_tag)
  {
    return __last - __first;
  }
  template < typename _Tp >
  ::std::ptrdiff_t __distance(::std::_List_iterator<_Tp>, ::std::_List_iterator<_Tp>, ::std::input_iterator_tag);
  template < typename _Tp >
  ::std::ptrdiff_t __distance(::std::_List_const_iterator<_Tp>, ::std::_List_const_iterator<_Tp>, ::std::input_iterator_tag);
  template < typename _InputIterator >
  inline typename ::std::iterator_traits<_InputIterator>::difference_type distance(_InputIterator __first, _InputIterator __last);
  template < typename _InputIterator >
  inline typename ::std::iterator_traits<_InputIterator>::difference_type distance(_InputIterator __first, _InputIterator __last)
  {
    return std::__distance(__first, __last, std::__iterator_category(__first));
  }
  template < typename _InputIterator, typename _Distance >
  inline void __advance(_InputIterator &__i, _Distance __n, ::std::input_iterator_tag);
  template < typename _InputIterator, typename _Distance >
  inline void __advance(_InputIterator &__i, _Distance __n, ::std::input_iterator_tag)
  {
    ;
    while (__n--)
      {
         ++__i;
      }
  }
  template < typename _BidirectionalIterator, typename _Distance >
  inline void __advance(_BidirectionalIterator &__i, _Distance __n, ::std::bidirectional_iterator_tag);
  template < typename _BidirectionalIterator, typename _Distance >
  inline void __advance(_BidirectionalIterator &__i, _Distance __n, ::std::bidirectional_iterator_tag)
  {
    if (__n > 0)
      {
        while (__n--)
          {
             ++__i;
          }
      }
    else
      {
        while (__n++)
          {
             --__i;
          }
      }
  }
  template < typename _RandomAccessIterator, typename _Distance >
  inline void __advance(_RandomAccessIterator &__i, _Distance __n, ::std::random_access_iterator_tag);
  template < typename _RandomAccessIterator, typename _Distance >
  inline void __advance(_RandomAccessIterator &__i, _Distance __n, ::std::random_access_iterator_tag)
  {
    __i += __n;
  }
  template < typename _InputIterator, typename _Distance >
  inline void advance(_InputIterator &__i, _Distance __n);
  template < typename _InputIterator, typename _Distance >
  inline void advance(_InputIterator &__i, _Distance __n)
  {
    typename ::std::iterator_traits<_InputIterator>::difference_type __d = __n;
    std::__advance(__i, __d, std::__iterator_category(__i));
  }
  template < typename _Iterator >
  class  reverse_iterator : public ::std::iterator<typename ::std::iterator_traits<_Iterator>::iterator_category, typename ::std::iterator_traits<_Iterator>::value_type, typename ::std::iterator_traits<_Iterator>::difference_type, typename ::std::iterator_traits<_Iterator>::pointer, typename ::std::iterator_traits<_Iterator>::reference>
  {
    protected:
      _Iterator current;
      typedef ::std::iterator_traits<_Iterator> __traits_type;
    public:
      typedef _Iterator iterator_type;
      typedef typename ::std::iterator_traits<_Iterator>::difference_type difference_type;
      typedef typename ::std::iterator_traits<_Iterator>::pointer pointer;
      typedef typename ::std::iterator_traits<_Iterator>::reference reference;
      inline reverse_iterator()
        : current()
      {
      }
      inline explicit reverse_iterator(typename ::std::reverse_iterator<_Iterator>::iterator_type __x)
        : current(__x)
      {
      }
      inline reverse_iterator(const ::std::reverse_iterator<_Iterator> &__x)
        : current(__x.current)
      {
      }
      template < typename _Iter >
      inline reverse_iterator(const ::std::reverse_iterator<_Iter> &__x)
        : current(__x.base())
      {
      }
      inline typename ::std::reverse_iterator<_Iterator>::iterator_type base() const 
      {
        return ::std::reverse_iterator<_Iterator>::current;
      }
      inline typename ::std::reverse_iterator<_Iterator>::reference operator *() const 
      {
        _Iterator __tmp = ::std::reverse_iterator<_Iterator>::current;
        return * --__tmp;
      }
      inline typename ::std::reverse_iterator<_Iterator>::pointer operator ->() const 
      {
        return std::__addressof((*this).operator *());
      }
      inline ::std::reverse_iterator<_Iterator> &operator ++()
      {
         --::std::reverse_iterator<_Iterator>::current;
        return *this;
      }
      inline ::std::reverse_iterator<_Iterator> operator ++(int)
      {
        ::std::reverse_iterator<_Iterator> __tmp = *this;
         --::std::reverse_iterator<_Iterator>::current;
        return __tmp;
      }
      inline ::std::reverse_iterator<_Iterator> &operator --()
      {
         ++::std::reverse_iterator<_Iterator>::current;
        return *this;
      }
      inline ::std::reverse_iterator<_Iterator> operator --(int)
      {
        ::std::reverse_iterator<_Iterator> __tmp = *this;
         ++::std::reverse_iterator<_Iterator>::current;
        return __tmp;
      }
      inline ::std::reverse_iterator<_Iterator> operator +(typename ::std::reverse_iterator<_Iterator>::difference_type __n) const 
      {
        return ::std::reverse_iterator<_Iterator>(::std::reverse_iterator<_Iterator>::current - __n);
      }
      inline ::std::reverse_iterator<_Iterator> &operator +=(typename ::std::reverse_iterator<_Iterator>::difference_type __n)
      {
        ::std::reverse_iterator<_Iterator>::current -= __n;
        return *this;
      }
      inline ::std::reverse_iterator<_Iterator> operator -(typename ::std::reverse_iterator<_Iterator>::difference_type __n) const 
      {
        return ::std::reverse_iterator<_Iterator>(::std::reverse_iterator<_Iterator>::current + __n);
      }
      inline ::std::reverse_iterator<_Iterator> &operator -=(typename ::std::reverse_iterator<_Iterator>::difference_type __n)
      {
        ::std::reverse_iterator<_Iterator>::current += __n;
        return *this;
      }
      inline typename ::std::reverse_iterator<_Iterator>::reference operator [](typename ::std::reverse_iterator<_Iterator>::difference_type __n) const 
      {
        return *(*this + __n);
      }
  };
  template < typename _Iterator >
  inline bool operator ==(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator ==(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return __x.base() == __y.base();
  }
  template < typename _Iterator >
  inline bool operator <(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator <(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return __y.base() < __x.base();
  }
  template < typename _Iterator >
  inline bool operator !=(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator !=(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return !(__x == __y);
  }
  template < typename _Iterator >
  inline bool operator >(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator >(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return __y < __x;
  }
  template < typename _Iterator >
  inline bool operator <=(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator <=(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Iterator >
  inline bool operator >=(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator >=(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return !(__x < __y);
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator ==(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator ==(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return __x.base() == __y.base();
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator <(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator <(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return __y.base() < __x.base();
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator !=(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator !=(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return !(__x == __y);
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator >(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator >(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return __y < __x;
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator <=(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator <=(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return !(__y < __x);
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator >=(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator >=(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Iterator >
  inline typename ::std::reverse_iterator<_Iterator>::difference_type operator -(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline typename ::std::reverse_iterator<_Iterator>::difference_type operator -(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return __y.base() - __x.base();
  }
  template < typename _IteratorL, typename _IteratorR >
  inline typename ::std::reverse_iterator<_IteratorL>::difference_type operator -(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline typename ::std::reverse_iterator<_IteratorL>::difference_type operator -(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return __y.base() - __x.base();
  }
  template < typename _Iterator >
  inline ::std::reverse_iterator<_Iterator> operator +(typename ::std::reverse_iterator<_Iterator>::difference_type __n, const ::std::reverse_iterator<_Iterator> &__x);
  template < typename _Iterator >
  inline ::std::reverse_iterator<_Iterator> operator +(typename ::std::reverse_iterator<_Iterator>::difference_type __n, const ::std::reverse_iterator<_Iterator> &__x)
  {
    return ::std::reverse_iterator<_Iterator>(__x.base() - __n);
  }
 /* Instantiation of class template '::std::iterator< ::std::output_iterator_tag, void, void, void, void>' */ 
  template < typename _Container >
  class  back_insert_iterator : public ::std::iterator< ::std::output_iterator_tag, void, void, void, void>
  {
    protected:
      _Container *container;
    public:
      typedef _Container container_type;
      inline explicit back_insert_iterator(_Container &__x)
        : container(std::__addressof(__x))
      {
      }
      inline ::std::back_insert_iterator<_Container> &operator =(typename _Container::const_reference __value)
      {
        ::std::back_insert_iterator<_Container>::container->push_back(__value);
        return *this;
      }
      inline ::std::back_insert_iterator<_Container> &operator *()
      {
        return *this;
      }
      inline ::std::back_insert_iterator<_Container> &operator ++()
      {
        return *this;
      }
      inline ::std::back_insert_iterator<_Container> operator ++(int)
      {
        return *this;
      }
  };
  template < typename _Container >
  inline ::std::back_insert_iterator<_Container> back_inserter(_Container &__x);
  template < typename _Container >
  inline ::std::back_insert_iterator<_Container> back_inserter(_Container &__x)
  {
    return ::std::back_insert_iterator<_Container>(__x);
  }
  template < typename _Container >
  class  front_insert_iterator : public ::std::iterator< ::std::output_iterator_tag, void, void, void, void>
  {
    protected:
      _Container *container;
    public:
      typedef _Container container_type;
      inline explicit front_insert_iterator(_Container &__x)
        : container(std::__addressof(__x))
      {
      }
      inline ::std::front_insert_iterator<_Container> &operator =(typename _Container::const_reference __value)
      {
        ::std::front_insert_iterator<_Container>::container->push_front(__value);
        return *this;
      }
      inline ::std::front_insert_iterator<_Container> &operator *()
      {
        return *this;
      }
      inline ::std::front_insert_iterator<_Container> &operator ++()
      {
        return *this;
      }
      inline ::std::front_insert_iterator<_Container> operator ++(int)
      {
        return *this;
      }
  };
  template < typename _Container >
  inline ::std::front_insert_iterator<_Container> front_inserter(_Container &__x);
  template < typename _Container >
  inline ::std::front_insert_iterator<_Container> front_inserter(_Container &__x)
  {
    return ::std::front_insert_iterator<_Container>(__x);
  }
  template < typename _Container >
  class  insert_iterator : public ::std::iterator< ::std::output_iterator_tag, void, void, void, void>
  {
    protected:
      _Container *container;
      typename _Container::iterator iter;
    public:
      typedef _Container container_type;
      inline insert_iterator(_Container &__x, typename _Container::iterator __i)
        : container(std::__addressof(__x)), iter(__i)
      {
      }
      inline ::std::insert_iterator<_Container> &operator =(typename _Container::const_reference __value)
      {
        ::std::insert_iterator<_Container>::iter = ::std::insert_iterator<_Container>::container->insert(::std::insert_iterator<_Container>::iter, __value);
         ++::std::insert_iterator<_Container>::iter;
        return *this;
      }
      inline ::std::insert_iterator<_Container> &operator *()
      {
        return *this;
      }
      inline ::std::insert_iterator<_Container> &operator ++()
      {
        return *this;
      }
      inline ::std::insert_iterator<_Container> &operator ++(int)
      {
        return *this;
      }
  };
  template < typename _Container, typename _Iterator >
  inline ::std::insert_iterator<_Container> inserter(_Container &__x, _Iterator __i);
  template < typename _Container, typename _Iterator >
  inline ::std::insert_iterator<_Container> inserter(_Container &__x, _Iterator __i)
  {
    return ::std::insert_iterator<_Container>(__x, typename _Container::iterator(__i));
  }
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  using ::std::iterator_traits;
  using ::std::iterator;
  template < typename _Iterator, typename _Container >
  class  __normal_iterator
  {
    protected:
      _Iterator _M_current;
      typedef ::std::iterator_traits<_Iterator> __traits_type;
    public:
      typedef _Iterator iterator_type;
      typedef typename ::std::iterator_traits<_Iterator>::iterator_category iterator_category;
      typedef typename ::std::iterator_traits<_Iterator>::value_type value_type;
      typedef typename ::std::iterator_traits<_Iterator>::difference_type difference_type;
      typedef typename ::std::iterator_traits<_Iterator>::reference reference;
      typedef typename ::std::iterator_traits<_Iterator>::pointer pointer;
      inline __normal_iterator()
        : _M_current(_Iterator())
      {
      }
      inline explicit __normal_iterator(const _Iterator &__i)
        : _M_current(__i)
      {
      }
      template < typename _Iter >
      inline __normal_iterator(const ::__gnu_cxx::__normal_iterator<_Iter, typename ::__gnu_cxx::__enable_if<std::__are_same<_Iter, typename _Container::pointer>::__value, _Container>::__type> &__i)
        : _M_current(__i.base())
      {
      }
      inline typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::reference operator *() const 
      {
        return *::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current;
      }
      inline typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::pointer operator ->() const 
      {
        return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current;
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &operator ++()
      {
         ++::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current;
        return *this;
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> operator ++(int)
      {
        return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>(::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current++);
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &operator --()
      {
         --::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current;
        return *this;
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> operator --(int)
      {
        return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>(::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current--);
      }
      inline typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::reference operator [](typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type __n) const 
      {
        return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current[__n];
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &operator +=(typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type __n)
      {
        ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current += __n;
        return *this;
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> operator +(typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type __n) const 
      {
        return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>(::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current + __n);
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &operator -=(typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type __n)
      {
        ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current -= __n;
        return *this;
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> operator -(typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type __n) const 
      {
        return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>(::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current - __n);
      }
      inline const _Iterator &base() const 
      {
        return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current;
      }
  };
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator ==(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator ==(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs)
  {
    return __lhs.base() == __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline bool operator ==(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs);
  template < typename _Iterator, typename _Container >
  inline bool operator ==(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs)
  {
    return __lhs.base() == __rhs.base();
  }
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator !=(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator !=(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs)
  {
    return __lhs.base() != __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline bool operator !=(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs);
  template < typename _Iterator, typename _Container >
  inline bool operator !=(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs)
  {
    return __lhs.base() != __rhs.base();
  }
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator <(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator <(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs)
  {
    return __lhs.base() < __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline bool operator <(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs);
  template < typename _Iterator, typename _Container >
  inline bool operator <(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs)
  {
    return __lhs.base() < __rhs.base();
  }
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator >(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator >(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs)
  {
    return __lhs.base() > __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline bool operator >(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs);
  template < typename _Iterator, typename _Container >
  inline bool operator >(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs)
  {
    return __lhs.base() > __rhs.base();
  }
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator <=(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator <=(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs)
  {
    return __lhs.base() <= __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline bool operator <=(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs);
  template < typename _Iterator, typename _Container >
  inline bool operator <=(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs)
  {
    return __lhs.base() <= __rhs.base();
  }
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator >=(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator >=(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs)
  {
    return __lhs.base() >= __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline bool operator >=(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs);
  template < typename _Iterator, typename _Container >
  inline bool operator >=(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs)
  {
    return __lhs.base() >= __rhs.base();
  }
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline typename ::__gnu_cxx::__normal_iterator<_IteratorL, _Container>::difference_type operator -(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline typename ::__gnu_cxx::__normal_iterator<_IteratorL, _Container>::difference_type operator -(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs)
  {
    return __lhs.base() - __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type operator -(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs);
  template < typename _Iterator, typename _Container >
  inline typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type operator -(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs)
  {
    return __lhs.base() - __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> operator +(typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type __n, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__i);
  template < typename _Iterator, typename _Container >
  inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> operator +(typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type __n, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__i)
  {
    return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>(__i.base() + __n);
  }
}
namespace std __attribute__((__visibility__("default"))) {
  template < typename _Iterator, typename _Container >
  _Iterator __niter_base(::__gnu_cxx::__normal_iterator<_Iterator, _Container> __it);
  template < typename _Iterator, typename _Container >
  _Iterator __niter_base(::__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
  {
    return __it.base();
  }
  namespace __debug { }
}
namespace __gnu_debug {
  using namespace ::std::__debug;
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  namespace __ops {
    struct  _Iter_less_iter
    {
        template < typename _Iterator1, typename _Iterator2 >
        inline bool operator ()(_Iterator1 __it1, _Iterator2 __it2) const 
        {
          return *__it1 < *__it2;
        }
    };
    inline ::__gnu_cxx::__ops::_Iter_less_iter __iter_less_iter()
    {
      return ::__gnu_cxx::__ops::_Iter_less_iter();
    }
    struct  _Iter_less_val
    {
        inline _Iter_less_val()
        {
        }
        inline explicit _Iter_less_val(::__gnu_cxx::__ops::_Iter_less_iter)
        {
        }
        template < typename _Iterator, typename _Value >
        inline bool operator ()(_Iterator __it, _Value &__val) const 
        {
          return *__it < __val;
        }
    };
    inline ::__gnu_cxx::__ops::_Iter_less_val __iter_less_val()
    {
      return ::__gnu_cxx::__ops::_Iter_less_val();
    }
    inline ::__gnu_cxx::__ops::_Iter_less_val __iter_comp_val(::__gnu_cxx::__ops::_Iter_less_iter)
    {
      return ::__gnu_cxx::__ops::_Iter_less_val();
    }
    struct  _Val_less_iter
    {
        inline _Val_less_iter()
        {
        }
        inline explicit _Val_less_iter(::__gnu_cxx::__ops::_Iter_less_iter)
        {
        }
        template < typename _Value, typename _Iterator >
        inline bool operator ()(_Value &__val, _Iterator __it) const 
        {
          return __val < *__it;
        }
    };
    inline ::__gnu_cxx::__ops::_Val_less_iter __val_less_iter()
    {
      return ::__gnu_cxx::__ops::_Val_less_iter();
    }
    inline ::__gnu_cxx::__ops::_Val_less_iter __val_comp_iter(::__gnu_cxx::__ops::_Iter_less_iter)
    {
      return ::__gnu_cxx::__ops::_Val_less_iter();
    }
    struct  _Iter_equal_to_iter
    {
        template < typename _Iterator1, typename _Iterator2 >
        inline bool operator ()(_Iterator1 __it1, _Iterator2 __it2) const 
        {
          return *__it1 == *__it2;
        }
    };
    inline ::__gnu_cxx::__ops::_Iter_equal_to_iter __iter_equal_to_iter()
    {
      return ::__gnu_cxx::__ops::_Iter_equal_to_iter();
    }
    struct  _Iter_equal_to_val
    {
        template < typename _Iterator, typename _Value >
        inline bool operator ()(_Iterator __it, _Value &__val) const 
        {
          return *__it == __val;
        }
    };
    inline ::__gnu_cxx::__ops::_Iter_equal_to_val __iter_equal_to_val()
    {
      return ::__gnu_cxx::__ops::_Iter_equal_to_val();
    }
    inline ::__gnu_cxx::__ops::_Iter_equal_to_val __iter_comp_val(::__gnu_cxx::__ops::_Iter_equal_to_iter)
    {
      return ::__gnu_cxx::__ops::_Iter_equal_to_val();
    }
    template < typename _Compare >
    struct  _Iter_comp_iter
    {
        _Compare _M_comp;
        inline explicit _Iter_comp_iter(_Compare __comp)
          : _M_comp(__comp)
        {
        }
        template < typename _Iterator1, typename _Iterator2 >
        inline bool operator ()(_Iterator1 __it1, _Iterator2 __it2)
        {
          return bool(::__gnu_cxx::__ops::_Iter_comp_iter<_Compare>::_M_comp(*__it1, *__it2));
        }
    };
    template < typename _Compare >
    inline ::__gnu_cxx::__ops::_Iter_comp_iter<_Compare> __iter_comp_iter(_Compare __comp);
    template < typename _Compare >
    inline ::__gnu_cxx::__ops::_Iter_comp_iter<_Compare> __iter_comp_iter(_Compare __comp)
    {
      return ::__gnu_cxx::__ops::_Iter_comp_iter<_Compare>(__comp);
    }
    template < typename _Compare >
    struct  _Iter_comp_val
    {
        _Compare _M_comp;
        inline explicit _Iter_comp_val(_Compare __comp)
          : _M_comp(__comp)
        {
        }
        inline explicit _Iter_comp_val(const ::__gnu_cxx::__ops::_Iter_comp_iter<_Compare> &__comp)
          : _M_comp(__comp._M_comp)
        {
        }
        template < typename _Iterator, typename _Value >
        inline bool operator ()(_Iterator __it, _Value &__val)
        {
          return bool(::__gnu_cxx::__ops::_Iter_comp_val<_Compare>::_M_comp(*__it, __val));
        }
    };
    template < typename _Compare >
    inline ::__gnu_cxx::__ops::_Iter_comp_val<_Compare> __iter_comp_val(_Compare __comp);
    template < typename _Compare >
    inline ::__gnu_cxx::__ops::_Iter_comp_val<_Compare> __iter_comp_val(_Compare __comp)
    {
      return ::__gnu_cxx::__ops::_Iter_comp_val<_Compare>(__comp);
    }
    template < typename _Compare >
    inline ::__gnu_cxx::__ops::_Iter_comp_val<_Compare> __iter_comp_val(::__gnu_cxx::__ops::_Iter_comp_iter<_Compare> __comp);
    template < typename _Compare >
    inline ::__gnu_cxx::__ops::_Iter_comp_val<_Compare> __iter_comp_val(::__gnu_cxx::__ops::_Iter_comp_iter<_Compare> __comp)
    {
      return ::__gnu_cxx::__ops::_Iter_comp_val<_Compare>(__comp);
    }
    template < typename _Compare >
    struct  _Val_comp_iter
    {
        _Compare _M_comp;
        inline explicit _Val_comp_iter(_Compare __comp)
          : _M_comp(__comp)
        {
        }
        inline explicit _Val_comp_iter(const ::__gnu_cxx::__ops::_Iter_comp_iter<_Compare> &__comp)
          : _M_comp(__comp._M_comp)
        {
        }
        template < typename _Value, typename _Iterator >
        inline bool operator ()(_Value &__val, _Iterator __it)
        {
          return bool(::__gnu_cxx::__ops::_Val_comp_iter<_Compare>::_M_comp(__val, *__it));
        }
    };
    template < typename _Compare >
    inline ::__gnu_cxx::__ops::_Val_comp_iter<_Compare> __val_comp_iter(_Compare __comp);
    template < typename _Compare >
    inline ::__gnu_cxx::__ops::_Val_comp_iter<_Compare> __val_comp_iter(_Compare __comp)
    {
      return ::__gnu_cxx::__ops::_Val_comp_iter<_Compare>(__comp);
    }
    template < typename _Compare >
    inline ::__gnu_cxx::__ops::_Val_comp_iter<_Compare> __val_comp_iter(::__gnu_cxx::__ops::_Iter_comp_iter<_Compare> __comp);
    template < typename _Compare >
    inline ::__gnu_cxx::__ops::_Val_comp_iter<_Compare> __val_comp_iter(::__gnu_cxx::__ops::_Iter_comp_iter<_Compare> __comp)
    {
      return ::__gnu_cxx::__ops::_Val_comp_iter<_Compare>(__comp);
    }
    template < typename _Value >
    struct  _Iter_equals_val
    {
        _Value &_M_value;
        inline explicit _Iter_equals_val(_Value &__value)
          : _M_value(__value)
        {
        }
        template < typename _Iterator >
        inline bool operator ()(_Iterator __it)
        {
          return *__it == ::__gnu_cxx::__ops::_Iter_equals_val<_Value>::_M_value;
        }
    };
    template < typename _Value >
    inline ::__gnu_cxx::__ops::_Iter_equals_val<_Value> __iter_equals_val(_Value &__val);
    template < typename _Value >
    inline ::__gnu_cxx::__ops::_Iter_equals_val<_Value> __iter_equals_val(_Value &__val)
    {
      return ::__gnu_cxx::__ops::_Iter_equals_val<_Value>(__val);
    }
    template < typename _Iterator1 >
    struct  _Iter_equals_iter
    {
        _Iterator1 _M_it1;
        inline explicit _Iter_equals_iter(_Iterator1 __it1)
          : _M_it1(__it1)
        {
        }
        template < typename _Iterator2 >
        inline bool operator ()(_Iterator2 __it2)
        {
          return *__it2 == *::__gnu_cxx::__ops::_Iter_equals_iter<_Iterator1>::_M_it1;
        }
    };
    template < typename _Iterator >
    inline ::__gnu_cxx::__ops::_Iter_equals_iter<_Iterator> __iter_comp_iter(::__gnu_cxx::__ops::_Iter_equal_to_iter, _Iterator __it);
    template < typename _Iterator >
    inline ::__gnu_cxx::__ops::_Iter_equals_iter<_Iterator> __iter_comp_iter(::__gnu_cxx::__ops::_Iter_equal_to_iter, _Iterator __it)
    {
      return ::__gnu_cxx::__ops::_Iter_equals_iter<_Iterator>(__it);
    }
    template < typename _Predicate >
    struct  _Iter_pred
    {
        _Predicate _M_pred;
        inline explicit _Iter_pred(_Predicate __pred)
          : _M_pred(__pred)
        {
        }
        template < typename _Iterator >
        inline bool operator ()(_Iterator __it)
        {
          return bool(::__gnu_cxx::__ops::_Iter_pred<_Predicate>::_M_pred(*__it));
        }
    };
    template < typename _Predicate >
    inline ::__gnu_cxx::__ops::_Iter_pred<_Predicate> __pred_iter(_Predicate __pred);
    template < typename _Predicate >
    inline ::__gnu_cxx::__ops::_Iter_pred<_Predicate> __pred_iter(_Predicate __pred)
    {
      return ::__gnu_cxx::__ops::_Iter_pred<_Predicate>(__pred);
    }
    template < typename _Compare, typename _Value >
    struct  _Iter_comp_to_val
    {
        _Compare _M_comp;
        _Value &_M_value;
        inline _Iter_comp_to_val(_Compare __comp, _Value &__value)
          : _M_comp(__comp), _M_value(__value)
        {
        }
        template < typename _Iterator >
        inline bool operator ()(_Iterator __it)
        {
          return bool(::__gnu_cxx::__ops::_Iter_comp_to_val<_Compare, _Value>::_M_comp(*__it, ::__gnu_cxx::__ops::_Iter_comp_to_val<_Compare, _Value>::_M_value));
        }
    };
    template < typename _Compare, typename _Value >
    ::__gnu_cxx::__ops::_Iter_comp_to_val<_Compare, _Value> __iter_comp_val(_Compare __comp, _Value &__val);
    template < typename _Compare, typename _Value >
    ::__gnu_cxx::__ops::_Iter_comp_to_val<_Compare, _Value> __iter_comp_val(_Compare __comp, _Value &__val)
    {
      return ::__gnu_cxx::__ops::_Iter_comp_to_val<_Compare, _Value>(__comp, __val);
    }
    template < typename _Compare, typename _Iterator1 >
    struct  _Iter_comp_to_iter
    {
        _Compare _M_comp;
        _Iterator1 _M_it1;
        inline _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
          : _M_comp(__comp), _M_it1(__it1)
        {
        }
        template < typename _Iterator2 >
        inline bool operator ()(_Iterator2 __it2)
        {
          return bool(::__gnu_cxx::__ops::_Iter_comp_to_iter<_Compare, _Iterator1>::_M_comp(*__it2, *::__gnu_cxx::__ops::_Iter_comp_to_iter<_Compare, _Iterator1>::_M_it1));
        }
    };
    template < typename _Compare, typename _Iterator >
    inline ::__gnu_cxx::__ops::_Iter_comp_to_iter<_Compare, _Iterator> __iter_comp_iter(::__gnu_cxx::__ops::_Iter_comp_iter<_Compare> __comp, _Iterator __it);
    template < typename _Compare, typename _Iterator >
    inline ::__gnu_cxx::__ops::_Iter_comp_to_iter<_Compare, _Iterator> __iter_comp_iter(::__gnu_cxx::__ops::_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    {
      return ::__gnu_cxx::__ops::_Iter_comp_to_iter<_Compare, _Iterator>(__comp._M_comp, __it);
    }
    template < typename _Predicate >
    struct  _Iter_negate
    {
        _Predicate _M_pred;
        inline explicit _Iter_negate(_Predicate __pred)
          : _M_pred(__pred)
        {
        }
        template < typename _Iterator >
        inline bool operator ()(_Iterator __it)
        {
          return !bool(::__gnu_cxx::__ops::_Iter_negate<_Predicate>::_M_pred(*__it));
        }
    };
    template < typename _Predicate >
    inline ::__gnu_cxx::__ops::_Iter_negate<_Predicate> __negate(::__gnu_cxx::__ops::_Iter_pred<_Predicate> __pred);
    template < typename _Predicate >
    inline ::__gnu_cxx::__ops::_Iter_negate<_Predicate> __negate(::__gnu_cxx::__ops::_Iter_pred<_Predicate> __pred)
    {
      return ::__gnu_cxx::__ops::_Iter_negate<_Predicate>(__pred._M_pred);
    }
  }
}
namespace std __attribute__((__visibility__("default"))) {
   template < bool _BoolType >
  struct  __iter_swap
  {
      template < typename _ForwardIterator1, typename _ForwardIterator2 >
      static inline void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
      {
        typedef typename ::std::iterator_traits<_ForwardIterator1>::value_type _ValueType1;
        _ValueType1 __tmp = (*__a);
        *__a = *__b;
        *__b = __tmp;
      }
  };
  template <>
  struct  __iter_swap<true>
  {
      template < typename _ForwardIterator1, typename _ForwardIterator2 >
      static inline void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
      {
        swap(*__a, *__b);
      }
  };
  template < typename _ForwardIterator1, typename _ForwardIterator2 >
  inline void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b);
  template < typename _ForwardIterator1, typename _ForwardIterator2 >
  inline void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_ForwardIterator2>::value_type _ValueType2;
    typedef typename ::std::iterator_traits<_ForwardIterator1>::reference _ReferenceType1;
    typedef typename ::std::iterator_traits<_ForwardIterator2>::reference _ReferenceType2;
    std::__iter_swap<(__are_same<_ValueType1, _ValueType2>::__value && __are_same<_ValueType1 &, _ReferenceType1>::__value) && __are_same<_ValueType2 &, _ReferenceType2>::__value>::iter_swap(__a, __b);
  }
  template < typename _ForwardIterator1, typename _ForwardIterator2 >
  _ForwardIterator2 swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2);
  template < typename _ForwardIterator1, typename _ForwardIterator2 >
  _ForwardIterator2 swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)
  {
    ;
    for (; __first1 != __last1; ( ++__first1, (void) ++__first2))
      {
        std::iter_swap(__first1, __first2);
      }
    return __first2;
  }
  template < typename _Tp >
  inline const _Tp &min(const _Tp &__a, const _Tp &__b);
  template < typename _Tp >
  inline const _Tp &min(const _Tp &__a, const _Tp &__b)
  {
    if (__b < __a)
      {
        return __b;
      }
    return __a;
  }
  template < typename _Tp >
  inline const _Tp &max(const _Tp &__a, const _Tp &__b);
  template < typename _Tp >
  inline const _Tp &max(const _Tp &__a, const _Tp &__b)
  {
    if (__a < __b)
      {
        return __b;
      }
    return __a;
  }
  template < typename _Tp, typename _Compare >
  inline const _Tp &min(const _Tp &__a, const _Tp &__b, _Compare __comp);
  template < typename _Tp, typename _Compare >
  inline const _Tp &min(const _Tp &__a, const _Tp &__b, _Compare __comp)
  {
    if (__comp(__b, __a))
      {
        return __b;
      }
    return __a;
  }
  template < typename _Tp, typename _Compare >
  inline const _Tp &max(const _Tp &__a, const _Tp &__b, _Compare __comp);
  template < typename _Tp, typename _Compare >
  inline const _Tp &max(const _Tp &__a, const _Tp &__b, _Compare __comp)
  {
    if (__comp(__a, __b))
      {
        return __b;
      }
    return __a;
  }
  template < typename _Iterator >
  inline _Iterator __niter_base(_Iterator __it);
  template < typename _Iterator >
  inline _Iterator __niter_base(_Iterator __it)
  {
    return __it;
  }
  template < bool __nontype_tpl_param_1_0__, bool __nontype_tpl_param_1_1__, typename __type_tpl__param_1_2__ >
  struct  __copy_move
  {
      template < typename _II, typename _OI >
      static inline _OI __copy_m(_II __first, _II __last, _OI __result)
      {
        for (; __first != __last; ( ++__result, (void) ++__first))
          {
            *__result = *__first;
          }
        return __result;
      }
  };
  template <>
  struct  __copy_move<false, false, ::std::random_access_iterator_tag>
  {
      template < typename _II, typename _OI >
      static inline _OI __copy_m(_II __first, _II __last, _OI __result)
      {
        typedef typename ::std::iterator_traits<_II>::difference_type _Distance;
        for (_Distance __n = __last - __first; __n > 0;  --__n)
          {
            *__result = *__first;
             ++__first;
             ++__result;
          }
        return __result;
      }
  };
  template < bool _IsMove >
  struct  __copy_move<_IsMove, true, ::std::random_access_iterator_tag>
  {
      template < typename _Tp >
      static inline _Tp *__copy_m(const _Tp *__first, const _Tp *__last, _Tp *__result)
      {
        const ::std::ptrdiff_t _Num = __last - __first;
        if (_Num)
          {
            __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
          }
        return __result + _Num;
      }
  };
  template < bool _IsMove, typename _II, typename _OI >
  inline _OI __copy_move_a(_II __first, _II __last, _OI __result);
  template < bool _IsMove, typename _II, typename _OI >
  inline _OI __copy_move_a(_II __first, _II __last, _OI __result)
  {
    typedef typename ::std::iterator_traits<_II>::value_type _ValueTypeI;
    typedef typename ::std::iterator_traits<_OI>::value_type _ValueTypeO;
    typedef typename ::std::iterator_traits<_II>::iterator_category _Category;
    const bool __simple = (((__is_trivial(_ValueTypeI)) && __is_pointer<_II>::__value) && __is_pointer<_OI>::__value) && __are_same<_ValueTypeI, _ValueTypeO>::__value;
    return std::__copy_move<_IsMove, __simple, _Category>::__copy_m(__first, __last, __result);
  }
  template < typename _CharT >
  struct char_traits;
  template < typename _CharT, typename _Traits >
  class istreambuf_iterator;
  template < typename _CharT, typename _Traits >
  class ostreambuf_iterator;
  template < bool _IsMove, typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >::__type __copy_move_a2(_CharT *__first, _CharT *__last, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __result);
  template < bool _IsMove, typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >::__type __copy_move_a2(const _CharT *__first, const _CharT *__last, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __result);
  template < bool _IsMove, typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_move_a2(::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __first, ::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __last, _CharT *__result);
  template < bool _IsMove, typename _II, typename _OI >
  inline _OI __copy_move_a2(_II __first, _II __last, _OI __result);
  template < bool _IsMove, typename _II, typename _OI >
  inline _OI __copy_move_a2(_II __first, _II __last, _OI __result)
  {
    return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
  }
  template < typename _II, typename _OI >
  inline _OI copy(_II __first, _II __last, _OI __result);
  template < typename _II, typename _OI >
  inline _OI copy(_II __first, _II __last, _OI __result)
  {
    ;
    return std::__copy_move_a2<__is_move_iterator<_II>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
  }
  template < bool __nontype_tpl_param_1_0__, bool __nontype_tpl_param_1_1__, typename __type_tpl__param_1_2__ >
  struct  __copy_move_backward
  {
      template < typename _BI1, typename _BI2 >
      static inline _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
      {
        while (__first != __last)
          {
            * --__result = * --__last;
          }
        return __result;
      }
  };
  template <>
  struct  __copy_move_backward<false, false, ::std::random_access_iterator_tag>
  {
      template < typename _BI1, typename _BI2 >
      static inline _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
      {
        typename ::std::iterator_traits<_BI1>::difference_type __n;
        for (__n = __last - __first; __n > 0;  --__n)
          {
            * --__result = * --__last;
          }
        return __result;
      }
  };
  template < bool _IsMove >
  struct  __copy_move_backward<_IsMove, true, ::std::random_access_iterator_tag>
  {
      template < typename _Tp >
      static inline _Tp *__copy_move_b(const _Tp *__first, const _Tp *__last, _Tp *__result)
      {
        const ::std::ptrdiff_t _Num = __last - __first;
        if (_Num)
          {
            __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
          }
        return __result - _Num;
      }
  };
  template < bool _IsMove, typename _BI1, typename _BI2 >
  inline _BI2 __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result);
  template < bool _IsMove, typename _BI1, typename _BI2 >
  inline _BI2 __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
  {
    typedef typename ::std::iterator_traits<_BI1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_BI2>::value_type _ValueType2;
    typedef typename ::std::iterator_traits<_BI1>::iterator_category _Category;
    const bool __simple = (((__is_trivial(_ValueType1)) && __is_pointer<_BI1>::__value) && __is_pointer<_BI2>::__value) && __are_same<_ValueType1, _ValueType2>::__value;
    return std::__copy_move_backward<_IsMove, __simple, _Category>::__copy_move_b(__first, __last, __result);
  }
  template < bool _IsMove, typename _BI1, typename _BI2 >
  inline _BI2 __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result);
  template < bool _IsMove, typename _BI1, typename _BI2 >
  inline _BI2 __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
  {
    return _BI2(std::__copy_move_backward_a<_IsMove>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
  }
  template < typename _BI1, typename _BI2 >
  inline _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result);
  template < typename _BI1, typename _BI2 >
  inline _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
  {
    ;
    return std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
  }
  template < typename _ForwardIterator, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type __fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value);
  template < typename _ForwardIterator, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type __fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)
  {
    for (; __first != __last;  ++__first)
      {
        *__first = __value;
      }
  }
  template < typename _ForwardIterator, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type __fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value);
  template < typename _ForwardIterator, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type __fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)
  {
    const _Tp __tmp = __value;
    for (; __first != __last;  ++__first)
      {
        *__first = __tmp;
      }
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type __fill_a(_Tp *__first, _Tp *__last, const _Tp &__c);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type __fill_a(_Tp *__first, _Tp *__last, const _Tp &__c)
  {
    const _Tp __tmp = __c;
    if (const ::std::size_t __len = __last - __first)
      {
        __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
      }
  }
  template < typename _ForwardIterator, typename _Tp >
  inline void fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value);
  template < typename _ForwardIterator, typename _Tp >
  inline void fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)
  {
    ;
    std::__fill_a(std::__niter_base(__first), std::__niter_base(__last), __value);
  }
  template < typename _OutputIterator, typename _Size, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value);
  template < typename _OutputIterator, typename _Size, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value)
  {
    for (__decltype(__n + 0) __niter = __n; __niter > 0; ( --__niter,  ++__first))
      {
        *__first = __value;
      }
    return __first;
  }
  template < typename _OutputIterator, typename _Size, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value);
  template < typename _OutputIterator, typename _Size, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value)
  {
    const _Tp __tmp = __value;
    for (__decltype(__n + 0) __niter = __n; __niter > 0; ( --__niter,  ++__first))
      {
        *__first = __tmp;
      }
    return __first;
  }
  template < typename _Size, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp *>::__type __fill_n_a(_Tp *__first, _Size __n, const _Tp &__c);
  template < typename _Size, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp *>::__type __fill_n_a(_Tp *__first, _Size __n, const _Tp &__c)
  {
    std::__fill_a(__first, __first + __n, __c);
    return __first + __n;
  }
  template < typename _OI, typename _Size, typename _Tp >
  inline _OI fill_n(_OI __first, _Size __n, const _Tp &__value);
  template < typename _OI, typename _Size, typename _Tp >
  inline _OI fill_n(_OI __first, _Size __n, const _Tp &__value)
  {
    return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
  }
  template < bool _BoolType >
  struct  __equal
  {
      template < typename _II1, typename _II2 >
      static inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2)
      {
        for (; __first1 != __last1; ( ++__first1, (void) ++__first2))
          {
            if (!(*__first1 == *__first2))
              {
                return false;
              }
          }
        return true;
      }
  };
  template <>
  struct  __equal<true>
  {
      template < typename _Tp >
      static inline bool equal(const _Tp *__first1, const _Tp *__last1, const _Tp *__first2)
      {
        if (const ::std::size_t __len = __last1 - __first1)
          {
            return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
          }
        return true;
      }
  };
  template < typename _II1, typename _II2 >
  inline bool __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2);
  template < typename _II1, typename _II2 >
  inline bool __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
  {
    typedef typename ::std::iterator_traits<_II1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_II2>::value_type _ValueType2;
    const bool __simple = (((__is_integer<_ValueType1>::__value || __is_pointer<_ValueType1>::__value) && __is_pointer<_II1>::__value) && __is_pointer<_II2>::__value) && __are_same<_ValueType1, _ValueType2>::__value;
    return std::__equal<__simple>::equal(__first1, __last1, __first2);
  }
  template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
  struct  __lc_rai
  {
      template < typename _II1, typename _II2 >
      static inline _II1 __newlast1(_II1, _II1 __last1, _II2, _II2)
      {
        return __last1;
      }
      template < typename _II >
      static inline bool __cnd2(_II __first, _II __last)
      {
        return __first != __last;
      }
  };
  template <>
  struct  __lc_rai< ::std::random_access_iterator_tag, ::std::random_access_iterator_tag>
  {
      template < typename _RAI1, typename _RAI2 >
      static inline _RAI1 __newlast1(_RAI1 __first1, _RAI1 __last1, _RAI2 __first2, _RAI2 __last2)
      {
        const typename ::std::iterator_traits<_RAI1>::difference_type __diff1 = __last1 - __first1;
        const typename ::std::iterator_traits<_RAI2>::difference_type __diff2 = __last2 - __first2;
        return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
      }
      template < typename _RAI >
      static inline bool __cnd2(_RAI, _RAI)
      {
        return true;
      }
  };
  template < typename _II1, typename _II2, typename _Compare >
  bool __lexicographical_compare_impl(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp);
  template < typename _II1, typename _II2, typename _Compare >
  bool __lexicographical_compare_impl(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_II1>::iterator_category _Category1;
    typedef typename ::std::iterator_traits<_II2>::iterator_category _Category2;
    typedef ::std::__lc_rai<_Category1, _Category2> __rai_type;
    __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
    for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2); ( ++__first1, (void) ++__first2))
      {
        if (__comp(__first1, __first2))
          {
            return true;
          }
        if (__comp(__first2, __first1))
          {
            return false;
          }
      }
    return __first1 == __last1 && __first2 != __last2;
  }
  template < bool _BoolType >
  struct  __lexicographical_compare
  {
      template < typename _II1, typename _II2 >
      static bool __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2);
  };
  template < bool _BoolType >
  template < typename _II1, typename _II2 >
  bool __lexicographical_compare<_BoolType>::__lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
  {
    return std::__lexicographical_compare_impl(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_less_iter());
  }
  template <>
  struct  __lexicographical_compare<true>
  {
      template < typename _Tp, typename _Up >
      static inline bool __lc(const _Tp *__first1, const _Tp *__last1, const _Up *__first2, const _Up *__last2)
      {
        const ::std::size_t __len1 = __last1 - __first1;
        const ::std::size_t __len2 = __last2 - __first2;
        if (const ::std::size_t __len = std::min(__len1, __len2))
          {
            if (int __result = __builtin_memcmp(__first1, __first2, __len))
              {
                return __result < 0;
              }
          }
        return __len1 < __len2;
      }
  };
  template < typename _II1, typename _II2 >
  inline bool __lexicographical_compare_aux(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2);
  template < typename _II1, typename _II2 >
  inline bool __lexicographical_compare_aux(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
  {
    typedef typename ::std::iterator_traits<_II1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_II2>::value_type _ValueType2;
    const bool __simple = ((((__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value) && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed) && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed) && __is_pointer<_II1>::__value) && __is_pointer<_II2>::__value;
    return std::__lexicographical_compare<__simple>::__lc(__first1, __last1, __first2, __last2);
  }
  template < typename _ForwardIterator, typename _Tp, typename _Compare >
  _ForwardIterator __lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp);
  template < typename _ForwardIterator, typename _Tp, typename _Compare >
  _ForwardIterator __lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::difference_type _DistanceType;
    _DistanceType __len = std::distance(__first, __last);
    while (__len > 0)
      {
        _DistanceType __half = __len >> 1;
        _ForwardIterator __middle = __first;
        std::advance(__middle, __half);
        if (__comp(__middle, __val))
          {
            __first = __middle;
             ++__first;
            __len = __len - __half - 1;
          }
        else
          {
            __len = __half;
          }
      }
    return __first;
  }
  template < typename _ForwardIterator, typename _Tp >
  inline _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val);
  template < typename _ForwardIterator, typename _Tp >
  inline _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)
  {
    ;
    return std::__lower_bound(__first, __last, __val, __gnu_cxx::__ops::__iter_less_val());
  }
  inline int __lg(int __n)
  {
    return sizeof(int) * 8 - 1 - __builtin_clz(__n);
  }
  inline unsigned int __lg(unsigned int __n)
  {
    return sizeof(int) * 8 - 1 - __builtin_clz(__n);
  }
  inline long int __lg(long int __n)
  {
    return sizeof(long int) * 8 - 1 - __builtin_clzl(__n);
  }
  inline unsigned long int __lg(unsigned long int __n)
  {
    return sizeof(long int) * 8 - 1 - __builtin_clzl(__n);
  }
  inline long long int __lg(long long int __n)
  {
    return sizeof(long long int) * 8 - 1 - __builtin_clzll(__n);
  }
  inline unsigned long long int __lg(unsigned long long int __n)
  {
    return sizeof(long long int) * 8 - 1 - __builtin_clzll(__n);
  }
  template < typename _II1, typename _II2 >
  inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2);
  template < typename _II1, typename _II2 >
  inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2)
  {
    ;
    return std::__equal_aux(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2));
  }
  template < typename _IIter1, typename _IIter2, typename _BinaryPredicate >
  inline bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _BinaryPredicate __binary_pred);
  template < typename _IIter1, typename _IIter2, typename _BinaryPredicate >
  inline bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _BinaryPredicate __binary_pred)
  {
    ;
    for (; __first1 != __last1; ( ++__first1, (void) ++__first2))
      {
        if (!bool(__binary_pred(*__first1, *__first2)))
          {
            return false;
          }
      }
    return true;
  }
  template < typename _II1, typename _II2 >
  inline bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2);
  template < typename _II1, typename _II2 >
  inline bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
  {
    ;
    ;
    return std::__lexicographical_compare_aux(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2), std::__niter_base(__last2));
  }
  template < typename _II1, typename _II2, typename _Compare >
  inline bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp);
  template < typename _II1, typename _II2, typename _Compare >
  inline bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp)
  {
    ;
    ;
    return std::__lexicographical_compare_impl(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__comp));
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate >
  ::std::pair<_InputIterator1, _InputIterator2> __mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred);
  template < typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate >
  ::std::pair<_InputIterator1, _InputIterator2> __mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred)
  {
    while (__first1 != __last1 && __binary_pred(__first1, __first2))
      {
         ++__first1;
         ++__first2;
      }
    return ::std::pair<_InputIterator1, _InputIterator2>(__first1, __first2);
  }
  template < typename _InputIterator1, typename _InputIterator2 >
  inline ::std::pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2);
  template < typename _InputIterator1, typename _InputIterator2 >
  inline ::std::pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
  {
    ;
    return std::__mismatch(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_equal_to_iter());
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate >
  inline ::std::pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred);
  template < typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate >
  inline ::std::pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred)
  {
    ;
    return std::__mismatch(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
  }
}
typedef __attribute__((mode(TC))) _Complex float __cfloat128;
typedef __float128 _Float128;
typedef float _Float32;
typedef double _Float64;
typedef double _Float32x;
typedef long double _Float64x;
typedef unsigned int wint_t;
typedef ::__mbstate_t mbstate_t;
struct tm;
extern "C"
{
  extern inline wchar_t *wcscpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw() __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline wchar_t *wcsncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __n) throw() __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline wchar_t *wcscat(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw() __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline wchar_t *wcsncat(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __n) throw() __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern int wcscmp(const wchar_t *__s1, const wchar_t *__s2) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int wcsncmp(const wchar_t *__s1, const wchar_t *__s2, ::size_t __n) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int wcscasecmp(const wchar_t *__s1, const wchar_t *__s2) throw();
}
extern "C"
{
  extern int wcsncasecmp(const wchar_t *__s1, const wchar_t *__s2, ::size_t __n) throw();
}
extern "C"
{
  extern int wcscasecmp_l(const wchar_t *__s1, const wchar_t *__s2, ::locale_t __loc) throw();
}
extern "C"
{
  extern int wcsncasecmp_l(const wchar_t *__s1, const wchar_t *__s2, ::size_t __n, ::locale_t __loc) throw();
}
extern "C"
{
  extern int wcscoll(const wchar_t *__s1, const wchar_t *__s2) throw();
}
extern "C"
{
  extern ::size_t wcsxfrm(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, ::size_t __n) throw();
}
extern "C"
{
  extern int wcscoll_l(const wchar_t *__s1, const wchar_t *__s2, ::locale_t __loc) throw();
}
extern "C"
{
  extern ::size_t wcsxfrm_l(wchar_t *__s1, const wchar_t *__s2, ::size_t __n, ::locale_t __loc) throw();
}
extern "C"
{
  extern wchar_t *wcsdup(const wchar_t *__s) throw() __attribute__((__malloc__));
}
wchar_t *wcschr(wchar_t *__wcs, wchar_t __wc) throw() __asm("wcschr") __attribute__((__pure__));
const wchar_t *wcschr(const wchar_t *__wcs, wchar_t __wc) throw() __asm("wcschr") __attribute__((__pure__));
wchar_t *wcsrchr(wchar_t *__wcs, wchar_t __wc) throw() __asm("wcsrchr") __attribute__((__pure__));
const wchar_t *wcsrchr(const wchar_t *__wcs, wchar_t __wc) throw() __asm("wcsrchr") __attribute__((__pure__));
extern "C"
{
  extern wchar_t *wcschrnul(const wchar_t *__s, wchar_t __wc) throw() __attribute__((__pure__));
}
extern "C"
{
  extern ::size_t wcscspn(const wchar_t *__wcs, const wchar_t *__reject) throw() __attribute__((__pure__));
}
extern "C"
{
  extern ::size_t wcsspn(const wchar_t *__wcs, const wchar_t *__accept) throw() __attribute__((__pure__));
}
wchar_t *wcspbrk(wchar_t *__wcs, const wchar_t *__accept) throw() __asm("wcspbrk") __attribute__((__pure__));
const wchar_t *wcspbrk(const wchar_t *__wcs, const wchar_t *__accept) throw() __asm("wcspbrk") __attribute__((__pure__));
wchar_t *wcsstr(wchar_t *__haystack, const wchar_t *__needle) throw() __asm("wcsstr") __attribute__((__pure__));
const wchar_t *wcsstr(const wchar_t *__haystack, const wchar_t *__needle) throw() __asm("wcsstr") __attribute__((__pure__));
extern "C"
{
  extern wchar_t *wcstok(wchar_t *__restrict __s, const wchar_t *__restrict __delim, wchar_t **__restrict __ptr) throw();
}
extern "C"
{
  extern ::size_t wcslen(const wchar_t *__s) throw() __attribute__((__pure__));
}
wchar_t *wcswcs(wchar_t *__haystack, const wchar_t *__needle) throw() __asm("wcswcs") __attribute__((__pure__));
const wchar_t *wcswcs(const wchar_t *__haystack, const wchar_t *__needle) throw() __asm("wcswcs") __attribute__((__pure__));
extern "C"
{
  extern ::size_t wcsnlen(const wchar_t *__s, ::size_t __maxlen) throw() __attribute__((__pure__));
}
wchar_t *wmemchr(wchar_t *__s, wchar_t __c, ::size_t __n) throw() __asm("wmemchr") __attribute__((__pure__));
const wchar_t *wmemchr(const wchar_t *__s, wchar_t __c, ::size_t __n) throw() __asm("wmemchr") __attribute__((__pure__));
extern "C"
{
  extern int wmemcmp(const wchar_t *__s1, const wchar_t *__s2, ::size_t __n) throw() __attribute__((__pure__));
}
extern "C"
{
  extern inline wchar_t *wmemcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, ::size_t __n) throw() __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline wchar_t *wmemmove(wchar_t *__s1, const wchar_t *__s2, ::size_t __n) throw() __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline wchar_t *wmemset(wchar_t *__s, wchar_t __c, ::size_t __n) throw() __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline wchar_t *wmempcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, ::size_t __n) throw() __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline ::wint_t btowc(int __c) throw() __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int wctob(::wint_t __wc) throw() __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern int mbsinit(const ::mbstate_t *__ps) throw() __attribute__((__pure__));
}
extern "C"
{
  extern ::size_t mbrtowc(wchar_t *__restrict __pwc, const char *__restrict __s, ::size_t __n, ::mbstate_t *__restrict __p) throw();
}
extern "C"
{
  extern inline ::size_t wcrtomb(char *__restrict __s, wchar_t __wchar, ::mbstate_t *__restrict __ps) throw() __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::size_t __mbrlen(const char *__restrict __s, ::size_t __n, ::mbstate_t *__restrict __ps) throw();
}
extern "C"
{
  extern inline ::size_t mbrlen(const char *__restrict __s, ::size_t __n, ::mbstate_t *__restrict __ps) throw() __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern ::wint_t __btowc_alias(int __c) __asm("btowc");
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__gnu_inline__)) ::wint_t btowc(int __c) throw()
  {
    return (__builtin_constant_p(__c) && __c >= '\000') && __c <= '\177' ? (::wint_t)__c : ::__btowc_alias(__c);
  }
}
extern "C"
{
  extern int __wctob_alias(::wint_t __c) __asm("wctob");
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__gnu_inline__)) int wctob(::wint_t __wc) throw()
  {
    return (__builtin_constant_p(__wc) && __wc >= L'\x0000') && __wc <= L'\x007f' ? (int)__wc : ::__wctob_alias(__wc);
  }
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__gnu_inline__)) ::size_t mbrlen(const char *__restrict __s, ::size_t __n, ::mbstate_t *__restrict __ps) throw()
  {
    return __ps != 0L ? ::mbrtowc(0L, __s, __n, __ps) : ::__mbrlen(__s, __n, 0L);
  }
}
extern "C"
{
  extern inline ::size_t mbsrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, ::size_t __len, ::mbstate_t *__restrict __ps) throw() __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline ::size_t wcsrtombs(char *__restrict __dst, const wchar_t **__restrict __src, ::size_t __len, ::mbstate_t *__restrict __ps) throw() __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline ::size_t mbsnrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, ::size_t __nmc, ::size_t __len, ::mbstate_t *__restrict __ps) throw() __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline ::size_t wcsnrtombs(char *__restrict __dst, const wchar_t **__restrict __src, ::size_t __nwc, ::size_t __len, ::mbstate_t *__restrict __ps) throw() __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern int wcwidth(wchar_t __c) throw();
}
extern "C"
{
  extern int wcswidth(const wchar_t *__s, ::size_t __n) throw();
}
extern "C"
{
  extern double wcstod(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
}
extern "C"
{
  extern float wcstof(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
}
extern "C"
{
  extern long double wcstold(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
}
extern "C"
{
  extern ::_Float32 wcstof32(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
}
extern "C"
{
  extern ::_Float64 wcstof64(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
}
extern "C"
{
  extern ::_Float128 wcstof128(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
}
extern "C"
{
  extern ::_Float32x wcstof32x(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
}
extern "C"
{
  extern ::_Float64x wcstof64x(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
}
extern "C"
{
  extern long int wcstol(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern unsigned long int wcstoul(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern long long int wcstoll(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern unsigned long long int wcstoull(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern long long int wcstoq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern unsigned long long int wcstouq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern long int wcstol_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, ::locale_t __loc) throw();
}
extern "C"
{
  extern unsigned long int wcstoul_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, ::locale_t __loc) throw();
}
extern "C"
{
  extern long long int wcstoll_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, ::locale_t __loc) throw();
}
extern "C"
{
  extern unsigned long long int wcstoull_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, ::locale_t __loc) throw();
}
extern "C"
{
  extern double wcstod_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, ::locale_t __loc) throw();
}
extern "C"
{
  extern float wcstof_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, ::locale_t __loc) throw();
}
extern "C"
{
  extern long double wcstold_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, ::locale_t __loc) throw();
}
extern "C"
{
  extern ::_Float32 wcstof32_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, ::locale_t __loc) throw();
}
extern "C"
{
  extern ::_Float64 wcstof64_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, ::locale_t __loc) throw();
}
extern "C"
{
  extern ::_Float128 wcstof128_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, ::locale_t __loc) throw();
}
extern "C"
{
  extern ::_Float32x wcstof32x_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, ::locale_t __loc) throw();
}
extern "C"
{
  extern ::_Float64x wcstof64x_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, ::locale_t __loc) throw();
}
extern "C"
{
  extern inline wchar_t *wcpcpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw() __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline wchar_t *wcpncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __n) throw() __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern ::__FILE *open_wmemstream(wchar_t **__bufloc, ::size_t *__sizeloc) throw();
}
extern "C"
{
  extern int fwide(::__FILE *__fp, int __mode) throw();
}
extern "C"
{
  extern inline int fwprintf(::__FILE *__restrict __stream, const wchar_t *__restrict __fmt, ...) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline int wprintf(const wchar_t *__restrict __fmt, ...) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline int swprintf(wchar_t *__restrict __s, ::size_t __n, const wchar_t *__restrict __fmt, ...) throw() __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline int vfwprintf(::__FILE *__restrict __stream, const wchar_t *__restrict __fmt, ::__gnuc_va_list __ap) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline int vwprintf(const wchar_t *__restrict __fmt, ::__gnuc_va_list __ap) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline int vswprintf(wchar_t *__restrict __s, ::size_t __n, const wchar_t *__restrict __fmt, ::__gnuc_va_list __ap) throw() __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern int fwscanf(::__FILE *__restrict __stream, const wchar_t *__restrict __format, ...);
}
extern "C"
{
  extern int wscanf(const wchar_t *__restrict __format, ...);
}
extern "C"
{
  extern int swscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) throw();
}
extern "C"
{
  extern int vfwscanf(::__FILE *__restrict __s, const wchar_t *__restrict __format, ::__gnuc_va_list __arg);
}
extern "C"
{
  extern int vwscanf(const wchar_t *__restrict __format, ::__gnuc_va_list __arg);
}
extern "C"
{
  extern int vswscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, ::__gnuc_va_list __arg) throw();
}
extern "C"
{
  extern ::wint_t fgetwc(::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t getwc(::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t getwchar();
}
extern "C"
{
  extern ::wint_t fputwc(wchar_t __wc, ::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t putwc(wchar_t __wc, ::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t putwchar(wchar_t __wc);
}
extern "C"
{
  extern inline wchar_t *fgetws(wchar_t *__restrict __s, int __n, ::__FILE *__restrict __stream) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int fputws(const wchar_t *__restrict __ws, ::__FILE *__restrict __stream);
}
extern "C"
{
  extern ::wint_t ungetwc(::wint_t __wc, ::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t getwc_unlocked(::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t getwchar_unlocked();
}
extern "C"
{
  extern ::wint_t fgetwc_unlocked(::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t fputwc_unlocked(wchar_t __wc, ::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t putwc_unlocked(wchar_t __wc, ::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t putwchar_unlocked(wchar_t __wc);
}
extern "C"
{
  extern inline wchar_t *fgetws_unlocked(wchar_t *__restrict __s, int __n, ::__FILE *__restrict __stream) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int fputws_unlocked(const wchar_t *__restrict __ws, ::__FILE *__restrict __stream);
}
extern "C"
{
  extern ::size_t wcsftime(wchar_t *__restrict __s, ::size_t __maxsize, const wchar_t *__restrict __format, const ::tm *__restrict __tp) throw();
}
extern "C"
{
  extern ::size_t wcsftime_l(wchar_t *__restrict __s, ::size_t __maxsize, const wchar_t *__restrict __format, const ::tm *__restrict __tp, ::locale_t __loc) throw();
}
extern "C"
{
  extern wchar_t *__wmemcpy_chk(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, ::size_t __n, ::size_t __ns1) throw();
}
extern "C"
{
  extern wchar_t *__wmemcpy_alias(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, ::size_t __n) throw() __asm("""wmemcpy");
}
extern "C"
{
  extern wchar_t *__wmemcpy_chk_warn(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, ::size_t __n, ::size_t __ns1) throw() __asm("""__wmemcpy_chk") __attribute__((__warning__("wmemcpy called with length bigger than size of destination ""buffer")));
}
extern "C"
{
  extern inline __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) wchar_t *wmemcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, ::size_t __n) throw()
  {
    if (__builtin_object_size(__s1, 0) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__n))
          {
            return ::__wmemcpy_chk(__s1, __s2, __n, __builtin_object_size(__s1, 0) / sizeof(wchar_t));
          }
        if (__n > __builtin_object_size(__s1, 0) / sizeof(wchar_t))
          {
            return ::__wmemcpy_chk_warn(__s1, __s2, __n, __builtin_object_size(__s1, 0) / sizeof(wchar_t));
          }
      }
    return ::__wmemcpy_alias(__s1, __s2, __n);
  }
}
extern "C"
{
  extern wchar_t *__wmemmove_chk(wchar_t *__s1, const wchar_t *__s2, ::size_t __n, ::size_t __ns1) throw();
}
extern "C"
{
  extern wchar_t *__wmemmove_alias(wchar_t *__s1, const wchar_t *__s2, ::size_t __n) throw() __asm("""wmemmove");
}
extern "C"
{
  extern wchar_t *__wmemmove_chk_warn(wchar_t *__s1, const wchar_t *__s2, ::size_t __n, ::size_t __ns1) throw() __asm("""__wmemmove_chk") __attribute__((__warning__("wmemmove called with length bigger than size of destination ""buffer")));
}
extern "C"
{
  extern inline __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) wchar_t *wmemmove(wchar_t *__s1, const wchar_t *__s2, ::size_t __n) throw()
  {
    if (__builtin_object_size(__s1, 0) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__n))
          {
            return ::__wmemmove_chk(__s1, __s2, __n, __builtin_object_size(__s1, 0) / sizeof(wchar_t));
          }
        if (__n > __builtin_object_size(__s1, 0) / sizeof(wchar_t))
          {
            return ::__wmemmove_chk_warn(__s1, __s2, __n, __builtin_object_size(__s1, 0) / sizeof(wchar_t));
          }
      }
    return ::__wmemmove_alias(__s1, __s2, __n);
  }
}
extern "C"
{
  extern wchar_t *__wmempcpy_chk(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, ::size_t __n, ::size_t __ns1) throw();
}
extern "C"
{
  extern wchar_t *__wmempcpy_alias(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, ::size_t __n) throw() __asm("""wmempcpy");
}
extern "C"
{
  extern wchar_t *__wmempcpy_chk_warn(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, ::size_t __n, ::size_t __ns1) throw() __asm("""__wmempcpy_chk") __attribute__((__warning__("wmempcpy called with length bigger than size of destination ""buffer")));
}
extern "C"
{
  extern inline __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) wchar_t *wmempcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, ::size_t __n) throw()
  {
    if (__builtin_object_size(__s1, 0) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__n))
          {
            return ::__wmempcpy_chk(__s1, __s2, __n, __builtin_object_size(__s1, 0) / sizeof(wchar_t));
          }
        if (__n > __builtin_object_size(__s1, 0) / sizeof(wchar_t))
          {
            return ::__wmempcpy_chk_warn(__s1, __s2, __n, __builtin_object_size(__s1, 0) / sizeof(wchar_t));
          }
      }
    return ::__wmempcpy_alias(__s1, __s2, __n);
  }
}
extern "C"
{
  extern wchar_t *__wmemset_chk(wchar_t *__s, wchar_t __c, ::size_t __n, ::size_t __ns) throw();
}
extern "C"
{
  extern wchar_t *__wmemset_alias(wchar_t *__s, wchar_t __c, ::size_t __n) throw() __asm("""wmemset");
}
extern "C"
{
  extern wchar_t *__wmemset_chk_warn(wchar_t *__s, wchar_t __c, ::size_t __n, ::size_t __ns) throw() __asm("""__wmemset_chk") __attribute__((__warning__("wmemset called with length bigger than size of destination ""buffer")));
}
extern "C"
{
  extern inline __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) wchar_t *wmemset(wchar_t *__s, wchar_t __c, ::size_t __n) throw()
  {
    if (__builtin_object_size(__s, 0) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__n))
          {
            return ::__wmemset_chk(__s, __c, __n, __builtin_object_size(__s, 0) / sizeof(wchar_t));
          }
        if (__n > __builtin_object_size(__s, 0) / sizeof(wchar_t))
          {
            return ::__wmemset_chk_warn(__s, __c, __n, __builtin_object_size(__s, 0) / sizeof(wchar_t));
          }
      }
    return ::__wmemset_alias(__s, __c, __n);
  }
}
extern "C"
{
  extern wchar_t *__wcscpy_chk(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __n) throw();
}
extern "C"
{
  extern wchar_t *__wcscpy_alias(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw() __asm("""wcscpy");
}
extern "C"
{
  extern inline __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) wchar_t *wcscpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw()
  {
    if (__builtin_object_size(__dest, 2 > 1) != (::size_t) -1)
      {
        return ::__wcscpy_chk(__dest, __src, __builtin_object_size(__dest, 2 > 1) / sizeof(wchar_t));
      }
    return ::__wcscpy_alias(__dest, __src);
  }
}
extern "C"
{
  extern wchar_t *__wcpcpy_chk(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __destlen) throw();
}
extern "C"
{
  extern wchar_t *__wcpcpy_alias(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw() __asm("""wcpcpy");
}
extern "C"
{
  extern inline __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) wchar_t *wcpcpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw()
  {
    if (__builtin_object_size(__dest, 2 > 1) != (::size_t) -1)
      {
        return ::__wcpcpy_chk(__dest, __src, __builtin_object_size(__dest, 2 > 1) / sizeof(wchar_t));
      }
    return ::__wcpcpy_alias(__dest, __src);
  }
}
extern "C"
{
  extern wchar_t *__wcsncpy_chk(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __n, ::size_t __destlen) throw();
}
extern "C"
{
  extern wchar_t *__wcsncpy_alias(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __n) throw() __asm("""wcsncpy");
}
extern "C"
{
  extern wchar_t *__wcsncpy_chk_warn(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __n, ::size_t __destlen) throw() __asm("""__wcsncpy_chk") __attribute__((__warning__("wcsncpy called with length bigger than size of destination ""buffer")));
}
extern "C"
{
  extern inline __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) wchar_t *wcsncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __n) throw()
  {
    if (__builtin_object_size(__dest, 2 > 1) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__n))
          {
            return ::__wcsncpy_chk(__dest, __src, __n, __builtin_object_size(__dest, 2 > 1) / sizeof(wchar_t));
          }
        if (__n > __builtin_object_size(__dest, 2 > 1) / sizeof(wchar_t))
          {
            return ::__wcsncpy_chk_warn(__dest, __src, __n, __builtin_object_size(__dest, 2 > 1) / sizeof(wchar_t));
          }
      }
    return ::__wcsncpy_alias(__dest, __src, __n);
  }
}
extern "C"
{
  extern wchar_t *__wcpncpy_chk(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __n, ::size_t __destlen) throw();
}
extern "C"
{
  extern wchar_t *__wcpncpy_alias(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __n) throw() __asm("""wcpncpy");
}
extern "C"
{
  extern wchar_t *__wcpncpy_chk_warn(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __n, ::size_t __destlen) throw() __asm("""__wcpncpy_chk") __attribute__((__warning__("wcpncpy called with length bigger than size of destination ""buffer")));
}
extern "C"
{
  extern inline __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) wchar_t *wcpncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __n) throw()
  {
    if (__builtin_object_size(__dest, 2 > 1) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__n))
          {
            return ::__wcpncpy_chk(__dest, __src, __n, __builtin_object_size(__dest, 2 > 1) / sizeof(wchar_t));
          }
        if (__n > __builtin_object_size(__dest, 2 > 1) / sizeof(wchar_t))
          {
            return ::__wcpncpy_chk_warn(__dest, __src, __n, __builtin_object_size(__dest, 2 > 1) / sizeof(wchar_t));
          }
      }
    return ::__wcpncpy_alias(__dest, __src, __n);
  }
}
extern "C"
{
  extern wchar_t *__wcscat_chk(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __destlen) throw();
}
extern "C"
{
  extern wchar_t *__wcscat_alias(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw() __asm("""wcscat");
}
extern "C"
{
  extern inline __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) wchar_t *wcscat(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw()
  {
    if (__builtin_object_size(__dest, 2 > 1) != (::size_t) -1)
      {
        return ::__wcscat_chk(__dest, __src, __builtin_object_size(__dest, 2 > 1) / sizeof(wchar_t));
      }
    return ::__wcscat_alias(__dest, __src);
  }
}
extern "C"
{
  extern wchar_t *__wcsncat_chk(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __n, ::size_t __destlen) throw();
}
extern "C"
{
  extern wchar_t *__wcsncat_alias(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __n) throw() __asm("""wcsncat");
}
extern "C"
{
  extern inline __attribute__((__nonnull__(1, 2))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) wchar_t *wcsncat(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __n) throw()
  {
    if (__builtin_object_size(__dest, 2 > 1) != (::size_t) -1)
      {
        return ::__wcsncat_chk(__dest, __src, __n, __builtin_object_size(__dest, 2 > 1) / sizeof(wchar_t));
      }
    return ::__wcsncat_alias(__dest, __src, __n);
  }
}
extern "C"
{
  extern int __swprintf_chk(wchar_t *__restrict __s, ::size_t __n, int __flag, ::size_t __s_len, const wchar_t *__restrict __format, ...) throw();
}
extern "C"
{
  extern int __swprintf_alias(wchar_t *__restrict __s, ::size_t __n, const wchar_t *__restrict __fmt, ...) throw() __asm("""swprintf");
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int swprintf(wchar_t *__restrict __s, ::size_t __n, const wchar_t *__restrict __fmt, ...) throw()
  {
    if (__builtin_object_size(__s, 2 > 1) != (::size_t) -1 || 2 > 1)
      {
        return ::__swprintf_chk(__s, __n, 2 - 1, __builtin_object_size(__s, 2 > 1) / sizeof(wchar_t), __fmt, __builtin_va_arg_pack());
      }
    return ::__swprintf_alias(__s, __n, __fmt, __builtin_va_arg_pack());
  }
}
extern "C"
{
  extern int __vswprintf_chk(wchar_t *__restrict __s, ::size_t __n, int __flag, ::size_t __s_len, const wchar_t *__restrict __format, ::__gnuc_va_list __arg) throw();
}
extern "C"
{
  extern int __vswprintf_alias(wchar_t *__restrict __s, ::size_t __n, const wchar_t *__restrict __fmt, ::__gnuc_va_list __ap) throw() __asm("""vswprintf");
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int vswprintf(wchar_t *__restrict __s, ::size_t __n, const wchar_t *__restrict __fmt, ::__gnuc_va_list __ap) throw()
  {
    if (__builtin_object_size(__s, 2 > 1) != (::size_t) -1 || 2 > 1)
      {
        return ::__vswprintf_chk(__s, __n, 2 - 1, __builtin_object_size(__s, 2 > 1) / sizeof(wchar_t), __fmt, __ap);
      }
    return ::__vswprintf_alias(__s, __n, __fmt, __ap);
  }
}
extern "C"
{
  extern int __fwprintf_chk(::__FILE *__restrict __stream, int __flag, const wchar_t *__restrict __format, ...);
}
extern "C"
{
  extern int __wprintf_chk(int __flag, const wchar_t *__restrict __format, ...);
}
extern "C"
{
  extern int __vfwprintf_chk(::__FILE *__restrict __stream, int __flag, const wchar_t *__restrict __format, ::__gnuc_va_list __ap);
}
extern "C"
{
  extern int __vwprintf_chk(int __flag, const wchar_t *__restrict __format, ::__gnuc_va_list __ap);
}
extern "C"
{
  extern inline __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int wprintf(const wchar_t *__restrict __fmt, ...)
  {
    return ::__wprintf_chk(2 - 1, __fmt, __builtin_va_arg_pack());
  }
}
extern "C"
{
  extern inline __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int fwprintf(::__FILE *__restrict __stream, const wchar_t *__restrict __fmt, ...)
  {
    return ::__fwprintf_chk(__stream, 2 - 1, __fmt, __builtin_va_arg_pack());
  }
}
extern "C"
{
  extern inline __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int vwprintf(const wchar_t *__restrict __fmt, ::__gnuc_va_list __ap)
  {
    return ::__vwprintf_chk(2 - 1, __fmt, __ap);
  }
}
extern "C"
{
  extern inline __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int vfwprintf(::__FILE *__restrict __stream, const wchar_t *__restrict __fmt, ::__gnuc_va_list __ap)
  {
    return ::__vfwprintf_chk(__stream, 2 - 1, __fmt, __ap);
  }
}
extern "C"
{
  extern wchar_t *__fgetws_chk(wchar_t *__restrict __s, ::size_t __size, int __n, ::__FILE *__restrict __stream) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern wchar_t *__fgetws_alias(wchar_t *__restrict __s, int __n, ::__FILE *__restrict __stream) __asm("""fgetws") __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern wchar_t *__fgetws_chk_warn(wchar_t *__restrict __s, ::size_t __size, int __n, ::__FILE *__restrict __stream) __asm("""__fgetws_chk") __attribute__((__warn_unused_result__)) __attribute__((__warning__("fgetws called with bigger size than length ""of destination buffer")));
}
extern "C"
{
  extern inline __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) __attribute__((__warn_unused_result__)) wchar_t *fgetws(wchar_t *__restrict __s, int __n, ::__FILE *__restrict __stream)
  {
    if (__builtin_object_size(__s, 2 > 1) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__n) || __n <= 0)
          {
            return ::__fgetws_chk(__s, __builtin_object_size(__s, 2 > 1) / sizeof(wchar_t), __n, __stream);
          }
        if ((::size_t)__n > __builtin_object_size(__s, 2 > 1) / sizeof(wchar_t))
          {
            return ::__fgetws_chk_warn(__s, __builtin_object_size(__s, 2 > 1) / sizeof(wchar_t), __n, __stream);
          }
      }
    return ::__fgetws_alias(__s, __n, __stream);
  }
}
extern "C"
{
  extern wchar_t *__fgetws_unlocked_chk(wchar_t *__restrict __s, ::size_t __size, int __n, ::__FILE *__restrict __stream) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern wchar_t *__fgetws_unlocked_alias(wchar_t *__restrict __s, int __n, ::__FILE *__restrict __stream) __asm("""fgetws_unlocked") __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern wchar_t *__fgetws_unlocked_chk_warn(wchar_t *__restrict __s, ::size_t __size, int __n, ::__FILE *__restrict __stream) __asm("""__fgetws_unlocked_chk") __attribute__((__warn_unused_result__)) __attribute__((__warning__("fgetws_unlocked called with bigger size than length ""of destination buffer")));
}
extern "C"
{
  extern inline __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) __attribute__((__warn_unused_result__)) wchar_t *fgetws_unlocked(wchar_t *__restrict __s, int __n, ::__FILE *__restrict __stream)
  {
    if (__builtin_object_size(__s, 2 > 1) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__n) || __n <= 0)
          {
            return ::__fgetws_unlocked_chk(__s, __builtin_object_size(__s, 2 > 1) / sizeof(wchar_t), __n, __stream);
          }
        if ((::size_t)__n > __builtin_object_size(__s, 2 > 1) / sizeof(wchar_t))
          {
            return ::__fgetws_unlocked_chk_warn(__s, __builtin_object_size(__s, 2 > 1) / sizeof(wchar_t), __n, __stream);
          }
      }
    return ::__fgetws_unlocked_alias(__s, __n, __stream);
  }
}
extern "C"
{
  extern ::size_t __wcrtomb_chk(char *__restrict __s, wchar_t __wchar, ::mbstate_t *__restrict __p, ::size_t __buflen) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::size_t __wcrtomb_alias(char *__restrict __s, wchar_t __wchar, ::mbstate_t *__restrict __ps) throw() __asm("""wcrtomb") __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) __attribute__((__warn_unused_result__)) ::size_t wcrtomb(char *__restrict __s, wchar_t __wchar, ::mbstate_t *__restrict __ps) throw()
  {
    if (__builtin_object_size(__s, 2 > 1) != (::size_t) -1 && 16 > __builtin_object_size(__s, 2 > 1))
      {
        return ::__wcrtomb_chk(__s, __wchar, __ps, __builtin_object_size(__s, 2 > 1));
      }
    return ::__wcrtomb_alias(__s, __wchar, __ps);
  }
}
extern "C"
{
  extern ::size_t __mbsrtowcs_chk(wchar_t *__restrict __dst, const char **__restrict __src, ::size_t __len, ::mbstate_t *__restrict __ps, ::size_t __dstlen) throw();
}
extern "C"
{
  extern ::size_t __mbsrtowcs_alias(wchar_t *__restrict __dst, const char **__restrict __src, ::size_t __len, ::mbstate_t *__restrict __ps) throw() __asm("""mbsrtowcs");
}
extern "C"
{
  extern ::size_t __mbsrtowcs_chk_warn(wchar_t *__restrict __dst, const char **__restrict __src, ::size_t __len, ::mbstate_t *__restrict __ps, ::size_t __dstlen) throw() __asm("""__mbsrtowcs_chk") __attribute__((__warning__("mbsrtowcs called with dst buffer smaller than len ""* sizeof (wchar_t)")));
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) ::size_t mbsrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, ::size_t __len, ::mbstate_t *__restrict __ps) throw()
  {
    if (__builtin_object_size(__dst, 2 > 1) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__len))
          {
            return ::__mbsrtowcs_chk(__dst, __src, __len, __ps, __builtin_object_size(__dst, 2 > 1) / sizeof(wchar_t));
          }
        if (__len > __builtin_object_size(__dst, 2 > 1) / sizeof(wchar_t))
          {
            return ::__mbsrtowcs_chk_warn(__dst, __src, __len, __ps, __builtin_object_size(__dst, 2 > 1) / sizeof(wchar_t));
          }
      }
    return ::__mbsrtowcs_alias(__dst, __src, __len, __ps);
  }
}
extern "C"
{
  extern ::size_t __wcsrtombs_chk(char *__restrict __dst, const wchar_t **__restrict __src, ::size_t __len, ::mbstate_t *__restrict __ps, ::size_t __dstlen) throw();
}
extern "C"
{
  extern ::size_t __wcsrtombs_alias(char *__restrict __dst, const wchar_t **__restrict __src, ::size_t __len, ::mbstate_t *__restrict __ps) throw() __asm("""wcsrtombs");
}
extern "C"
{
  extern ::size_t __wcsrtombs_chk_warn(char *__restrict __dst, const wchar_t **__restrict __src, ::size_t __len, ::mbstate_t *__restrict __ps, ::size_t __dstlen) throw() __asm("""__wcsrtombs_chk") __attribute__((__warning__("wcsrtombs called with dst buffer smaller than len")));
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) ::size_t wcsrtombs(char *__restrict __dst, const wchar_t **__restrict __src, ::size_t __len, ::mbstate_t *__restrict __ps) throw()
  {
    if (__builtin_object_size(__dst, 2 > 1) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__len))
          {
            return ::__wcsrtombs_chk(__dst, __src, __len, __ps, __builtin_object_size(__dst, 2 > 1));
          }
        if (__len > __builtin_object_size(__dst, 2 > 1))
          {
            return ::__wcsrtombs_chk_warn(__dst, __src, __len, __ps, __builtin_object_size(__dst, 2 > 1));
          }
      }
    return ::__wcsrtombs_alias(__dst, __src, __len, __ps);
  }
}
extern "C"
{
  extern ::size_t __mbsnrtowcs_chk(wchar_t *__restrict __dst, const char **__restrict __src, ::size_t __nmc, ::size_t __len, ::mbstate_t *__restrict __ps, ::size_t __dstlen) throw();
}
extern "C"
{
  extern ::size_t __mbsnrtowcs_alias(wchar_t *__restrict __dst, const char **__restrict __src, ::size_t __nmc, ::size_t __len, ::mbstate_t *__restrict __ps) throw() __asm("""mbsnrtowcs");
}
extern "C"
{
  extern ::size_t __mbsnrtowcs_chk_warn(wchar_t *__restrict __dst, const char **__restrict __src, ::size_t __nmc, ::size_t __len, ::mbstate_t *__restrict __ps, ::size_t __dstlen) throw() __asm("""__mbsnrtowcs_chk") __attribute__((__warning__("mbsnrtowcs called with dst buffer smaller than len ""* sizeof (wchar_t)")));
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) ::size_t mbsnrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, ::size_t __nmc, ::size_t __len, ::mbstate_t *__restrict __ps) throw()
  {
    if (__builtin_object_size(__dst, 2 > 1) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__len))
          {
            return ::__mbsnrtowcs_chk(__dst, __src, __nmc, __len, __ps, __builtin_object_size(__dst, 2 > 1) / sizeof(wchar_t));
          }
        if (__len > __builtin_object_size(__dst, 2 > 1) / sizeof(wchar_t))
          {
            return ::__mbsnrtowcs_chk_warn(__dst, __src, __nmc, __len, __ps, __builtin_object_size(__dst, 2 > 1) / sizeof(wchar_t));
          }
      }
    return ::__mbsnrtowcs_alias(__dst, __src, __nmc, __len, __ps);
  }
}
extern "C"
{
  extern ::size_t __wcsnrtombs_chk(char *__restrict __dst, const wchar_t **__restrict __src, ::size_t __nwc, ::size_t __len, ::mbstate_t *__restrict __ps, ::size_t __dstlen) throw();
}
extern "C"
{
  extern ::size_t __wcsnrtombs_alias(char *__restrict __dst, const wchar_t **__restrict __src, ::size_t __nwc, ::size_t __len, ::mbstate_t *__restrict __ps) throw() __asm("""wcsnrtombs");
}
extern "C"
{
  extern ::size_t __wcsnrtombs_chk_warn(char *__restrict __dst, const wchar_t **__restrict __src, ::size_t __nwc, ::size_t __len, ::mbstate_t *__restrict __ps, ::size_t __dstlen) throw() __asm("""__wcsnrtombs_chk") __attribute__((__warning__("wcsnrtombs called with dst buffer smaller than len")));
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) ::size_t wcsnrtombs(char *__restrict __dst, const wchar_t **__restrict __src, ::size_t __nwc, ::size_t __len, ::mbstate_t *__restrict __ps) throw()
  {
    if (__builtin_object_size(__dst, 2 > 1) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__len))
          {
            return ::__wcsnrtombs_chk(__dst, __src, __nwc, __len, __ps, __builtin_object_size(__dst, 2 > 1));
          }
        if (__len > __builtin_object_size(__dst, 2 > 1))
          {
            return ::__wcsnrtombs_chk_warn(__dst, __src, __nwc, __len, __ps, __builtin_object_size(__dst, 2 > 1));
          }
      }
    return ::__wcsnrtombs_alias(__dst, __src, __nwc, __len, __ps);
  }
}
namespace std __attribute__((__visibility__("default"))) {
  using ::mbstate_t;
  using ::wint_t;
  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;
  using ::swprintf;
  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;
  using ::vfwscanf;
  using ::vswprintf;
  using ::vswscanf;
  using ::vwprintf;
  using ::vwscanf;
  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;
  using ::wcstof;
  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  using ::wcstold;
  using ::wcstoll;
  using ::wcstoull;
}
namespace std __attribute__((__visibility__("default"))) {
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
  typedef long int streamoff;
  typedef ::std::ptrdiff_t streamsize;
  template < typename _StateT >
  class  fpos
  {
      ::std::streamoff _M_off;
      _StateT _M_state;
    public:
      inline fpos()
        : _M_off(0), _M_state()
      {
      }
      inline fpos(::std::streamoff __off)
        : _M_off(__off), _M_state()
      {
      }
      inline operator ::std::streamoff() const 
      {
        return ::std::fpos<_StateT>::_M_off;
      }
      inline void state(_StateT __st)
      {
        ::std::fpos<_StateT>::_M_state = __st;
      }
      inline _StateT state() const 
      {
        return ::std::fpos<_StateT>::_M_state;
      }
      inline ::std::fpos<_StateT> &operator +=(::std::streamoff __off)
      {
        ::std::fpos<_StateT>::_M_off += __off;
        return *this;
      }
      inline ::std::fpos<_StateT> &operator -=(::std::streamoff __off)
      {
        ::std::fpos<_StateT>::_M_off -= __off;
        return *this;
      }
      inline ::std::fpos<_StateT> operator +(::std::streamoff __off) const 
      {
        ::std::fpos<_StateT> __pos(*this);
        __pos += __off;
        return __pos;
      }
      inline ::std::fpos<_StateT> operator -(::std::streamoff __off) const 
      {
        ::std::fpos<_StateT> __pos(*this);
        __pos -= __off;
        return __pos;
      }
      inline ::std::streamoff operator -(const ::std::fpos<_StateT> &__other) const 
      {
        return ::std::fpos<_StateT>::_M_off - __other._M_off;
      }
  };
  template < typename _StateT >
  inline bool operator ==(const ::std::fpos<_StateT> &__lhs, const ::std::fpos<_StateT> &__rhs);
  template < typename _StateT >
  inline bool operator ==(const ::std::fpos<_StateT> &__lhs, const ::std::fpos<_StateT> &__rhs)
  {
    return long(__lhs) == long(__rhs);
  }
  template < typename _StateT >
  inline bool operator !=(const ::std::fpos<_StateT> &__lhs, const ::std::fpos<_StateT> &__rhs);
  template < typename _StateT >
  inline bool operator !=(const ::std::fpos<_StateT> &__lhs, const ::std::fpos<_StateT> &__rhs)
  {
    return long(__lhs) != long(__rhs);
  }
  typedef ::std::fpos< ::__mbstate_t> streampos;
  typedef ::std::fpos< ::__mbstate_t> wstreampos;
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  template < typename _CharT >
  struct  _Char_types
  {
      typedef unsigned long int int_type;
      typedef ::std::streampos pos_type;
      typedef ::std::streamoff off_type;
      typedef ::mbstate_t state_type;
  };
  template < typename _CharT >
  struct  char_traits
  {
      typedef _CharT char_type;
      typedef typename ::__gnu_cxx::_Char_types<_CharT>::int_type int_type;
      typedef typename ::__gnu_cxx::_Char_types<_CharT>::pos_type pos_type;
      typedef typename ::__gnu_cxx::_Char_types<_CharT>::off_type off_type;
      typedef typename ::__gnu_cxx::_Char_types<_CharT>::state_type state_type;
      static inline void assign(typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c2)
      {
        __c1 = __c2;
      }
      static inline bool eq(const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c2)
      {
        return __c1 == __c2;
      }
      static inline bool lt(const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c2)
      {
        return __c1 < __c2;
      }
      static int compare(const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s2, ::std::size_t __n);
      static ::std::size_t length(const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__p);
      static const typename ::__gnu_cxx::char_traits<_CharT>::char_type *find(const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s, ::std::size_t __n, const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__a);
      static typename ::__gnu_cxx::char_traits<_CharT>::char_type *move(typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s2, ::std::size_t __n);
      static typename ::__gnu_cxx::char_traits<_CharT>::char_type *copy(typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s2, ::std::size_t __n);
      static typename ::__gnu_cxx::char_traits<_CharT>::char_type *assign(typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s, ::std::size_t __n, typename ::__gnu_cxx::char_traits<_CharT>::char_type __a);
      static inline typename ::__gnu_cxx::char_traits<_CharT>::char_type to_char_type(const typename ::__gnu_cxx::char_traits<_CharT>::int_type &__c)
      {
        return static_cast<typename ::__gnu_cxx::char_traits<_CharT>::char_type>(__c);
      }
      static inline typename ::__gnu_cxx::char_traits<_CharT>::int_type to_int_type(const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c)
      {
        return static_cast<typename ::__gnu_cxx::char_traits<_CharT>::int_type>(__c);
      }
      static inline bool eq_int_type(const typename ::__gnu_cxx::char_traits<_CharT>::int_type &__c1, const typename ::__gnu_cxx::char_traits<_CharT>::int_type &__c2)
      {
        return __c1 == __c2;
      }
      static inline typename ::__gnu_cxx::char_traits<_CharT>::int_type eof()
      {
        return static_cast<typename ::__gnu_cxx::char_traits<_CharT>::int_type>( -1);
      }
      static inline typename ::__gnu_cxx::char_traits<_CharT>::int_type not_eof(const typename ::__gnu_cxx::char_traits<_CharT>::int_type &__c)
      {
        return !eq_int_type(__c, eof()) ? __c : to_int_type(((typename ::__gnu_cxx::char_traits<_CharT>::char_type())));
      }
  };
  template < typename _CharT >
  int char_traits<_CharT>::compare(const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s2, ::std::size_t __n)
  {
    for (::std::size_t __i(0); __i < __n;  ++__i)
      {
        if (lt(__s1[__i], __s2[__i]))
          {
            return  -1;
          }
        else
          {
            if (lt(__s2[__i], __s1[__i]))
              {
                return 1;
              }
          }
      }
    return 0;
  }
  template < typename _CharT >
  ::std::size_t char_traits<_CharT>::length(const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__p)
  {
    ::std::size_t __i(0);
    while (!eq(__p[__i], ((typename ::__gnu_cxx::char_traits<_CharT>::char_type()))))
      {
         ++__i;
      }
    return __i;
  }
  template < typename _CharT >
  const typename ::__gnu_cxx::char_traits<_CharT>::char_type *char_traits<_CharT>::find(const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s, ::std::size_t __n, const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__a)
  {
    for (::std::size_t __i(0); __i < __n;  ++__i)
      {
        if (eq(__s[__i], __a))
          {
            return __s + __i;
          }
      }
    return 0;
  }
  template < typename _CharT >
  typename ::__gnu_cxx::char_traits<_CharT>::char_type *char_traits<_CharT>::move(typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s2, ::std::size_t __n)
  {
    return static_cast<_CharT *>(__builtin_memmove(__s1, __s2, __n * sizeof(typename ::__gnu_cxx::char_traits<_CharT>::char_type)));
  }
  template < typename _CharT >
  typename ::__gnu_cxx::char_traits<_CharT>::char_type *char_traits<_CharT>::copy(typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s2, ::std::size_t __n)
  {
    std::copy(__s2, __s2 + __n, __s1);
    return __s1;
  }
  template < typename _CharT >
  typename ::__gnu_cxx::char_traits<_CharT>::char_type *char_traits<_CharT>::assign(typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s, ::std::size_t __n, typename ::__gnu_cxx::char_traits<_CharT>::char_type __a)
  {
    std::fill_n(__s, __n, __a);
    return __s;
  }
}
namespace std __attribute__((__visibility__("default"))) {
  template < typename _CharT >
  struct  char_traits : ::__gnu_cxx::char_traits<_CharT>
  {
  };
  template <>
  struct  char_traits<char>
  {
      typedef char char_type;
      typedef int int_type;
      typedef ::std::streampos pos_type;
      typedef ::std::streamoff off_type;
      typedef ::mbstate_t state_type;
      static inline void assign(::std::char_traits<char>::char_type &__c1, const ::std::char_traits<char>::char_type &__c2)
      {
        __c1 = __c2;
      }
      static inline bool eq(const ::std::char_traits<char>::char_type &__c1, const ::std::char_traits<char>::char_type &__c2)
      {
        return __c1 == __c2;
      }
      static inline bool lt(const ::std::char_traits<char>::char_type &__c1, const ::std::char_traits<char>::char_type &__c2)
      {
        return static_cast<unsigned char>(__c1) < static_cast<unsigned char>(__c2);
      }
      static inline int compare(const ::std::char_traits<char>::char_type *__s1, const ::std::char_traits<char>::char_type *__s2, ::std::size_t __n)
      {
        if (__n == 0)
          {
            return 0;
          }
        return __builtin_memcmp(__s1, __s2, __n);
      }
      static inline ::std::size_t length(const ::std::char_traits<char>::char_type *__s)
      {
        return __builtin_strlen(__s);
      }
      static inline const ::std::char_traits<char>::char_type *find(const ::std::char_traits<char>::char_type *__s, ::std::size_t __n, const ::std::char_traits<char>::char_type &__a)
      {
        if (__n == 0)
          {
            return 0;
          }
        return static_cast<const ::std::char_traits<char>::char_type *>(__builtin_memchr(__s, __a, __n));
      }
      static inline ::std::char_traits<char>::char_type *move(::std::char_traits<char>::char_type *__s1, const ::std::char_traits<char>::char_type *__s2, ::std::size_t __n)
      {
        if (__n == 0)
          {
            return __s1;
          }
        return static_cast< ::std::char_traits<char>::char_type *>(__builtin_memmove(__s1, __s2, __n));
      }
      static inline ::std::char_traits<char>::char_type *copy(::std::char_traits<char>::char_type *__s1, const ::std::char_traits<char>::char_type *__s2, ::std::size_t __n)
      {
        if (__n == 0)
          {
            return __s1;
          }
        return static_cast< ::std::char_traits<char>::char_type *>(__builtin_memcpy(__s1, __s2, __n));
      }
      static inline ::std::char_traits<char>::char_type *assign(::std::char_traits<char>::char_type *__s, ::std::size_t __n, ::std::char_traits<char>::char_type __a)
      {
        if (__n == 0)
          {
            return __s;
          }
        return static_cast< ::std::char_traits<char>::char_type *>(__builtin_memset(__s, __a, __n));
      }
      static inline ::std::char_traits<char>::char_type to_char_type(const ::std::char_traits<char>::int_type &__c)
      {
        return static_cast< ::std::char_traits<char>::char_type>(__c);
      }
      static inline ::std::char_traits<char>::int_type to_int_type(const ::std::char_traits<char>::char_type &__c)
      {
        return static_cast< ::std::char_traits<char>::int_type>(static_cast<unsigned char>(__c));
      }
      static inline bool eq_int_type(const ::std::char_traits<char>::int_type &__c1, const ::std::char_traits<char>::int_type &__c2)
      {
        return __c1 == __c2;
      }
      static inline ::std::char_traits<char>::int_type eof()
      {
        return static_cast< ::std::char_traits<char>::int_type>( -1);
      }
      static inline ::std::char_traits<char>::int_type not_eof(const ::std::char_traits<char>::int_type &__c)
      {
        return __c == ::std::char_traits<char>::eof() ? 0 : __c;
      }
  };
  template <>
  struct  char_traits<wchar_t>
  {
      typedef wchar_t char_type;
      typedef ::wint_t int_type;
      typedef ::std::streamoff off_type;
      typedef ::std::wstreampos pos_type;
      typedef ::mbstate_t state_type;
      static inline void assign(::std::char_traits<wchar_t>::char_type &__c1, const ::std::char_traits<wchar_t>::char_type &__c2)
      {
        __c1 = __c2;
      }
      static inline bool eq(const ::std::char_traits<wchar_t>::char_type &__c1, const ::std::char_traits<wchar_t>::char_type &__c2)
      {
        return __c1 == __c2;
      }
      static inline bool lt(const ::std::char_traits<wchar_t>::char_type &__c1, const ::std::char_traits<wchar_t>::char_type &__c2)
      {
        return __c1 < __c2;
      }
      static inline int compare(const ::std::char_traits<wchar_t>::char_type *__s1, const ::std::char_traits<wchar_t>::char_type *__s2, ::std::size_t __n)
      {
        if (__n == 0)
          {
            return 0;
          }
        else
          {
            return ::std::wmemcmp(__s1, __s2, __n);
          }
      }
      static inline ::std::size_t length(const ::std::char_traits<wchar_t>::char_type *__s)
      {
        return ::std::wcslen(__s);
      }
      static inline const ::std::char_traits<wchar_t>::char_type *find(const ::std::char_traits<wchar_t>::char_type *__s, ::std::size_t __n, const ::std::char_traits<wchar_t>::char_type &__a)
      {
        if (__n == 0)
          {
            return 0;
          }
        else
          {
            return ::std::wmemchr(__s, __a, __n);
          }
      }
      static inline ::std::char_traits<wchar_t>::char_type *move(::std::char_traits<wchar_t>::char_type *__s1, const ::std::char_traits<wchar_t>::char_type *__s2, ::std::size_t __n)
      {
        if (__n == 0)
          {
            return __s1;
          }
        return ::std::wmemmove(__s1, __s2, __n);
      }
      static inline ::std::char_traits<wchar_t>::char_type *copy(::std::char_traits<wchar_t>::char_type *__s1, const ::std::char_traits<wchar_t>::char_type *__s2, ::std::size_t __n)
      {
        if (__n == 0)
          {
            return __s1;
          }
        return ::std::wmemcpy(__s1, __s2, __n);
      }
      static inline ::std::char_traits<wchar_t>::char_type *assign(::std::char_traits<wchar_t>::char_type *__s, ::std::size_t __n, ::std::char_traits<wchar_t>::char_type __a)
      {
        if (__n == 0)
          {
            return __s;
          }
        return ::std::wmemset(__s, __a, __n);
      }
      static inline ::std::char_traits<wchar_t>::char_type to_char_type(const ::std::char_traits<wchar_t>::int_type &__c)
      {
        return (::std::char_traits<wchar_t>::char_type)__c;
      }
      static inline ::std::char_traits<wchar_t>::int_type to_int_type(const ::std::char_traits<wchar_t>::char_type &__c)
      {
        return (::std::char_traits<wchar_t>::int_type)__c;
      }
      static inline bool eq_int_type(const ::std::char_traits<wchar_t>::int_type &__c1, const ::std::char_traits<wchar_t>::int_type &__c2)
      {
        return __c1 == __c2;
      }
      static inline ::std::char_traits<wchar_t>::int_type eof()
      {
        return static_cast< ::std::char_traits<wchar_t>::int_type>(4294967295U);
      }
      static inline ::std::char_traits<wchar_t>::int_type not_eof(const ::std::char_traits<wchar_t>::int_type &__c)
      {
        return ::std::char_traits<wchar_t>::eq_int_type(__c, ::std::char_traits<wchar_t>::eof()) ? 0 : __c;
      }
  };
}
#pragma GCC visibility push(default)
#pragma GCC visibility push(default)
namespace std __attribute__((__visibility__("default"))) {
  class  exception
  {
    public:
      inline exception() throw()
      {
      }
      virtual ~exception() throw();
      virtual const char *what() const  throw();
  };
}
#pragma GCC visibility pop
namespace std __attribute__((__visibility__("default"))) {
  class  bad_exception : public ::std::exception
  {
    public:
      inline bad_exception() throw()
      {
      }
      virtual ~bad_exception() throw();
      virtual const char *what() const  throw();
  };
  typedef void (*terminate_handler)();
  typedef void (*unexpected_handler)();
  ::std::terminate_handler set_terminate(::std::terminate_handler) throw();
  void terminate() throw() __attribute__((__noreturn__));
  ::std::unexpected_handler set_unexpected(::std::unexpected_handler) throw();
  void unexpected() __attribute__((__noreturn__));
  bool uncaught_exception() throw() __attribute__((__pure__));
  int uncaught_exceptions() throw() __attribute__((__pure__));
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  void __verbose_terminate_handler();
}
#pragma GCC visibility pop
#pragma GCC visibility push(default)
namespace std __attribute__((__visibility__("default"))) {
  class  bad_alloc : public ::std::exception
  {
    public:
      inline bad_alloc() throw()
      {
      }
      virtual ~bad_alloc() throw();
      virtual const char *what() const  throw();
  };
  struct  nothrow_t
  {
  };
  extern const ::std::nothrow_t nothrow;
  typedef void (*new_handler)();
  ::std::new_handler set_new_handler(::std::new_handler) throw();
}
void *operator new(::std::size_t, const ::std::nothrow_t &) throw() __attribute__((__externally_visible__));
void *operator new[](::std::size_t, const ::std::nothrow_t &) throw() __attribute__((__externally_visible__));
void operator delete(void *, const ::std::nothrow_t &) throw() __attribute__((__externally_visible__));
void operator delete[](void *, const ::std::nothrow_t &) throw() __attribute__((__externally_visible__));
inline void *operator new(::std::size_t, void *__p) throw()
{
  return __p;
}
inline void *operator new[](::std::size_t, void *__p) throw()
{
  return __p;
}
inline void operator delete(void *, void *) throw()
{
}
inline void operator delete[](void *, void *) throw()
{
}
#pragma GCC visibility pop
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  using ::std::size_t;
  using ::std::ptrdiff_t;
  template < typename _Tp >
  class  new_allocator
  {
    public:
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef _Tp *pointer;
      typedef const _Tp *const_pointer;
      typedef _Tp &reference;
      typedef const _Tp &const_reference;
      typedef _Tp value_type;
      template < typename _Tp1 >
      struct  rebind
      {
          typedef ::__gnu_cxx::new_allocator<_Tp1> other;
      };
      inline new_allocator() throw()
      {
      }
      inline new_allocator(const ::__gnu_cxx::new_allocator<_Tp> &) throw()
      {
      }
      template < typename _Tp1 >
      inline new_allocator(const ::__gnu_cxx::new_allocator<_Tp1> &) throw()
      {
      }
      inline ~new_allocator() throw()
      {
      }
      inline typename ::__gnu_cxx::new_allocator<_Tp>::pointer address(typename ::__gnu_cxx::new_allocator<_Tp>::reference __x) const 
      {
        return std::__addressof(__x);
      }
      inline typename ::__gnu_cxx::new_allocator<_Tp>::const_pointer address(typename ::__gnu_cxx::new_allocator<_Tp>::const_reference __x) const 
      {
        return std::__addressof(__x);
      }
      inline typename ::__gnu_cxx::new_allocator<_Tp>::pointer allocate(typename ::__gnu_cxx::new_allocator<_Tp>::size_type __n, const void *  = (static_cast<const void *>(0)))
      {
        if (__n > this->max_size())
          {
            std::__throw_bad_alloc();
          }
        return static_cast<_Tp *>(::operator new(__n * sizeof(_Tp)));
      }
      inline void deallocate(typename ::__gnu_cxx::new_allocator<_Tp>::pointer __p, typename ::__gnu_cxx::new_allocator<_Tp>::size_type)
      {
        ::operator delete(__p);
      }
      inline typename ::__gnu_cxx::new_allocator<_Tp>::size_type max_size() const  throw()
      {
        return (::std::size_t) -1 / sizeof(_Tp);
      }
      inline void construct(typename ::__gnu_cxx::new_allocator<_Tp>::pointer __p, const _Tp &__val)
      {
        ::new ((void *)__p)_Tp(__val);
      }
      inline void destroy(typename ::__gnu_cxx::new_allocator<_Tp>::pointer __p)
      {
        __p->~_Tp();
      }
  };
  template < typename _Tp >
  inline bool operator ==(const ::__gnu_cxx::new_allocator<_Tp> &, const ::__gnu_cxx::new_allocator<_Tp> &);
  template < typename _Tp >
  inline bool operator ==(const ::__gnu_cxx::new_allocator<_Tp> &, const ::__gnu_cxx::new_allocator<_Tp> &)
  {
    return true;
  }
  template < typename _Tp >
  inline bool operator !=(const ::__gnu_cxx::new_allocator<_Tp> &, const ::__gnu_cxx::new_allocator<_Tp> &);
  template < typename _Tp >
  inline bool operator !=(const ::__gnu_cxx::new_allocator<_Tp> &, const ::__gnu_cxx::new_allocator<_Tp> &)
  {
    return false;
  }
}
namespace std __attribute__((__visibility__("default"))) {
  template <>
  class  allocator<void>
  {
    public:
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef void *pointer;
      typedef const void *const_pointer;
      typedef void value_type;
      template < typename _Tp1 >
      struct  rebind
      {
          typedef ::std::allocator<_Tp1> other;
      };
  };
  template < typename _Tp >
  class  allocator : public ::__gnu_cxx::new_allocator<_Tp>
  {
    public:
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef _Tp *pointer;
      typedef const _Tp *const_pointer;
      typedef _Tp &reference;
      typedef const _Tp &const_reference;
      typedef _Tp value_type;
      template < typename _Tp1 >
      struct  rebind
      {
          typedef ::std::allocator<_Tp1> other;
      };
      inline allocator() throw()
      {
      }
      inline allocator(const ::std::allocator<_Tp> &__a) throw()
        : __gnu_cxx::new_allocator<_Tp>(__a)
      {
      }
      template < typename _Tp1 >
      inline allocator(const ::std::allocator<_Tp1> &) throw()
      {
      }
      inline ~allocator() throw()
      {
      }
  };
  template < typename _T1, typename _T2 >
  inline bool operator ==(const ::std::allocator<_T1> &, const ::std::allocator<_T2> &) throw();
  template < typename _T1, typename _T2 >
  inline bool operator ==(const ::std::allocator<_T1> &, const ::std::allocator<_T2> &) throw()
  {
    return true;
  }
  template < typename _Tp >
  inline bool operator ==(const ::std::allocator<_Tp> &, const ::std::allocator<_Tp> &) throw();
  template < typename _Tp >
  inline bool operator ==(const ::std::allocator<_Tp> &, const ::std::allocator<_Tp> &) throw()
  {
    return true;
  }
  template < typename _T1, typename _T2 >
  inline bool operator !=(const ::std::allocator<_T1> &, const ::std::allocator<_T2> &) throw();
  template < typename _T1, typename _T2 >
  inline bool operator !=(const ::std::allocator<_T1> &, const ::std::allocator<_T2> &) throw()
  {
    return false;
  }
  template < typename _Tp >
  inline bool operator !=(const ::std::allocator<_Tp> &, const ::std::allocator<_Tp> &) throw();
  template < typename _Tp >
  inline bool operator !=(const ::std::allocator<_Tp> &, const ::std::allocator<_Tp> &) throw()
  {
    return false;
  }
  extern template class ::std::allocator<char>;
  extern template class ::std::allocator<wchar_t>;
  template < typename _Alloc, bool __nontype_tpl_param_1_1__ = __is_empty(_Alloc) >
  struct  __alloc_swap
  {
      static inline void _S_do_it(_Alloc &, _Alloc &)
      {
      }
  };
  template < typename _Alloc >
  struct  __alloc_swap<_Alloc, false>
  {
      static inline void _S_do_it(_Alloc &__one, _Alloc &__two)
      {
        if (__one != __two)
          {
            swap(__one, __two);
          }
      }
  };
  template < typename _Alloc, bool __nontype_tpl_param_1_1__ = __is_empty(_Alloc) >
  struct  __alloc_neq
  {
      static inline bool _S_do_it(const _Alloc &, const _Alloc &)
      {
        return false;
      }
  };
  template < typename _Alloc >
  struct  __alloc_neq<_Alloc, false>
  {
      static inline bool _S_do_it(const _Alloc &__one, const _Alloc &__two)
      {
        return __one != __two;
      }
  };
}
struct  lconv
{
    char *decimal_point;
    char *thousands_sep;
    char *grouping;
    char *int_curr_symbol;
    char *currency_symbol;
    char *mon_decimal_point;
    char *mon_thousands_sep;
    char *mon_grouping;
    char *positive_sign;
    char *negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
    char int_p_cs_precedes;
    char int_p_sep_by_space;
    char int_n_cs_precedes;
    char int_n_sep_by_space;
    char int_p_sign_posn;
    char int_n_sign_posn;
};
extern "C"
{
  extern char *setlocale(int __category, const char *__locale) throw();
}
extern "C"
{
  extern ::lconv *localeconv() throw();
}
extern "C"
{
  extern ::locale_t newlocale(int __category_mask, const char *__locale, ::locale_t __base) throw();
}
extern "C"
{
  extern ::locale_t duplocale(::locale_t __dataset) throw();
}
extern "C"
{
  extern void freelocale(::locale_t __dataset) throw();
}
extern "C"
{
  extern ::locale_t uselocale(::locale_t __dataset) throw();
}
namespace std __attribute__((__visibility__("default"))) {
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
extern "C"
  {
    ::locale_t __uselocale(::locale_t) throw();
  }
}
namespace std __attribute__((__visibility__("default"))) {
  typedef ::__locale_t __c_locale;
  inline int __convert_from_v(const ::std::__c_locale &__cloc __attribute__((__unused__)), char *__out, const int __size __attribute__((__unused__)), const char *__fmt, ...)
  {
    ::std::__c_locale __old(__gnu_cxx::__uselocale(__cloc));
    ::__builtin_va_list __args;
    __builtin_va_start(__args, __fmt);
    const int __ret(__builtin_vsnprintf(__out, __size, __fmt, __args));
    __builtin_va_end(__args);
    __gnu_cxx::__uselocale(__old);
    return __ret;
  }
  class ios_base;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_ios;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_streambuf;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_istream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_ostream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_iostream;
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    template < typename _CharT, typename _Traits = ::std::char_traits<_CharT>, typename _Alloc = ::std::allocator<_CharT> >
    class basic_stringbuf;
    template < typename _CharT, typename _Traits = ::std::char_traits<_CharT>, typename _Alloc = ::std::allocator<_CharT> >
    class basic_istringstream;
    template < typename _CharT, typename _Traits = ::std::char_traits<_CharT>, typename _Alloc = ::std::allocator<_CharT> >
    class basic_ostringstream;
    template < typename _CharT, typename _Traits = ::std::char_traits<_CharT>, typename _Alloc = ::std::allocator<_CharT> >
    class basic_stringstream;
  }
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_filebuf;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_ifstream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_ofstream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_fstream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class istreambuf_iterator;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class ostreambuf_iterator;
  typedef ::std::basic_ios<char> ios;
  typedef ::std::basic_streambuf<char> streambuf;
  typedef ::std::basic_istream<char> istream;
  typedef ::std::basic_ostream<char> ostream;
  typedef ::std::basic_iostream<char> iostream;
  typedef ::std::__cxx11::basic_stringbuf<char> stringbuf;
  typedef ::std::__cxx11::basic_istringstream<char> istringstream;
  typedef ::std::__cxx11::basic_ostringstream<char> ostringstream;
  typedef ::std::__cxx11::basic_stringstream<char> stringstream;
  typedef ::std::basic_filebuf<char> filebuf;
  typedef ::std::basic_ifstream<char> ifstream;
  typedef ::std::basic_ofstream<char> ofstream;
  typedef ::std::basic_fstream<char> fstream;
  typedef ::std::basic_ios<wchar_t> wios;
  typedef ::std::basic_streambuf<wchar_t> wstreambuf;
  typedef ::std::basic_istream<wchar_t> wistream;
  typedef ::std::basic_ostream<wchar_t> wostream;
  typedef ::std::basic_iostream<wchar_t> wiostream;
  typedef ::std::__cxx11::basic_stringbuf<wchar_t> wstringbuf;
  typedef ::std::__cxx11::basic_istringstream<wchar_t> wistringstream;
  typedef ::std::__cxx11::basic_ostringstream<wchar_t> wostringstream;
  typedef ::std::__cxx11::basic_stringstream<wchar_t> wstringstream;
  typedef ::std::basic_filebuf<wchar_t> wfilebuf;
  typedef ::std::basic_ifstream<wchar_t> wifstream;
  typedef ::std::basic_ofstream<wchar_t> wofstream;
  typedef ::std::basic_fstream<wchar_t> wfstream;
}
extern "C"
{
  static inline unsigned int __bswap_32(unsigned int __bsx)
  {
    return __builtin_bswap32(__bsx);
  }
}
extern "C"
{
  static inline ::__uint64_t __bswap_64(::__uint64_t __bsx)
  {
    return __builtin_bswap64(__bsx);
  }
}
extern "C"
{
  static inline ::__uint16_t __uint16_identity(::__uint16_t __x)
  {
    return __x;
  }
}
extern "C"
{
  static inline ::__uint32_t __uint32_identity(::__uint32_t __x)
  {
    return __x;
  }
}
extern "C"
{
  static inline ::__uint64_t __uint64_identity(::__uint64_t __x)
  {
    return __x;
  }
}
enum mcc_enum_anon_35
{
  _ISupper = 0 < 8 ? 1 << 0 << 8 : 1 << 0 >> 8,
  _ISlower = 1 < 8 ? 1 << 1 << 8 : 1 << 1 >> 8,
  _ISalpha = 2 < 8 ? 1 << 2 << 8 : 1 << 2 >> 8,
  _ISdigit = 3 < 8 ? 1 << 3 << 8 : 1 << 3 >> 8,
  _ISxdigit = 4 < 8 ? 1 << 4 << 8 : 1 << 4 >> 8,
  _ISspace = 5 < 8 ? 1 << 5 << 8 : 1 << 5 >> 8,
  _ISprint = 6 < 8 ? 1 << 6 << 8 : 1 << 6 >> 8,
  _ISgraph = 7 < 8 ? 1 << 7 << 8 : 1 << 7 >> 8,
  _ISblank = 8 < 8 ? 1 << 8 << 8 : 1 << 8 >> 8,
  _IScntrl = 9 < 8 ? 1 << 9 << 8 : 1 << 9 >> 8,
  _ISpunct = 10 < 8 ? 1 << 10 << 8 : 1 << 10 >> 8,
  _ISalnum = 11 < 8 ? 1 << 11 << 8 : 1 << 11 >> 8
};
extern "C"
{
  extern const unsigned short int **__ctype_b_loc() throw() __attribute__((__const__));
}
extern "C"
{
  extern const ::__int32_t **__ctype_tolower_loc() throw() __attribute__((__const__));
}
extern "C"
{
  extern const ::__int32_t **__ctype_toupper_loc() throw() __attribute__((__const__));
}
extern "C"
{
  extern int isalnum(int) throw();
}
extern "C"
{
  extern int isalpha(int) throw();
}
extern "C"
{
  extern int iscntrl(int) throw();
}
extern "C"
{
  extern int isdigit(int) throw();
}
extern "C"
{
  extern int islower(int) throw();
}
extern "C"
{
  extern int isgraph(int) throw();
}
extern "C"
{
  extern int isprint(int) throw();
}
extern "C"
{
  extern int ispunct(int) throw();
}
extern "C"
{
  extern int isspace(int) throw();
}
extern "C"
{
  extern int isupper(int) throw();
}
extern "C"
{
  extern int isxdigit(int) throw();
}
extern "C"
{
  extern int tolower(int __c) throw();
}
extern "C"
{
  extern int toupper(int __c) throw();
}
extern "C"
{
  extern int isblank(int) throw();
}
extern "C"
{
  extern int isctype(int __c, int __mask) throw();
}
extern "C"
{
  extern int isascii(int __c) throw();
}
extern "C"
{
  extern int toascii(int __c) throw();
}
extern "C"
{
  extern int _toupper(int) throw();
}
extern "C"
{
  extern int _tolower(int) throw();
}
extern "C"
{
  extern int isalnum_l(int, ::locale_t) throw();
}
extern "C"
{
  extern int isalpha_l(int, ::locale_t) throw();
}
extern "C"
{
  extern int iscntrl_l(int, ::locale_t) throw();
}
extern "C"
{
  extern int isdigit_l(int, ::locale_t) throw();
}
extern "C"
{
  extern int islower_l(int, ::locale_t) throw();
}
extern "C"
{
  extern int isgraph_l(int, ::locale_t) throw();
}
extern "C"
{
  extern int isprint_l(int, ::locale_t) throw();
}
extern "C"
{
  extern int ispunct_l(int, ::locale_t) throw();
}
extern "C"
{
  extern int isspace_l(int, ::locale_t) throw();
}
extern "C"
{
  extern int isupper_l(int, ::locale_t) throw();
}
extern "C"
{
  extern int isxdigit_l(int, ::locale_t) throw();
}
extern "C"
{
  extern int isblank_l(int, ::locale_t) throw();
}
extern "C"
{
  extern int __tolower_l(int __c, ::locale_t __l) throw();
}
extern "C"
{
  extern int tolower_l(int __c, ::locale_t __l) throw();
}
extern "C"
{
  extern int __toupper_l(int __c, ::locale_t __l) throw();
}
extern "C"
{
  extern int toupper_l(int __c, ::locale_t __l) throw();
}
namespace std __attribute__((__visibility__("default"))) {
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
  class locale;
  template < typename _Facet >
  bool has_facet(const ::std::locale &__loc) throw();
  template < typename _Facet >
  const _Facet &use_facet(const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isspace(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isprint(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool iscntrl(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isupper(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool islower(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isalpha(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isdigit(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool ispunct(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isxdigit(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isalnum(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isgraph(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline _CharT toupper(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline _CharT tolower(_CharT __c, const ::std::locale &__loc);
  struct ctype_base;
  template < typename _CharT >
  class ctype;
  template <>
  class ctype<char>;
  template <>
  class ctype<wchar_t>;
  template < typename _CharT >
  class ctype_byname;
  class codecvt_base;
  template < typename _InternT, typename _ExternT, typename _StateT >
  class codecvt;
  template <>
  class codecvt<char, char, ::__mbstate_t>;
  template <>
  class codecvt<wchar_t, char, ::__mbstate_t>;
  template < typename _InternT, typename _ExternT, typename _StateT >
  class codecvt_byname;
  template < typename _CharT, typename _InIter = ::std::istreambuf_iterator<_CharT> >
  class num_get;
  template < typename _CharT, typename _OutIter = ::std::ostreambuf_iterator<_CharT> >
  class num_put;
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    template < typename _CharT >
    class numpunct;
    template < typename _CharT >
    class numpunct_byname;
    template < typename _CharT >
    class collate;
    template < typename _CharT >
    class collate_byname;
  }
  class time_base;
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    template < typename _CharT, typename _InIter = ::std::istreambuf_iterator<_CharT> >
    class time_get;
    template < typename _CharT, typename _InIter = ::std::istreambuf_iterator<_CharT> >
    class time_get_byname;
  }
  template < typename _CharT, typename _OutIter = ::std::ostreambuf_iterator<_CharT> >
  class time_put;
  template < typename _CharT, typename _OutIter = ::std::ostreambuf_iterator<_CharT> >
  class time_put_byname;
  class money_base;
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    template < typename _CharT, typename _InIter = ::std::istreambuf_iterator<_CharT> >
    class money_get;
    template < typename _CharT, typename _OutIter = ::std::ostreambuf_iterator<_CharT> >
    class money_put;
    template < typename _CharT, bool _Intl = false >
    class moneypunct;
    template < typename _CharT, bool _Intl = false >
    class moneypunct_byname;
  }
  class messages_base;
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    template < typename _CharT >
    class messages;
    template < typename _CharT >
    class messages_byname;
  }
}
#pragma GCC visibility push(default)
namespace __cxxabiv1 {
  class  __forced_unwind
  {
      virtual ~__forced_unwind() throw();
      virtual void __pure_dummy() = 0 ;
    public:
  };
}
#pragma GCC visibility pop
namespace std __attribute__((__visibility__("default"))) {
  template < typename _CharT, typename _Traits >
  inline void __ostream_write(::std::basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, ::std::streamsize __n);
  template < typename _CharT, typename _Traits >
  inline void __ostream_write(::std::basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, ::std::streamsize __n)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const ::std::streamsize __put = __out.rdbuf()->sputn(__s, __n);
    if (__put != __n)
      {
        __out.setstate(__ios_base::badbit);
      }
  }
  template < typename _CharT, typename _Traits >
  inline void __ostream_fill(::std::basic_ostream<_CharT, _Traits> &__out, ::std::streamsize __n);
  template < typename _CharT, typename _Traits >
  inline void __ostream_fill(::std::basic_ostream<_CharT, _Traits> &__out, ::std::streamsize __n)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const _CharT __c = __out.fill();
    for (; __n > 0;  --__n)
      {
        const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
        if (_Traits::eq_int_type(__put, _Traits::eof()))
          {
            __out.setstate(__ios_base::badbit);
            break;
          }
      }
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &__ostream_insert(::std::basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, ::std::streamsize __n);
  template < typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &__ostream_insert(::std::basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, ::std::streamsize __n)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    typename ::std::basic_ostream<_CharT, _Traits>::sentry __cerb(__out);
    if (__cerb)
      {
        try
        {
          const ::std::streamsize __w = __out.width();
          if (__w > __n)
            {
              const bool __left = (__out.flags() & __ios_base::adjustfield) == __ios_base::left;
              if (!__left)
                {
                  __ostream_fill(__out, __w - __n);
                }
              if (__out.good())
                {
                  __ostream_write(__out, __s, __n);
                }
              if (__left && __out.good())
                {
                  __ostream_fill(__out, __w - __n);
                }
            }
          else
            {
              __ostream_write(__out, __s, __n);
            }
          __out.width(0);
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __out._M_setstate(__ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __out._M_setstate(__ios_base::badbit);
        }
      }
    return __out;
  }
  extern template ::std::basic_ostream<char> &__ostream_insert(::std::basic_ostream<char> &, const char *, long int);
  extern template ::std::basic_ostream<wchar_t> &__ostream_insert(::std::basic_ostream<wchar_t> &, const wchar_t *, long int);
  template < typename _Arg, typename _Result >
  struct  unary_function
  {
      typedef _Arg argument_type;
      typedef _Result result_type;
  };
  template < typename _Arg1, typename _Arg2, typename _Result >
  struct  binary_function
  {
      typedef _Arg1 first_argument_type;
      typedef _Arg2 second_argument_type;
      typedef _Result result_type;
  };
  template < typename _Tp >
  struct  plus : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x + __y;
      }
  };
  template < typename _Tp >
  struct  minus : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x - __y;
      }
  };
  template < typename _Tp >
  struct  multiplies : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x * __y;
      }
  };
  template < typename _Tp >
  struct  divides : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x / __y;
      }
  };
  template < typename _Tp >
  struct  modulus : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x % __y;
      }
  };
  template < typename _Tp >
  struct  negate : ::std::unary_function<_Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x) const 
      {
        return  -__x;
      }
  };
  template < typename _Tp >
  struct  equal_to : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x == __y;
      }
  };
  template < typename _Tp >
  struct  not_equal_to : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x != __y;
      }
  };
  template < typename _Tp >
  struct  greater : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x > __y;
      }
  };
  template < typename _Tp >
  struct  less : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x < __y;
      }
  };
  template < typename _Tp >
  struct  greater_equal : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x >= __y;
      }
  };
  template < typename _Tp >
  struct  less_equal : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x <= __y;
      }
  };
  template < typename _Tp >
  struct  logical_and : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x && __y;
      }
  };
  template < typename _Tp >
  struct  logical_or : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x || __y;
      }
  };
  template < typename _Tp >
  struct  logical_not : ::std::unary_function<_Tp, bool>
  {
      inline bool operator ()(const _Tp &__x) const 
      {
        return !__x;
      }
  };
  template < typename _Tp >
  struct  bit_and : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x & __y;
      }
  };
  template < typename _Tp >
  struct  bit_or : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x | __y;
      }
  };
  template < typename _Tp >
  struct  bit_xor : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x ^ __y;
      }
  };
  template < typename _Tp >
  struct  bit_not : ::std::unary_function<_Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x) const 
      {
        return ~__x;
      }
  };
  template < typename _Predicate >
  class  unary_negate : public ::std::unary_function<typename _Predicate::argument_type, bool>
  {
    protected:
      _Predicate _M_pred;
    public:
      inline explicit unary_negate(const _Predicate &__x)
        : _M_pred(__x)
      {
      }
      inline bool operator ()(const typename _Predicate::argument_type &__x) const 
      {
        return !::std::unary_negate<_Predicate>::_M_pred(__x);
      }
  };
  template < typename _Predicate >
  inline ::std::unary_negate<_Predicate> not1(const _Predicate &__pred);
  template < typename _Predicate >
  inline ::std::unary_negate<_Predicate> not1(const _Predicate &__pred)
  {
    return ::std::unary_negate<_Predicate>(__pred);
  }
  template < typename _Predicate >
  class  binary_negate : public ::std::binary_function<typename _Predicate::first_argument_type, typename _Predicate::second_argument_type, bool>
  {
    protected:
      _Predicate _M_pred;
    public:
      inline explicit binary_negate(const _Predicate &__x)
        : _M_pred(__x)
      {
      }
      inline bool operator ()(const typename _Predicate::first_argument_type &__x, const typename _Predicate::second_argument_type &__y) const 
      {
        return !::std::binary_negate<_Predicate>::_M_pred(__x, __y);
      }
  };
  template < typename _Predicate >
  inline ::std::binary_negate<_Predicate> not2(const _Predicate &__pred);
  template < typename _Predicate >
  inline ::std::binary_negate<_Predicate> not2(const _Predicate &__pred)
  {
    return ::std::binary_negate<_Predicate>(__pred);
  }
  template < typename _Arg, typename _Result >
  class  pointer_to_unary_function : public ::std::unary_function<_Arg, _Result>
  {
    protected:
      _Result (*_M_ptr)(_Arg);
    public:
      inline pointer_to_unary_function()
      {
      }
      inline explicit pointer_to_unary_function(_Result (*__x)(_Arg))
        : _M_ptr(__x)
      {
      }
      inline _Result operator ()(_Arg __x) const 
      {
        return ::std::pointer_to_unary_function<_Arg, _Result>::_M_ptr(__x);
      }
  };
  template < typename _Arg, typename _Result >
  inline ::std::pointer_to_unary_function<_Arg, _Result> ptr_fun(_Result (*__x)(_Arg));
  template < typename _Arg, typename _Result >
  inline ::std::pointer_to_unary_function<_Arg, _Result> ptr_fun(_Result (*__x)(_Arg))
  {
    return ::std::pointer_to_unary_function<_Arg, _Result>(__x);
  }
  template < typename _Arg1, typename _Arg2, typename _Result >
  class  pointer_to_binary_function : public ::std::binary_function<_Arg1, _Arg2, _Result>
  {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);
    public:
      inline pointer_to_binary_function()
      {
      }
      inline explicit pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
        : _M_ptr(__x)
      {
      }
      inline _Result operator ()(_Arg1 __x, _Arg2 __y) const 
      {
        return ::std::pointer_to_binary_function<_Arg1, _Arg2, _Result>::_M_ptr(__x, __y);
      }
  };
  template < typename _Arg1, typename _Arg2, typename _Result >
  inline ::std::pointer_to_binary_function<_Arg1, _Arg2, _Result> ptr_fun(_Result (*__x)(_Arg1, _Arg2));
  template < typename _Arg1, typename _Arg2, typename _Result >
  inline ::std::pointer_to_binary_function<_Arg1, _Arg2, _Result> ptr_fun(_Result (*__x)(_Arg1, _Arg2))
  {
    return ::std::pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x);
  }
  template < typename _Tp >
  struct  _Identity : ::std::unary_function<_Tp, _Tp>
  {
      inline _Tp &operator ()(_Tp &__x) const 
      {
        return __x;
      }
      inline const _Tp &operator ()(const _Tp &__x) const 
      {
        return __x;
      }
  };
  template < typename _Pair >
  struct  _Select1st : ::std::unary_function<_Pair, typename _Pair::first_type>
  {
      inline typename _Pair::first_type &operator ()(_Pair &__x) const 
      {
        return __x.first;
      }
      inline const typename _Pair::first_type &operator ()(const _Pair &__x) const 
      {
        return __x.first;
      }
  };
  template < typename _Pair >
  struct  _Select2nd : ::std::unary_function<_Pair, typename _Pair::second_type>
  {
      inline typename _Pair::second_type &operator ()(_Pair &__x) const 
      {
        return __x.second;
      }
      inline const typename _Pair::second_type &operator ()(const _Pair &__x) const 
      {
        return __x.second;
      }
  };
  template < typename _Ret, typename _Tp >
  class  mem_fun_t : public ::std::unary_function<_Tp *, _Ret>
  {
    public:
      inline explicit mem_fun_t(_Ret (_Tp::*__pf)())
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(_Tp *__p) const 
      {
        return (__p->*::std::mem_fun_t<_Ret, _Tp>::_M_f)();
      }
    private:
      _Ret (_Tp::*_M_f)();
  };
  template < typename _Ret, typename _Tp >
  class  const_mem_fun_t : public ::std::unary_function<const _Tp *, _Ret>
  {
    public:
      inline explicit const_mem_fun_t(_Ret (_Tp::*__pf)() const )
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(const _Tp *__p) const 
      {
        return (__p->*::std::const_mem_fun_t<_Ret, _Tp>::_M_f)();
      }
    private:
      _Ret (_Tp::*_M_f)() const ;
  };
  template < typename _Ret, typename _Tp >
  class  mem_fun_ref_t : public ::std::unary_function<_Tp, _Ret>
  {
    public:
      inline explicit mem_fun_ref_t(_Ret (_Tp::*__pf)())
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(_Tp &__r) const 
      {
        return (__r.*::std::mem_fun_ref_t<_Ret, _Tp>::_M_f)();
      }
    private:
      _Ret (_Tp::*_M_f)();
  };
  template < typename _Ret, typename _Tp >
  class  const_mem_fun_ref_t : public ::std::unary_function<_Tp, _Ret>
  {
    public:
      inline explicit const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const )
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(const _Tp &__r) const 
      {
        return (__r.*::std::const_mem_fun_ref_t<_Ret, _Tp>::_M_f)();
      }
    private:
      _Ret (_Tp::*_M_f)() const ;
  };
  template < typename _Ret, typename _Tp, typename _Arg >
  class  mem_fun1_t : public ::std::binary_function<_Tp *, _Arg, _Ret>
  {
    public:
      inline explicit mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(_Tp *__p, _Arg __x) const 
      {
        return (__p->*::std::mem_fun1_t<_Ret, _Tp, _Arg>::_M_f)(__x);
      }
    private:
      _Ret (_Tp::*_M_f)(_Arg);
  };
  template < typename _Ret, typename _Tp, typename _Arg >
  class  const_mem_fun1_t : public ::std::binary_function<const _Tp *, _Arg, _Ret>
  {
    public:
      inline explicit const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const )
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(const _Tp *__p, _Arg __x) const 
      {
        return (__p->*::std::const_mem_fun1_t<_Ret, _Tp, _Arg>::_M_f)(__x);
      }
    private:
      _Ret (_Tp::*_M_f)(_Arg) const ;
  };
  template < typename _Ret, typename _Tp, typename _Arg >
  class  mem_fun1_ref_t : public ::std::binary_function<_Tp, _Arg, _Ret>
  {
    public:
      inline explicit mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(_Tp &__r, _Arg __x) const 
      {
        return (__r.*::std::mem_fun1_ref_t<_Ret, _Tp, _Arg>::_M_f)(__x);
      }
    private:
      _Ret (_Tp::*_M_f)(_Arg);
  };
  template < typename _Ret, typename _Tp, typename _Arg >
  class  const_mem_fun1_ref_t : public ::std::binary_function<_Tp, _Arg, _Ret>
  {
    public:
      inline explicit const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const )
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(const _Tp &__r, _Arg __x) const 
      {
        return (__r.*::std::const_mem_fun1_ref_t<_Ret, _Tp, _Arg>::_M_f)(__x);
      }
    private:
      _Ret (_Tp::*_M_f)(_Arg) const ;
  };
  template < typename _Ret, typename _Tp >
  inline ::std::mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)());
  template < typename _Ret, typename _Tp >
  inline ::std::mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)())
  {
    return ::std::mem_fun_t<_Ret, _Tp>(__f);
  }
  template < typename _Ret, typename _Tp >
  inline ::std::const_mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)() const );
  template < typename _Ret, typename _Tp >
  inline ::std::const_mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)() const )
  {
    return ::std::const_mem_fun_t<_Ret, _Tp>(__f);
  }
  template < typename _Ret, typename _Tp >
  inline ::std::mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)());
  template < typename _Ret, typename _Tp >
  inline ::std::mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)())
  {
    return ::std::mem_fun_ref_t<_Ret, _Tp>(__f);
  }
  template < typename _Ret, typename _Tp >
  inline ::std::const_mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)() const );
  template < typename _Ret, typename _Tp >
  inline ::std::const_mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)() const )
  {
    return ::std::const_mem_fun_ref_t<_Ret, _Tp>(__f);
  }
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg));
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg))
  {
    return ::std::mem_fun1_t<_Ret, _Tp, _Arg>(__f);
  }
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::const_mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg) const );
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::const_mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg) const )
  {
    return ::std::const_mem_fun1_t<_Ret, _Tp, _Arg>(__f);
  }
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg));
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
  {
    return ::std::mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f);
  }
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::const_mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const );
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::const_mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const )
  {
    return ::std::const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f);
  }
}
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
namespace std __attribute__((__visibility__("default"))) {
  template < typename _Operation >
  class  binder1st : public ::std::unary_function<typename _Operation::second_argument_type, typename _Operation::result_type>
  {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;
    public:
      inline binder1st(const _Operation &__x, const typename _Operation::first_argument_type &__y)
        : op(__x), value(__y)
      {
      }
      inline typename _Operation::result_type operator ()(const typename _Operation::second_argument_type &__x) const 
      {
        return ::std::binder1st<_Operation>::op(::std::binder1st<_Operation>::value, __x);
      }
      inline typename _Operation::result_type operator ()(typename _Operation::second_argument_type &__x) const 
      {
        return ::std::binder1st<_Operation>::op(::std::binder1st<_Operation>::value, __x);
      }
  };
  template < typename _Operation, typename _Tp >
  inline ::std::binder1st<_Operation> bind1st(const _Operation &__fn, const _Tp &__x);
  template < typename _Operation, typename _Tp >
  inline ::std::binder1st<_Operation> bind1st(const _Operation &__fn, const _Tp &__x)
  {
    typedef typename _Operation::first_argument_type _Arg1_type;
    return ::std::binder1st<_Operation>(__fn, _Arg1_type(__x));
  }
  template < typename _Operation >
  class  binder2nd : public ::std::unary_function<typename _Operation::first_argument_type, typename _Operation::result_type>
  {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;
    public:
      inline binder2nd(const _Operation &__x, const typename _Operation::second_argument_type &__y)
        : op(__x), value(__y)
      {
      }
      inline typename _Operation::result_type operator ()(const typename _Operation::first_argument_type &__x) const 
      {
        return ::std::binder2nd<_Operation>::op(__x, ::std::binder2nd<_Operation>::value);
      }
      inline typename _Operation::result_type operator ()(typename _Operation::first_argument_type &__x) const 
      {
        return ::std::binder2nd<_Operation>::op(__x, ::std::binder2nd<_Operation>::value);
      }
  };
  template < typename _Operation, typename _Tp >
  inline ::std::binder2nd<_Operation> bind2nd(const _Operation &__fn, const _Tp &__x);
  template < typename _Operation, typename _Tp >
  inline ::std::binder2nd<_Operation> bind2nd(const _Operation &__fn, const _Tp &__x)
  {
    typedef typename _Operation::second_argument_type _Arg2_type;
    return ::std::binder2nd<_Operation>(__fn, _Arg2_type(__x));
  }
}
#pragma GCC diagnostic pop
#pragma GCC visibility push(default)
typedef ::__time_t time_t;
struct  timespec
{
    ::__time_t tv_sec;
    ::__syscall_slong_t tv_nsec;
};
typedef ::__pid_t pid_t;
struct  sched_param
{
    int sched_priority;
};
extern "C"
{
  extern int clone(int (*__fn)(void *), void *__child_stack, int __flags, void *__arg, ...) throw();
}
extern "C"
{
  extern int unshare(int __flags) throw();
}
extern "C"
{
  extern int sched_getcpu() throw();
}
extern "C"
{
  extern int setns(int __fd, int __nstype) throw();
}
typedef unsigned long int __cpu_mask;
struct  cpu_set_t
{
    ::__cpu_mask __bits[16L];
};
extern "C"
{
  extern int __sched_cpucount(::size_t __setsize, const ::cpu_set_t *__setp) throw();
}
extern "C"
{
  extern ::cpu_set_t *__sched_cpualloc(::size_t __count) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern void __sched_cpufree(::cpu_set_t *__set) throw();
}
extern "C"
{
  extern int sched_setparam(::__pid_t __pid, const ::sched_param *__param) throw();
}
extern "C"
{
  extern int sched_getparam(::__pid_t __pid, ::sched_param *__param) throw();
}
extern "C"
{
  extern int sched_setscheduler(::__pid_t __pid, int __policy, const ::sched_param *__param) throw();
}
extern "C"
{
  extern int sched_getscheduler(::__pid_t __pid) throw();
}
extern "C"
{
  extern int sched_yield() throw();
}
extern "C"
{
  extern int sched_get_priority_max(int __algorithm) throw();
}
extern "C"
{
  extern int sched_get_priority_min(int __algorithm) throw();
}
extern "C"
{
  extern int sched_rr_get_interval(::__pid_t __pid, ::timespec *__t) throw();
}
extern "C"
{
  extern int sched_setaffinity(::__pid_t __pid, ::size_t __cpusetsize, const ::cpu_set_t *__cpuset) throw();
}
extern "C"
{
  extern int sched_getaffinity(::__pid_t __pid, ::size_t __cpusetsize, ::cpu_set_t *__cpuset) throw();
}
struct  timeval
{
    ::__time_t tv_sec;
    ::__suseconds_t tv_usec;
};
struct  timex
{
    unsigned int modes;
    ::__syscall_slong_t offset;
    ::__syscall_slong_t freq;
    ::__syscall_slong_t maxerror;
    ::__syscall_slong_t esterror;
    int status;
    ::__syscall_slong_t constant;
    ::__syscall_slong_t precision;
    ::__syscall_slong_t tolerance;
    ::timeval time;
    ::__syscall_slong_t tick;
    ::__syscall_slong_t ppsfreq;
    ::__syscall_slong_t jitter;
    int shift;
    ::__syscall_slong_t stabil;
    ::__syscall_slong_t jitcnt;
    ::__syscall_slong_t calcnt;
    ::__syscall_slong_t errcnt;
    ::__syscall_slong_t stbcnt;
    int tai;
    int:32;
    int:32;
    int:32;
    int:32;
    int:32;
    int:32;
    int:32;
    int:32;
    int:32;
    int:32;
    int:32;
};
extern "C"
{
  extern int clock_adjtime(::__clockid_t __clock_id, ::timex *__utx) throw();
}
typedef ::__clock_t clock_t;
struct  tm
{
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
    long int tm_gmtoff;
    const char *tm_zone;
};
typedef ::__clockid_t clockid_t;
typedef ::__timer_t timer_t;
struct  itimerspec
{
    ::timespec it_interval;
    ::timespec it_value;
};
struct sigevent;
extern "C"
{
  extern ::clock_t clock() throw();
}
extern "C"
{
  extern ::time_t time(::time_t *__timer) throw();
}
extern "C"
{
  extern double difftime(::time_t __time1, ::time_t __time0) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::time_t mktime(::tm *__tp) throw();
}
extern "C"
{
  extern ::size_t strftime(char *__restrict __s, ::size_t __maxsize, const char *__restrict __format, const ::tm *__restrict __tp) throw();
}
extern "C"
{
  extern char *strptime(const char *__restrict __s, const char *__restrict __fmt, ::tm *__tp) throw();
}
extern "C"
{
  extern ::size_t strftime_l(char *__restrict __s, ::size_t __maxsize, const char *__restrict __format, const ::tm *__restrict __tp, ::locale_t __loc) throw();
}
extern "C"
{
  extern char *strptime_l(const char *__restrict __s, const char *__restrict __fmt, ::tm *__tp, ::locale_t __loc) throw();
}
extern "C"
{
  extern ::tm *gmtime(const ::time_t *__timer) throw();
}
extern "C"
{
  extern ::tm *localtime(const ::time_t *__timer) throw();
}
extern "C"
{
  extern ::tm *gmtime_r(const ::time_t *__restrict __timer, ::tm *__restrict __tp) throw();
}
extern "C"
{
  extern ::tm *localtime_r(const ::time_t *__restrict __timer, ::tm *__restrict __tp) throw();
}
extern "C"
{
  extern char *asctime(const ::tm *__tp) throw();
}
extern "C"
{
  extern char *ctime(const ::time_t *__timer) throw();
}
extern "C"
{
  extern char *asctime_r(const ::tm *__restrict __tp, char *__restrict __buf) throw();
}
extern "C"
{
  extern char *ctime_r(const ::time_t *__restrict __timer, char *__restrict __buf) throw();
}
extern "C"
{
  extern char *__tzname[2L];
}
extern "C"
{
  extern int __daylight;
}
extern "C"
{
  extern long int __timezone;
}
extern "C"
{
  extern char *tzname[2L];
}
extern "C"
{
  extern void tzset() throw();
}
extern "C"
{
  extern int daylight;
}
extern "C"
{
  extern long int timezone;
}
extern "C"
{
  extern int stime(const ::time_t *__when) throw();
}
extern "C"
{
  extern ::time_t timegm(::tm *__tp) throw();
}
extern "C"
{
  extern ::time_t timelocal(::tm *__tp) throw();
}
extern "C"
{
  extern int dysize(int __year) throw() __attribute__((__const__));
}
extern "C"
{
  extern int nanosleep(const ::timespec *__requested_time, ::timespec *__remaining);
}
extern "C"
{
  extern int clock_getres(::clockid_t __clock_id, ::timespec *__res) throw();
}
extern "C"
{
  extern int clock_gettime(::clockid_t __clock_id, ::timespec *__tp) throw();
}
extern "C"
{
  extern int clock_settime(::clockid_t __clock_id, const ::timespec *__tp) throw();
}
extern "C"
{
  extern int clock_nanosleep(::clockid_t __clock_id, int __flags, const ::timespec *__req, ::timespec *__rem);
}
extern "C"
{
  extern int clock_getcpuclockid(::pid_t __pid, ::clockid_t *__clock_id) throw();
}
extern "C"
{
  extern int timer_create(::clockid_t __clock_id, ::sigevent *__restrict __evp, ::timer_t *__restrict __timerid) throw();
}
extern "C"
{
  extern int timer_delete(::timer_t __timerid) throw();
}
extern "C"
{
  extern int timer_settime(::timer_t __timerid, int __flags, const ::itimerspec *__restrict __value, ::itimerspec *__restrict __ovalue) throw();
}
extern "C"
{
  extern int timer_gettime(::timer_t __timerid, ::itimerspec *__value) throw();
}
extern "C"
{
  extern int timer_getoverrun(::timer_t __timerid) throw();
}
extern "C"
{
  extern int timespec_get(::timespec *__ts, int __base) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int getdate_err;
}
extern "C"
{
  extern ::tm *getdate(const char *__string);
}
extern "C"
{
  extern int getdate_r(const char *__restrict __string, ::tm *__restrict __resbufp);
}
struct  __pthread_rwlock_arch_t
{
    unsigned int __readers;
    unsigned int __writers;
    unsigned int __wrphase_futex;
    unsigned int __writers_futex;
    unsigned int __pad3;
    unsigned int __pad4;
    int __cur_writer;
    int __shared;
    signed char __rwelision;
    unsigned char __pad1[7L];
    unsigned long int __pad2;
    unsigned int __flags;
};
struct __pthread_internal_list;
struct  __pthread_internal_list
{
    ::__pthread_internal_list *__prev;
    ::__pthread_internal_list *__next;
};
typedef ::__pthread_internal_list __pthread_list_t;
struct  __pthread_mutex_s
{
    int __lock;
    unsigned int __count;
    int __owner;
    unsigned int __nusers;
    int __kind;
    short int __spins;
    short int __elision;
    ::__pthread_list_t __list;
};
struct  __pthread_cond_s
{
    union 
    {
        __extension__ unsigned long long int __wseq;
        struct 
        {
            unsigned int __low;
            unsigned int __high;
        } __wseq32;
    };
    union 
    {
        __extension__ unsigned long long int __g1_start;
        struct 
        {
            unsigned int __low;
            unsigned int __high;
        } __g1_start32;
    };
    unsigned int __g_refs[2L];
    unsigned int __g_size[2L];
    unsigned int __g1_orig_size;
    unsigned int __wrefs;
    unsigned int __g_signals[2L];
};
typedef unsigned long int pthread_t;
union  pthread_mutexattr_t
{
    char __size[4L];
    int __align;
};
union  pthread_condattr_t
{
    char __size[4L];
    int __align;
};
typedef unsigned int pthread_key_t;
typedef int pthread_once_t;
union  pthread_attr_t
{
    char __size[56L];
    long int __align;
};
union  pthread_mutex_t
{
    ::__pthread_mutex_s __data;
    char __size[40L];
    long int __align;
};
union  pthread_cond_t
{
    ::__pthread_cond_s __data;
    char __size[48L];
    __extension__ long long int __align;
};
union  pthread_rwlock_t
{
    ::__pthread_rwlock_arch_t __data;
    char __size[56L];
    long int __align;
};
union  pthread_rwlockattr_t
{
    char __size[8L];
    long int __align;
};
typedef volatile int pthread_spinlock_t;
union  pthread_barrier_t
{
    char __size[32L];
    long int __align;
};
union  pthread_barrierattr_t
{
    char __size[4L];
    int __align;
};
typedef long int __jmp_buf[8L];
enum mcc_enum_anon_36
{
  PTHREAD_CREATE_JOINABLE = 0,
  PTHREAD_CREATE_DETACHED = 1
};
enum mcc_enum_anon_37
{
  PTHREAD_MUTEX_TIMED_NP = 0,
  PTHREAD_MUTEX_RECURSIVE_NP = 1,
  PTHREAD_MUTEX_ERRORCHECK_NP = 2,
  PTHREAD_MUTEX_ADAPTIVE_NP = 3,
  PTHREAD_MUTEX_NORMAL = ::PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = ::PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = ::PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = ::PTHREAD_MUTEX_NORMAL,
  PTHREAD_MUTEX_FAST_NP = ::PTHREAD_MUTEX_TIMED_NP
};
enum mcc_enum_anon_38
{
  PTHREAD_MUTEX_STALLED = 0,
  PTHREAD_MUTEX_STALLED_NP = ::PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST = 1,
  PTHREAD_MUTEX_ROBUST_NP = ::PTHREAD_MUTEX_ROBUST
};
enum mcc_enum_anon_39
{
  PTHREAD_PRIO_NONE = 0,
  PTHREAD_PRIO_INHERIT = 1,
  PTHREAD_PRIO_PROTECT = 2
};
enum mcc_enum_anon_40
{
  PTHREAD_RWLOCK_PREFER_READER_NP = 0,
  PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
  PTHREAD_RWLOCK_DEFAULT_NP = ::PTHREAD_RWLOCK_PREFER_READER_NP
};
enum mcc_enum_anon_41
{
  PTHREAD_INHERIT_SCHED = 0,
  PTHREAD_EXPLICIT_SCHED = 1
};
enum mcc_enum_anon_42
{
  PTHREAD_SCOPE_SYSTEM = 0,
  PTHREAD_SCOPE_PROCESS = 1
};
enum mcc_enum_anon_43
{
  PTHREAD_PROCESS_PRIVATE = 0,
  PTHREAD_PROCESS_SHARED = 1
};
struct _pthread_cleanup_buffer;
struct  _pthread_cleanup_buffer
{
    void (*__routine)(void *);
    void *__arg;
    int __canceltype;
    ::_pthread_cleanup_buffer *__prev;
};
enum mcc_enum_anon_44
{
  PTHREAD_CANCEL_ENABLE = 0,
  PTHREAD_CANCEL_DISABLE = 1
};
enum mcc_enum_anon_45
{
  PTHREAD_CANCEL_DEFERRED = 0,
  PTHREAD_CANCEL_ASYNCHRONOUS = 1
};
extern "C"
{
  extern int pthread_create(::pthread_t *__restrict __newthread, const ::pthread_attr_t *__restrict __attr, void *(*__start_routine)(void *), void *__restrict __arg) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern void pthread_exit(void *__retval) __attribute__((__noreturn__));
}
extern "C"
{
  extern int pthread_join(::pthread_t __th, void **__thread_return);
}
extern "C"
{
  extern int pthread_tryjoin_np(::pthread_t __th, void **__thread_return) throw();
}
extern "C"
{
  extern int pthread_timedjoin_np(::pthread_t __th, void **__thread_return, const ::timespec *__abstime);
}
extern "C"
{
  extern int pthread_detach(::pthread_t __th) throw();
}
extern "C"
{
  extern ::pthread_t pthread_self() throw() __attribute__((__const__));
}
extern "C"
{
  extern inline int pthread_equal(::pthread_t __thread1, ::pthread_t __thread2) throw() __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern int pthread_attr_init(::pthread_attr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_destroy(::pthread_attr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getdetachstate(const ::pthread_attr_t *__attr, int *__detachstate) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setdetachstate(::pthread_attr_t *__attr, int __detachstate) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getguardsize(const ::pthread_attr_t *__attr, ::size_t *__guardsize) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setguardsize(::pthread_attr_t *__attr, ::size_t __guardsize) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getschedparam(const ::pthread_attr_t *__restrict __attr, ::sched_param *__restrict __param) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setschedparam(::pthread_attr_t *__restrict __attr, const ::sched_param *__restrict __param) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_getschedpolicy(const ::pthread_attr_t *__restrict __attr, int *__restrict __policy) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setschedpolicy(::pthread_attr_t *__attr, int __policy) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getinheritsched(const ::pthread_attr_t *__restrict __attr, int *__restrict __inherit) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setinheritsched(::pthread_attr_t *__attr, int __inherit) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getscope(const ::pthread_attr_t *__restrict __attr, int *__restrict __scope) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setscope(::pthread_attr_t *__attr, int __scope) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getstackaddr(const ::pthread_attr_t *__restrict __attr, void **__restrict __stackaddr) throw() __attribute__((__nonnull__(1, 2))) __attribute__((__deprecated__));
}
extern "C"
{
  extern int pthread_attr_setstackaddr(::pthread_attr_t *__attr, void *__stackaddr) throw() __attribute__((__nonnull__(1))) __attribute__((__deprecated__));
}
extern "C"
{
  extern int pthread_attr_getstacksize(const ::pthread_attr_t *__restrict __attr, ::size_t *__restrict __stacksize) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setstacksize(::pthread_attr_t *__attr, ::size_t __stacksize) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getstack(const ::pthread_attr_t *__restrict __attr, void **__restrict __stackaddr, ::size_t *__restrict __stacksize) throw() __attribute__((__nonnull__(1, 2, 3)));
}
extern "C"
{
  extern int pthread_attr_setstack(::pthread_attr_t *__attr, void *__stackaddr, ::size_t __stacksize) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_setaffinity_np(::pthread_attr_t *__attr, ::size_t __cpusetsize, const ::cpu_set_t *__cpuset) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern int pthread_attr_getaffinity_np(const ::pthread_attr_t *__attr, ::size_t __cpusetsize, ::cpu_set_t *__cpuset) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern int pthread_getattr_default_np(::pthread_attr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_setattr_default_np(const ::pthread_attr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_getattr_np(::pthread_t __th, ::pthread_attr_t *__attr) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int pthread_setschedparam(::pthread_t __target_thread, int __policy, const ::sched_param *__param) throw() __attribute__((__nonnull__(3)));
}
extern "C"
{
  extern int pthread_getschedparam(::pthread_t __target_thread, int *__restrict __policy, ::sched_param *__restrict __param) throw() __attribute__((__nonnull__(2, 3)));
}
extern "C"
{
  extern int pthread_setschedprio(::pthread_t __target_thread, int __prio) throw();
}
extern "C"
{
  extern int pthread_getname_np(::pthread_t __target_thread, char *__buf, ::size_t __buflen) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int pthread_setname_np(::pthread_t __target_thread, const char *__name) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int pthread_getconcurrency() throw();
}
extern "C"
{
  extern int pthread_setconcurrency(int __level) throw();
}
extern "C"
{
  extern int pthread_yield() throw();
}
extern "C"
{
  extern int pthread_setaffinity_np(::pthread_t __th, ::size_t __cpusetsize, const ::cpu_set_t *__cpuset) throw() __attribute__((__nonnull__(3)));
}
extern "C"
{
  extern int pthread_getaffinity_np(::pthread_t __th, ::size_t __cpusetsize, ::cpu_set_t *__cpuset) throw() __attribute__((__nonnull__(3)));
}
extern "C"
{
  extern int pthread_once(::pthread_once_t *__once_control, void (*__init_routine)()) __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_setcancelstate(int __state, int *__oldstate);
}
extern "C"
{
  extern int pthread_setcanceltype(int __type, int *__oldtype);
}
extern "C"
{
  extern int pthread_cancel(::pthread_t __th);
}
extern "C"
{
  extern void pthread_testcancel();
}
struct __attribute__((__aligned__))  __pthread_unwind_buf_t
{
    struct  mcc_struct_anon_25
    {
        ::__jmp_buf __cancel_jmp_buf;
        int __mask_was_saved;
    };
    ::__pthread_unwind_buf_t::mcc_struct_anon_25 __cancel_jmp_buf[1L];
    void *__pad[4L];
};
struct  __pthread_cleanup_frame
{
    void (*__cancel_routine)(void *);
    void *__cancel_arg;
    int __do_it;
    int __cancel_type;
};
class  __pthread_cleanup_class
{
    void (*__cancel_routine)(void *);
    void *__cancel_arg;
    int __do_it;
    int __cancel_type;
  public:
    inline __pthread_cleanup_class(void (*__fct)(void *), void *__arg)
      : __cancel_routine(__fct), __cancel_arg(__arg), __do_it(1)
    {
    }
    inline ~__pthread_cleanup_class()
    {
      if ((*this).__do_it)
        {
          (*this).__cancel_routine((*this).__cancel_arg);
        }
    }
    inline void __setdoit(int __newval)
    {
      (*this).__do_it = __newval;
    }
    inline void __defer()
    {
      ::pthread_setcanceltype(::PTHREAD_CANCEL_DEFERRED, &(*this).__cancel_type);
    }
    inline void __restore() const 
    {
      ::pthread_setcanceltype((*this).__cancel_type, 0);
    }
};
struct __jmp_buf_tag;
extern "C"
{
  extern int __sigsetjmp(::__jmp_buf_tag *__env, int __savemask) throw();
}
extern "C"
{
  extern int pthread_mutex_init(::pthread_mutex_t *__mutex, const ::pthread_mutexattr_t *__mutexattr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutex_destroy(::pthread_mutex_t *__mutex) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutex_trylock(::pthread_mutex_t *__mutex) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutex_lock(::pthread_mutex_t *__mutex) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutex_timedlock(::pthread_mutex_t *__restrict __mutex, const ::timespec *__restrict __abstime) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutex_unlock(::pthread_mutex_t *__mutex) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutex_getprioceiling(const ::pthread_mutex_t *__restrict __mutex, int *__restrict __prioceiling) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutex_setprioceiling(::pthread_mutex_t *__restrict __mutex, int __prioceiling, int *__restrict __old_ceiling) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern int pthread_mutex_consistent(::pthread_mutex_t *__mutex) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutex_consistent_np(::pthread_mutex_t *__mutex) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_init(::pthread_mutexattr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_destroy(::pthread_mutexattr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_getpshared(const ::pthread_mutexattr_t *__restrict __attr, int *__restrict __pshared) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutexattr_setpshared(::pthread_mutexattr_t *__attr, int __pshared) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_gettype(const ::pthread_mutexattr_t *__restrict __attr, int *__restrict __kind) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutexattr_settype(::pthread_mutexattr_t *__attr, int __kind) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_getprotocol(const ::pthread_mutexattr_t *__restrict __attr, int *__restrict __protocol) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutexattr_setprotocol(::pthread_mutexattr_t *__attr, int __protocol) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_getprioceiling(const ::pthread_mutexattr_t *__restrict __attr, int *__restrict __prioceiling) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutexattr_setprioceiling(::pthread_mutexattr_t *__attr, int __prioceiling) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_getrobust(const ::pthread_mutexattr_t *__attr, int *__robustness) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutexattr_getrobust_np(const ::pthread_mutexattr_t *__attr, int *__robustness) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutexattr_setrobust(::pthread_mutexattr_t *__attr, int __robustness) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_setrobust_np(::pthread_mutexattr_t *__attr, int __robustness) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_init(::pthread_rwlock_t *__restrict __rwlock, const ::pthread_rwlockattr_t *__restrict __attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_destroy(::pthread_rwlock_t *__rwlock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_rdlock(::pthread_rwlock_t *__rwlock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_tryrdlock(::pthread_rwlock_t *__rwlock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_timedrdlock(::pthread_rwlock_t *__restrict __rwlock, const ::timespec *__restrict __abstime) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_rwlock_wrlock(::pthread_rwlock_t *__rwlock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_trywrlock(::pthread_rwlock_t *__rwlock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_timedwrlock(::pthread_rwlock_t *__restrict __rwlock, const ::timespec *__restrict __abstime) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_rwlock_unlock(::pthread_rwlock_t *__rwlock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlockattr_init(::pthread_rwlockattr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlockattr_destroy(::pthread_rwlockattr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlockattr_getpshared(const ::pthread_rwlockattr_t *__restrict __attr, int *__restrict __pshared) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_rwlockattr_setpshared(::pthread_rwlockattr_t *__attr, int __pshared) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlockattr_getkind_np(const ::pthread_rwlockattr_t *__restrict __attr, int *__restrict __pref) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_rwlockattr_setkind_np(::pthread_rwlockattr_t *__attr, int __pref) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_cond_init(::pthread_cond_t *__restrict __cond, const ::pthread_condattr_t *__restrict __cond_attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_cond_destroy(::pthread_cond_t *__cond) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_cond_signal(::pthread_cond_t *__cond) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_cond_broadcast(::pthread_cond_t *__cond) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_cond_wait(::pthread_cond_t *__restrict __cond, ::pthread_mutex_t *__restrict __mutex) __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_cond_timedwait(::pthread_cond_t *__restrict __cond, ::pthread_mutex_t *__restrict __mutex, const ::timespec *__restrict __abstime) __attribute__((__nonnull__(1, 2, 3)));
}
extern "C"
{
  extern int pthread_condattr_init(::pthread_condattr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_condattr_destroy(::pthread_condattr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_condattr_getpshared(const ::pthread_condattr_t *__restrict __attr, int *__restrict __pshared) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_condattr_setpshared(::pthread_condattr_t *__attr, int __pshared) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_condattr_getclock(const ::pthread_condattr_t *__restrict __attr, ::__clockid_t *__restrict __clock_id) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_condattr_setclock(::pthread_condattr_t *__attr, ::__clockid_t __clock_id) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_spin_init(::pthread_spinlock_t *__lock, int __pshared) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_spin_destroy(::pthread_spinlock_t *__lock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_spin_lock(::pthread_spinlock_t *__lock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_spin_trylock(::pthread_spinlock_t *__lock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_spin_unlock(::pthread_spinlock_t *__lock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_barrier_init(::pthread_barrier_t *__restrict __barrier, const ::pthread_barrierattr_t *__restrict __attr, unsigned int __count) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_barrier_destroy(::pthread_barrier_t *__barrier) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_barrier_wait(::pthread_barrier_t *__barrier) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_barrierattr_init(::pthread_barrierattr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_barrierattr_destroy(::pthread_barrierattr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_barrierattr_getpshared(const ::pthread_barrierattr_t *__restrict __attr, int *__restrict __pshared) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_barrierattr_setpshared(::pthread_barrierattr_t *__attr, int __pshared) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_key_create(::pthread_key_t *__key, void (*__destr_function)(void *)) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_key_delete(::pthread_key_t __key) throw();
}
extern "C"
{
  extern void *pthread_getspecific(::pthread_key_t __key) throw();
}
extern "C"
{
  extern int pthread_setspecific(::pthread_key_t __key, const void *__pointer) throw();
}
extern "C"
{
  extern int pthread_getcpuclockid(::pthread_t __thread_id, ::__clockid_t *__clock_id) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int pthread_atfork(void (*__prepare)(), void (*__parent)(), void (*__child)()) throw();
}
extern "C"
{
  extern inline __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) int pthread_equal(::pthread_t __thread1, ::pthread_t __thread2) throw()
  {
    return __thread1 == __thread2;
  }
}
typedef ::pthread_t __gthread_t;
typedef ::pthread_key_t __gthread_key_t;
typedef ::pthread_once_t __gthread_once_t;
typedef ::pthread_mutex_t __gthread_mutex_t;
typedef ::pthread_mutex_t __gthread_recursive_mutex_t;
typedef ::pthread_cond_t __gthread_cond_t;
typedef ::timespec __gthread_time_t;
static int __gthrw_pthread_once(::pthread_once_t *, void (*)()) throw() __attribute__((__weakref__("pthread_once")));
static void *__gthrw_pthread_getspecific(::pthread_key_t) throw() __attribute__((__weakref__("pthread_getspecific")));
static int __gthrw_pthread_setspecific(::pthread_key_t, const void *) throw() __attribute__((__weakref__("pthread_setspecific")));
static int __gthrw_pthread_create(::pthread_t *__restrict , const ::pthread_attr_t *__restrict , void *(*)(void *), void *__restrict ) throw() __attribute__((__weakref__("pthread_create")));
static int __gthrw_pthread_join(::pthread_t, void **) throw() __attribute__((__weakref__("pthread_join")));
static int __gthrw_pthread_equal(::pthread_t, ::pthread_t) throw() __attribute__((__weakref__("pthread_equal")));
static ::pthread_t __gthrw_pthread_self() throw() __attribute__((__weakref__("pthread_self")));
static int __gthrw_pthread_detach(::pthread_t) throw() __attribute__((__weakref__("pthread_detach")));
static int __gthrw_pthread_cancel(::pthread_t) throw() __attribute__((__weakref__("pthread_cancel")));
static int __gthrw_sched_yield() throw() __attribute__((__weakref__("sched_yield")));
static int __gthrw_pthread_mutex_lock(::pthread_mutex_t *) throw() __attribute__((__weakref__("pthread_mutex_lock")));
static int __gthrw_pthread_mutex_trylock(::pthread_mutex_t *) throw() __attribute__((__weakref__("pthread_mutex_trylock")));
static int __gthrw_pthread_mutex_timedlock(::pthread_mutex_t *__restrict , const ::timespec *__restrict ) throw() __attribute__((__weakref__("pthread_mutex_timedlock")));
static int __gthrw_pthread_mutex_unlock(::pthread_mutex_t *) throw() __attribute__((__weakref__("pthread_mutex_unlock")));
static int __gthrw_pthread_mutex_init(::pthread_mutex_t *, const ::pthread_mutexattr_t *) throw() __attribute__((__weakref__("pthread_mutex_init")));
static int __gthrw_pthread_mutex_destroy(::pthread_mutex_t *) throw() __attribute__((__weakref__("pthread_mutex_destroy")));
static int __gthrw_pthread_cond_init(::pthread_cond_t *__restrict , const ::pthread_condattr_t *__restrict ) throw() __attribute__((__weakref__("pthread_cond_init")));
static int __gthrw_pthread_cond_broadcast(::pthread_cond_t *) throw() __attribute__((__weakref__("pthread_cond_broadcast")));
static int __gthrw_pthread_cond_signal(::pthread_cond_t *) throw() __attribute__((__weakref__("pthread_cond_signal")));
static int __gthrw_pthread_cond_wait(::pthread_cond_t *__restrict , ::pthread_mutex_t *__restrict ) throw() __attribute__((__weakref__("pthread_cond_wait")));
static int __gthrw_pthread_cond_timedwait(::pthread_cond_t *__restrict , ::pthread_mutex_t *__restrict , const ::timespec *__restrict ) throw() __attribute__((__weakref__("pthread_cond_timedwait")));
static int __gthrw_pthread_cond_destroy(::pthread_cond_t *) throw() __attribute__((__weakref__("pthread_cond_destroy")));
static int __gthrw_pthread_key_create(::pthread_key_t *, void (*)(void *)) throw() __attribute__((__weakref__("pthread_key_create")));
static int __gthrw_pthread_key_delete(::pthread_key_t) throw() __attribute__((__weakref__("pthread_key_delete")));
static int __gthrw_pthread_mutexattr_init(::pthread_mutexattr_t *) throw() __attribute__((__weakref__("pthread_mutexattr_init")));
static int __gthrw_pthread_mutexattr_settype(::pthread_mutexattr_t *, int) throw() __attribute__((__weakref__("pthread_mutexattr_settype")));
static int __gthrw_pthread_mutexattr_destroy(::pthread_mutexattr_t *) throw() __attribute__((__weakref__("pthread_mutexattr_destroy")));
static int __gthrw___pthread_key_create(::pthread_key_t *, void (*)(void *)) throw() __attribute__((__weakref__("__pthread_key_create")));
static inline int __gthread_active_p()
{
  static void *const __gthread_active_ptr((void *)::__gthrw___pthread_key_create);
  return __gthread_active_ptr != 0;
}
static inline int __gthread_create(::__gthread_t *__threadid, void *(*__func)(void *), void *__args)
{
  return ::__gthrw_pthread_create(__threadid, 0L, __func, __args);
}
static inline int __gthread_join(::__gthread_t __threadid, void **__value_ptr)
{
  return ::__gthrw_pthread_join(__threadid, __value_ptr);
}
static inline int __gthread_detach(::__gthread_t __threadid)
{
  return ::__gthrw_pthread_detach(__threadid);
}
static inline int __gthread_equal(::__gthread_t __t1, ::__gthread_t __t2)
{
  return ::__gthrw_pthread_equal(__t1, __t2);
}
static inline ::__gthread_t __gthread_self()
{
  return ::__gthrw_pthread_self();
}
static inline int __gthread_yield()
{
  return ::__gthrw_sched_yield();
}
static inline int __gthread_once(::__gthread_once_t *__once, void (*__func)())
{
  if (::__gthread_active_p())
    {
      return ::__gthrw_pthread_once(__once, __func);
    }
  else
    {
      return  -1;
    }
}
static inline int __gthread_key_create(::__gthread_key_t *__key, void (*__dtor)(void *))
{
  return ::__gthrw_pthread_key_create(__key, __dtor);
}
static inline int __gthread_key_delete(::__gthread_key_t __key)
{
  return ::__gthrw_pthread_key_delete(__key);
}
static inline void *__gthread_getspecific(::__gthread_key_t __key)
{
  return ::__gthrw_pthread_getspecific(__key);
}
static inline int __gthread_setspecific(::__gthread_key_t __key, const void *__ptr)
{
  return ::__gthrw_pthread_setspecific(__key, __ptr);
}
static inline void __gthread_mutex_init_function(::__gthread_mutex_t *__mutex)
{
  if (::__gthread_active_p())
    {
      ::__gthrw_pthread_mutex_init(__mutex, 0L);
    }
}
static inline int __gthread_mutex_destroy(::__gthread_mutex_t *__mutex)
{
  if (::__gthread_active_p())
    {
      return ::__gthrw_pthread_mutex_destroy(__mutex);
    }
  else
    {
      return 0;
    }
}
static inline int __gthread_mutex_lock(::__gthread_mutex_t *__mutex)
{
  if (::__gthread_active_p())
    {
      return ::__gthrw_pthread_mutex_lock(__mutex);
    }
  else
    {
      return 0;
    }
}
static inline int __gthread_mutex_trylock(::__gthread_mutex_t *__mutex)
{
  if (::__gthread_active_p())
    {
      return ::__gthrw_pthread_mutex_trylock(__mutex);
    }
  else
    {
      return 0;
    }
}
static inline int __gthread_mutex_timedlock(::__gthread_mutex_t *__mutex, const ::__gthread_time_t *__abs_timeout)
{
  if (::__gthread_active_p())
    {
      return ::__gthrw_pthread_mutex_timedlock(__mutex, __abs_timeout);
    }
  else
    {
      return 0;
    }
}
static inline int __gthread_mutex_unlock(::__gthread_mutex_t *__mutex)
{
  if (::__gthread_active_p())
    {
      return ::__gthrw_pthread_mutex_unlock(__mutex);
    }
  else
    {
      return 0;
    }
}
static inline int __gthread_recursive_mutex_lock(::__gthread_recursive_mutex_t *__mutex)
{
  return ::__gthread_mutex_lock(__mutex);
}
static inline int __gthread_recursive_mutex_trylock(::__gthread_recursive_mutex_t *__mutex)
{
  return ::__gthread_mutex_trylock(__mutex);
}
static inline int __gthread_recursive_mutex_timedlock(::__gthread_recursive_mutex_t *__mutex, const ::__gthread_time_t *__abs_timeout)
{
  return ::__gthread_mutex_timedlock(__mutex, __abs_timeout);
}
static inline int __gthread_recursive_mutex_unlock(::__gthread_recursive_mutex_t *__mutex)
{
  return ::__gthread_mutex_unlock(__mutex);
}
static inline int __gthread_recursive_mutex_destroy(::__gthread_recursive_mutex_t *__mutex)
{
  return ::__gthread_mutex_destroy(__mutex);
}
static inline int __gthread_cond_broadcast(::__gthread_cond_t *__cond)
{
  return ::__gthrw_pthread_cond_broadcast(__cond);
}
static inline int __gthread_cond_signal(::__gthread_cond_t *__cond)
{
  return ::__gthrw_pthread_cond_signal(__cond);
}
static inline int __gthread_cond_wait(::__gthread_cond_t *__cond, ::__gthread_mutex_t *__mutex)
{
  return ::__gthrw_pthread_cond_wait(__cond, __mutex);
}
static inline int __gthread_cond_timedwait(::__gthread_cond_t *__cond, ::__gthread_mutex_t *__mutex, const ::__gthread_time_t *__abs_timeout)
{
  return ::__gthrw_pthread_cond_timedwait(__cond, __mutex, __abs_timeout);
}
static inline int __gthread_cond_wait_recursive(::__gthread_cond_t *__cond, ::__gthread_recursive_mutex_t *__mutex)
{
  return ::__gthread_cond_wait(__cond, __mutex);
}
static inline int __gthread_cond_destroy(::__gthread_cond_t *__cond)
{
  return ::__gthrw_pthread_cond_destroy(__cond);
}
#pragma GCC visibility pop
typedef int _Atomic_word;
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  static inline ::_Atomic_word __exchange_and_add(volatile ::_Atomic_word *__mem, int __val)
  {
    return __atomic_fetch_add(__mem, __val, 4);
  }
  static inline void __atomic_add(volatile ::_Atomic_word *__mem, int __val)
  {
    __atomic_fetch_add(__mem, __val, 4);
  }
  static inline ::_Atomic_word __exchange_and_add_single(::_Atomic_word *__mem, int __val)
  {
    ::_Atomic_word __result(*__mem);
    *__mem += __val;
    return __result;
  }
  static inline void __atomic_add_single(::_Atomic_word *__mem, int __val)
  {
    *__mem += __val;
  }
  static inline __attribute__((__unused__)) ::_Atomic_word __exchange_and_add_dispatch(::_Atomic_word *__mem, int __val)
  {
    if (::__gthread_active_p())
      {
        return ::__gnu_cxx::__exchange_and_add(__mem, __val);
      }
    else
      {
        return ::__gnu_cxx::__exchange_and_add_single(__mem, __val);
      }
  }
  static inline __attribute__((__unused__)) void __atomic_add_dispatch(::_Atomic_word *__mem, int __val)
  {
    if (::__gthread_active_p())
      {
        ::__gnu_cxx::__atomic_add(__mem, __val);
      }
    else
      {
        ::__gnu_cxx::__atomic_add_single(__mem, __val);
      }
  }
  template < typename _Alloc >
  struct  __alloc_traits
  {
      typedef _Alloc allocator_type;
      typedef typename _Alloc::pointer pointer;
      typedef typename _Alloc::const_pointer const_pointer;
      typedef typename _Alloc::value_type value_type;
      typedef typename _Alloc::reference reference;
      typedef typename _Alloc::const_reference const_reference;
      typedef typename _Alloc::size_type size_type;
      typedef typename _Alloc::difference_type difference_type;
      static inline typename ::__gnu_cxx::__alloc_traits<_Alloc>::pointer allocate(_Alloc &__a, typename ::__gnu_cxx::__alloc_traits<_Alloc>::size_type __n)
      {
        return __a.allocate(__n);
      }
      static inline void deallocate(_Alloc &__a, typename ::__gnu_cxx::__alloc_traits<_Alloc>::pointer __p, typename ::__gnu_cxx::__alloc_traits<_Alloc>::size_type __n)
      {
        __a.deallocate(__p, __n);
      }
      template < typename _Tp >
      static inline void construct(_Alloc &__a, typename ::__gnu_cxx::__alloc_traits<_Alloc>::pointer __p, const _Tp &__arg)
      {
        __a.construct(__p, __arg);
      }
      static inline void destroy(_Alloc &__a, typename ::__gnu_cxx::__alloc_traits<_Alloc>::pointer __p)
      {
        __a.destroy(__p);
      }
      static inline typename ::__gnu_cxx::__alloc_traits<_Alloc>::size_type max_size(const _Alloc &__a)
      {
        return __a.max_size();
      }
      static inline const _Alloc &_S_select_on_copy(const _Alloc &__a)
      {
        return __a;
      }
      static inline void _S_on_swap(_Alloc &__a, _Alloc &__b)
      {
        std::__alloc_swap<_Alloc>::_S_do_it(__a, __b);
      }
      template < typename _Tp >
      struct  rebind
      {
          typedef typename _Alloc::template rebind< _Tp>::other other;
      };
  };
 /* Instantiation of class template '::__gnu_cxx::__conditional_type<true, ::__gnu_cxx::__numeric_traits_integer<int>, ::__gnu_cxx::__numeric_traits_floating<int> >' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits_integer<int>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits<int>' */ 
}
namespace std __attribute__((__visibility__("default"))) {
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    template < typename _CharT, typename _Traits, typename _Alloc >
    class  basic_string
    {
        typedef typename ::__gnu_cxx::__alloc_traits<_Alloc>::template rebind< _CharT>::other _Char_alloc_type;
        typedef ::__gnu_cxx::__alloc_traits<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Char_alloc_type> _Alloc_traits;
      public:
        typedef _Traits traits_type;
        typedef typename _Traits::char_type value_type;
        typedef typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Char_alloc_type allocator_type;
        typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Char_alloc_type>::size_type size_type;
        typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Char_alloc_type>::difference_type difference_type;
        typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Char_alloc_type>::reference reference;
        typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Char_alloc_type>::const_reference const_reference;
        typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Char_alloc_type>::pointer pointer;
        typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Char_alloc_type>::const_pointer const_pointer;
        typedef ::__gnu_cxx::__normal_iterator<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> > iterator;
        typedef ::__gnu_cxx::__normal_iterator<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_pointer, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> > const_iterator;
        typedef ::std::reverse_iterator<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator> const_reverse_iterator;
        typedef ::std::reverse_iterator<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator> reverse_iterator;
        static const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type npos = static_cast<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type>( -1);
      private:
        typedef typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator __const_iterator;
        struct  _Alloc_hider : ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type
        {
            inline _Alloc_hider(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer __dat, const _Alloc &__a  = (_Alloc()))
              : allocator_type(__a), _M_p(__dat)
            {
            }
            typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer _M_p;
        };
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Alloc_hider _M_dataplus;
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type _M_string_length;
        enum mcc_enum_anon_46
        {
          _S_local_capacity = 15 / sizeof(_CharT)
        };
        union 
        {
            _CharT _M_local_buf[::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity + 1];
            typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type _M_allocated_capacity;
        };
        inline void _M_data(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer __p)
        {
          ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_dataplus._M_p = __p;
        }
        inline void _M_length(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __length)
        {
          ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_string_length = __length;
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer _M_data() const 
        {
          return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_dataplus._M_p;
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer _M_local_data()
        {
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_buf)));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_pointer _M_local_data() const 
        {
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_pointer(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_buf)));
        }
        inline void _M_capacity(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __capacity)
        {
          ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_allocated_capacity = __capacity;
        }
        inline void _M_set_length(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
        {
          (*this)._M_length(__n);
          traits_type::assign((*this)._M_data()[__n], _CharT());
        }
        inline bool _M_is_local() const 
        {
          return (*this)._M_data() == (*this)._M_local_data();
        }
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer _M_create(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type &__capacity, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __old_capacity);
        inline void _M_dispose()
        {
          if (!(*this)._M_is_local())
            {
              (*this)._M_destroy(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_allocated_capacity);
            }
        }
        inline void _M_destroy(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size) throw()
        {
          _Alloc_traits::deallocate((*this)._M_get_allocator(), (*this)._M_data(), __size + 1);
        }
        template < typename _InIterator >
        inline void _M_construct_aux(_InIterator __beg, _InIterator __end, ::std::__false_type)
        {
          typedef typename ::std::iterator_traits<_InIterator>::iterator_category _Tag;
          (*this)._M_construct(__beg, __end, _Tag());
        }
        template < typename _Integer >
        inline void _M_construct_aux(_Integer __beg, _Integer __end, ::std::__true_type)
        {
          (*this)._M_construct_aux_2(static_cast<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type>(__beg), __end);
        }
        inline void _M_construct_aux_2(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __req, _CharT __c)
        {
          (*this)._M_construct(__req, __c);
        }
        template < typename _InIterator >
        inline void _M_construct(_InIterator __beg, _InIterator __end)
        {
          typedef typename ::std::__is_integer<_InIterator>::__type _Integral;
          (*this)._M_construct_aux(__beg, __end, _Integral());
        }
        template < typename _InIterator >
        void _M_construct(_InIterator __beg, _InIterator __end, ::std::input_iterator_tag);
        template < typename _FwdIterator >
        void _M_construct(_FwdIterator __beg, _FwdIterator __end, ::std::forward_iterator_tag);
        void _M_construct(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c);
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type &_M_get_allocator()
        {
          return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_dataplus;
        }
        inline const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type &_M_get_allocator() const 
        {
          return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_dataplus;
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type _M_check(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, const char *__s) const 
        {
          if (__pos > this->size())
            {
              __throw_out_of_range_fmt("%s: __pos (which is %zu) > this->size() (which is %zu)", __s, __pos, this->size());
            }
          return __pos;
        }
        inline void _M_check_length(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n2, const char *__s) const 
        {
          if (this->max_size() - (this->size() - __n1) < __n2)
            {
              ::std::__throw_length_error(__s);
            }
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type _M_limit(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __off) const 
        {
          const bool __testoff = __off < this->size() - __pos;
          return __testoff ? __off : this->size() - __pos;
        }
        inline bool _M_disjunct(const _CharT *__s) const 
        {
          return ::std::less<const _CharT *>()(__s, (*this)._M_data()) || ::std::less<const _CharT *>()((*this)._M_data() + this->size(), __s);
        }
        static inline void _S_copy(_CharT *__d, const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
        {
          if (__n == 1)
            {
              traits_type::assign(*__d, *__s);
            }
          else
            {
              traits_type::copy(__d, __s, __n);
            }
        }
        static inline void _S_move(_CharT *__d, const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
        {
          if (__n == 1)
            {
              traits_type::assign(*__d, *__s);
            }
          else
            {
              traits_type::move(__d, __s, __n);
            }
        }
        static inline void _S_assign(_CharT *__d, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
        {
          if (__n == 1)
            {
              traits_type::assign(*__d, __c);
            }
          else
            {
              traits_type::assign(__d, __n, __c);
            }
        }
        template < typename _Iterator >
        static inline void _S_copy_chars(_CharT *__p, _Iterator __k1, _Iterator __k2)
        {
          for (; __k1 != __k2; ( ++__k1, (void) ++__p))
            {
              traits_type::assign(*__p, *__k1);
            }
        }
        static inline void _S_copy_chars(_CharT *__p, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator __k1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator __k2)
        {
          _S_copy_chars(__p, __k1.base(), __k2.base());
        }
        static inline void _S_copy_chars(_CharT *__p, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __k1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __k2)
        {
          _S_copy_chars(__p, __k1.base(), __k2.base());
        }
        static inline void _S_copy_chars(_CharT *__p, _CharT *__k1, _CharT *__k2)
        {
          _S_copy(__p, __k1, __k2 - __k1);
        }
        static inline void _S_copy_chars(_CharT *__p, const _CharT *__k1, const _CharT *__k2)
        {
          _S_copy(__p, __k1, __k2 - __k1);
        }
        static inline int _S_compare(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n2)
        {
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::difference_type __d = ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::difference_type(__n1 - __n2)));
          if (__d > ::__gnu_cxx::__numeric_traits_integer<int>::__max)
            {
              return ::__gnu_cxx::__numeric_traits_integer<int>::__max;
            }
          else
            {
              if (__d < ::__gnu_cxx::__numeric_traits_integer<int>::__min)
                {
                  return ::__gnu_cxx::__numeric_traits_integer<int>::__min;
                }
              else
                {
                  return int(__d);
                }
            }
        }
        void _M_assign(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str);
        void _M_mutate(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len1, const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len2);
        void _M_erase(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n);
      public:
        inline basic_string()
          : _M_dataplus((*this)._M_local_data())
        {
          (*this)._M_set_length(0);
        }
        inline explicit basic_string(const _Alloc &__a)
          : _M_dataplus((*this)._M_local_data(), __a)
        {
          (*this)._M_set_length(0);
        }
        inline basic_string(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
          : _M_dataplus((*this)._M_local_data(), _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))
        {
          (*this)._M_construct(__str._M_data(), __str._M_data() + __str.length());
        }
        inline basic_string(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, const _Alloc &__a  = (_Alloc()))
          : _M_dataplus((*this)._M_local_data(), __a)
        {
          const _CharT *__start = __str._M_data() + __str._M_check(__pos, "basic_string::basic_string");
          (*this)._M_construct(__start, __start + __str._M_limit(__pos, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos));
        }
        inline basic_string(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
          : _M_dataplus((*this)._M_local_data())
        {
          const _CharT *__start = __str._M_data() + __str._M_check(__pos, "basic_string::basic_string");
          (*this)._M_construct(__start, __start + __str._M_limit(__pos, __n));
        }
        inline basic_string(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, const _Alloc &__a)
          : _M_dataplus((*this)._M_local_data(), __a)
        {
          const _CharT *__start = __str._M_data() + __str._M_check(__pos, "string::string");
          (*this)._M_construct(__start, __start + __str._M_limit(__pos, __n));
        }
        inline basic_string(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, const _Alloc &__a  = (_Alloc()))
          : _M_dataplus((*this)._M_local_data(), __a)
        {
          (*this)._M_construct(__s, __s + __n);
        }
        inline basic_string(const _CharT *__s, const _Alloc &__a  = (_Alloc()))
          : _M_dataplus((*this)._M_local_data(), __a)
        {
          (*this)._M_construct(__s, __s ? __s + traits_type::length(__s) : __s + ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos);
        }
        inline basic_string(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c, const _Alloc &__a  = (_Alloc()))
          : _M_dataplus((*this)._M_local_data(), __a)
        {
          (*this)._M_construct(__n, __c);
        }
        template < typename _InputIterator >
        inline basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc &__a  = (_Alloc()))
          : _M_dataplus((*this)._M_local_data(), __a)
        {
          (*this)._M_construct(__beg, __end);
        }
        inline ~basic_string()
        {
          (*this)._M_dispose();
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &operator =(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
        {
          return this->assign(__str);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &operator =(const _CharT *__s)
        {
          return this->assign(__s);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &operator =(_CharT __c)
        {
          this->assign(1, __c);
          return *this;
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator begin()
        {
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator((*this)._M_data())));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator begin() const 
        {
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator((*this)._M_data())));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator end()
        {
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator((*this)._M_data() + this->size())));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator end() const 
        {
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator((*this)._M_data() + this->size())));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::reverse_iterator rbegin()
        {
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::reverse_iterator(this->end())));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reverse_iterator rbegin() const 
        {
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reverse_iterator(this->end())));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::reverse_iterator rend()
        {
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::reverse_iterator(this->begin())));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reverse_iterator rend() const 
        {
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reverse_iterator(this->begin())));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type size() const 
        {
          return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_string_length;
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type length() const 
        {
          return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_string_length;
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type max_size() const 
        {
          return (_Alloc_traits::max_size((*this)._M_get_allocator()) - 1) / 2;
        }
        void resize(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c);
        inline void resize(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
        {
          this->resize(__n, _CharT());
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type capacity() const 
        {
          return (*this)._M_is_local() ? ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity))) : ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_allocated_capacity;
        }
        void reserve(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __res  = (0));
        inline void clear()
        {
          (*this)._M_set_length(0);
        }
        inline bool empty() const 
        {
          return this->size() == 0;
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reference operator [](typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos) const 
        {
          ;
          return (*this)._M_data()[__pos];
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::reference operator [](typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos)
        {
          ;
          ;
          return (*this)._M_data()[__pos];
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reference at(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
        {
          if (__n >= this->size())
            {
              __throw_out_of_range_fmt("basic_string::at: __n (which is %zu) >= this->size() (which is %zu)", __n, this->size());
            }
          return (*this)._M_data()[__n];
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::reference at(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
        {
          if (__n >= (*this).size())
            {
              __throw_out_of_range_fmt("basic_string::at: __n (which is %zu) >= this->size() (which is %zu)", __n, this->size());
            }
          return (*this)._M_data()[__n];
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &operator +=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
        {
          return this->append(__str);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &operator +=(const _CharT *__s)
        {
          return this->append(__s);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &operator +=(_CharT __c)
        {
          this->push_back(__c);
          return *this;
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &append(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
        {
          return (*this)._M_append(__str._M_data(), __str.size());
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &append(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos))
        {
          return (*this)._M_append(__str._M_data() + __str._M_check(__pos, "basic_string::append"), __str._M_limit(__pos, __n));
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &append(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
        {
          ;
          (*this)._M_check_length(((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __n, "basic_string::append");
          return (*this)._M_append(__s, __n);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &append(const _CharT *__s)
        {
          ;
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n = traits_type::length(__s);
          (*this)._M_check_length(((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __n, "basic_string::append");
          return (*this)._M_append(__s, __n);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &append(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
        {
          return (*this)._M_replace_aux(this->size(), ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __n, __c);
        }
        template < typename _InputIterator >
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &append(_InputIterator __first, _InputIterator __last)
        {
          return this->replace((*this).end(), (*this).end(), __first, __last);
        }
        inline void push_back(_CharT __c)
        {
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
          if (__size + 1 > this->capacity())
            {
              this->_M_mutate(__size, ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), 0, ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(1))));
            }
          traits_type::assign(this->_M_data()[__size], __c);
          this->_M_set_length(__size + 1);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &assign(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
        {
          this->_M_assign(__str);
          return *this;
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &assign(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos))
        {
          return (*this)._M_replace(((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), this->size(), __str._M_data() + __str._M_check(__pos, "basic_string::assign"), __str._M_limit(__pos, __n));
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &assign(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
        {
          ;
          return (*this)._M_replace(((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), this->size(), __s, __n);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &assign(const _CharT *__s)
        {
          ;
          return (*this)._M_replace(((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), this->size(), __s, traits_type::length(__s));
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &assign(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
        {
          return (*this)._M_replace_aux(((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), this->size(), __n, __c);
        }
        template < typename _InputIterator >
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &assign(_InputIterator __first, _InputIterator __last)
        {
          return this->replace((*this).begin(), (*this).end(), __first, __last);
        }
        inline void insert(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator __p, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
        {
          this->replace(__p, __p, __n, __c);
        }
        template < typename _InputIterator >
        inline void insert(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator __p, _InputIterator __beg, _InputIterator __end)
        {
          this->replace(__p, __p, __beg, __end);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &insert(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
        {
          return this->replace(__pos1, ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __str._M_data(), __str.size());
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &insert(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos2, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos))
        {
          return this->replace(__pos1, ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __str._M_data() + __str._M_check(__pos2, "basic_string::insert"), __str._M_limit(__pos2, __n));
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &insert(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
        {
          return this->replace(__pos, ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __s, __n);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &insert(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, const _CharT *__s)
        {
          ;
          return this->replace(__pos, ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __s, traits_type::length(__s));
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &insert(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
        {
          return (*this)._M_replace_aux((*this)._M_check(__pos, "basic_string::insert"), ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __n, __c);
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator insert(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __p, _CharT __c)
        {
          ;
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos = __p - (*this).begin();
          (*this)._M_replace_aux(__pos, ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(1))), __c);
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator((*this)._M_data() + __pos)));
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &erase(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0), typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos))
        {
          (*this)._M_check(__pos, "basic_string::erase");
          if (__n == ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos)
            {
              this->_M_set_length(__pos);
            }
          else
            {
              if (__n != 0)
                {
                  this->_M_erase(__pos, (*this)._M_limit(__pos, __n));
                }
            }
          return *this;
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator erase(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __position)
        {
          ;
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos = __position - (*this).begin();
          this->_M_erase(__pos, ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(1))));
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator((*this)._M_data() + __pos)));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator erase(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __first, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __last)
        {
          ;
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos = __first - (*this).begin();
          if (__last == (*this).end())
            {
              this->_M_set_length(__pos);
            }
          else
            {
              this->_M_erase(__pos, __last - __first);
            }
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator(this->_M_data() + __pos)));
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
        {
          return this->replace(__pos, __n, __str._M_data(), __str.size());
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos2, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n2  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos))
        {
          return this->replace(__pos1, __n1, __str._M_data() + __str._M_check(__pos2, "basic_string::replace"), __str._M_limit(__pos2, __n2));
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n2)
        {
          ;
          return (*this)._M_replace((*this)._M_check(__pos, "basic_string::replace"), (*this)._M_limit(__pos, __n1), __s, __n2);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s)
        {
          ;
          return this->replace(__pos, __n1, __s, traits_type::length(__s));
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n2, _CharT __c)
        {
          return (*this)._M_replace_aux((*this)._M_check(__pos, "basic_string::replace"), (*this)._M_limit(__pos, __n1), __n2, __c);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i2, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
        {
          return this->replace(__i1, __i2, __str._M_data(), __str.size());
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i2, const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
        {
          ;
          return this->replace(__i1 - (*this).begin(), __i2 - __i1, __s, __n);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i2, const _CharT *__s)
        {
          ;
          return this->replace(__i1, __i2, __s, traits_type::length(__s));
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i2, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
        {
          ;
          return (*this)._M_replace_aux(__i1 - (*this).begin(), __i2 - __i1, __n, __c);
        }
        template < typename _InputIterator >
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, _InputIterator __k1, _InputIterator __k2)
        {
          ;
          ;
          typedef typename ::std::__is_integer<_InputIterator>::__type _Integral;
          return (*this)._M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i2, _CharT *__k1, _CharT *__k2)
        {
          ;
          ;
          return this->replace(__i1 - (*this).begin(), __i2 - __i1, __k1, __k2 - __k1);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i2, const _CharT *__k1, const _CharT *__k2)
        {
          ;
          ;
          return this->replace(__i1 - (*this).begin(), __i2 - __i1, __k1, __k2 - __k1);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i2, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator __k1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator __k2)
        {
          ;
          ;
          return this->replace(__i1 - (*this).begin(), __i2 - __i1, __k1.base(), __k2 - __k1);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i2, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __k1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __k2)
        {
          ;
          ;
          return this->replace(__i1 - (*this).begin(), __i2 - __i1, __k1.base(), __k2 - __k1);
        }
      private:
        template < typename _Integer >
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &_M_replace_dispatch(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __i1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __i2, _Integer __n, _Integer __val, ::std::__true_type)
        {
          return (*this)._M_replace_aux(__i1 - (*this).begin(), __i2 - __i1, __n, __val);
        }
        template < typename _InputIterator >
        ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &_M_replace_dispatch(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __i1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, ::std::__false_type);
        ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &_M_replace_aux(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n2, _CharT __c);
        ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &_M_replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len1, const _CharT *__s, const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len2);
        ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &_M_append(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n);
      public:
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type copy(_CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const ;
        void swap(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__s);
        inline const _CharT *c_str() const 
        {
          return (*this)._M_data();
        }
        inline const _CharT *data() const 
        {
          return (*this)._M_data();
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type get_allocator() const 
        {
          return (*this)._M_get_allocator();
        }
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const ;
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const 
        {
          return this->find(__str.data(), __pos, __str.size());
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const 
        {
          ;
          return this->find(__s, __pos, traits_type::length(__s));
        }
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find(_CharT __c, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const ;
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type rfind(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos)) const 
        {
          return this->rfind(__str.data(), __pos, __str.size());
        }
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type rfind(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const ;
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type rfind(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos)) const 
        {
          ;
          return this->rfind(__s, __pos, traits_type::length(__s));
        }
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type rfind(_CharT __c, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos)) const ;
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_of(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const 
        {
          return this->find_first_of(__str.data(), __pos, __str.size());
        }
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_of(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const ;
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_of(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const 
        {
          ;
          return this->find_first_of(__s, __pos, traits_type::length(__s));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_of(_CharT __c, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const 
        {
          return this->find(__c, __pos);
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_of(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos)) const 
        {
          return this->find_last_of(__str.data(), __pos, __str.size());
        }
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_of(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const ;
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_of(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos)) const 
        {
          ;
          return this->find_last_of(__s, __pos, traits_type::length(__s));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_of(_CharT __c, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos)) const 
        {
          return this->rfind(__c, __pos);
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_not_of(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const 
        {
          return this->find_first_not_of(__str.data(), __pos, __str.size());
        }
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_not_of(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const ;
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_not_of(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const 
        {
          ;
          return this->find_first_not_of(__s, __pos, traits_type::length(__s));
        }
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_not_of(_CharT __c, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const ;
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_not_of(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos)) const 
        {
          return this->find_last_not_of(__str.data(), __pos, __str.size());
        }
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_not_of(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const ;
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_not_of(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos)) const 
        {
          ;
          return this->find_last_not_of(__s, __pos, traits_type::length(__s));
        }
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_not_of(_CharT __c, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos)) const ;
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> substr(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0), typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos)) const 
        {
          return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>(*this, (*this)._M_check(__pos, "basic_string::substr"), __n);
        }
        inline int compare(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str) const 
        {
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __osize = __str.size();
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len = std::min(__size, __osize);
          int __r = traits_type::compare((*this)._M_data(), __str.data(), __len);
          if (!__r)
            {
              __r = _S_compare(__size, __osize);
            }
          return __r;
        }
        int compare(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str) const ;
        int compare(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos2, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n2  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos)) const ;
        int compare(const _CharT *__s) const ;
        int compare(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s) const ;
        int compare(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n2) const ;
      template < typename __type_tpl__param_2_0__, typename __type_tpl__param_2_1__, typename __type_tpl__param_2_2__ >
      friend class basic_stringbuf;
    };
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
    __str.append(__rhs);
    return __str;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(_CharT __lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
    __str.append(__rhs);
    return __str;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, _CharT __rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, _CharT __rhs)
  {
    typedef ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> __string_type;
    typedef typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size_type;
    __string_type __str(__lhs);
    __str.append(__size_type(1), __rhs);
    return __str;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator ==(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator ==(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __lhs.compare(__rhs) == 0;
  }
  template < typename _CharT >
  inline typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type operator ==(const ::std::__cxx11::basic_string<_CharT> &__lhs, const ::std::__cxx11::basic_string<_CharT> &__rhs);
  template < typename _CharT >
  inline typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type operator ==(const ::std::__cxx11::basic_string<_CharT> &__lhs, const ::std::__cxx11::basic_string<_CharT> &__rhs)
  {
    return __lhs.size() == __rhs.size() && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(), __lhs.size());
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator ==(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator ==(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __rhs.compare(__lhs) == 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator ==(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator ==(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    return __lhs.compare(__rhs) == 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator !=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator !=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return !(__lhs == __rhs);
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator !=(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator !=(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return !(__lhs == __rhs);
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator !=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator !=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    return !(__lhs == __rhs);
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __lhs.compare(__rhs) < 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    return __lhs.compare(__rhs) < 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __rhs.compare(__lhs) > 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __lhs.compare(__rhs) > 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    return __lhs.compare(__rhs) > 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __rhs.compare(__lhs) < 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __lhs.compare(__rhs) <= 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    return __lhs.compare(__rhs) <= 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <=(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <=(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __rhs.compare(__lhs) >= 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __lhs.compare(__rhs) >= 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    return __lhs.compare(__rhs) >= 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >=(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >=(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __rhs.compare(__lhs) <= 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline void swap(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline void swap(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    __lhs.swap(__rhs);
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__in, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str);
  template <>
  ::std::basic_istream<char> &operator >><char, ::std::char_traits<char>, ::std::allocator<char> >(::std::basic_istream<char> &__is, ::std::__cxx11::basic_string<char> &__str);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
  {
    return __ostream_insert(__os, __str.data(), __str.size());
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_istream<_CharT, _Traits> &getline(::std::basic_istream<_CharT, _Traits> &__in, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_istream<_CharT, _Traits> &getline(::std::basic_istream<_CharT, _Traits> &__is, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_istream<_CharT, _Traits> &getline(::std::basic_istream<_CharT, _Traits> &__is, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
  {
    return std::getline(__is, __str, __is.widen('\n'));
  }
  template <>
  ::std::basic_istream<char> &getline<char, ::std::char_traits<char>, ::std::allocator<char> >(::std::basic_istream<char> &__in, ::std::__cxx11::basic_string<char> &__str, char __delim);
  template <>
  ::std::basic_istream<wchar_t> &getline<wchar_t, ::std::char_traits<wchar_t>, ::std::allocator<wchar_t> >(::std::basic_istream<wchar_t> &__in, ::std::__cxx11::basic_string<wchar_t> &__str, wchar_t __delim);
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    template < typename _CharT, typename _Traits, typename _Alloc >
    const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::npos;
    template < typename _CharT, typename _Traits, typename _Alloc >
    void basic_string<_CharT, _Traits, _Alloc>::swap(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__s)
    {
      if (this == &__s)
        {
          return ;
        }
      _Alloc_traits::_S_on_swap((*this)._M_get_allocator(), __s._M_get_allocator());
      if ((*this)._M_is_local())
        {
          if (__s._M_is_local())
            {
              if ((*this).length() && __s.length())
                {
                  _CharT __tmp_data[::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity + 1];
                  traits_type::copy(__tmp_data, __s._M_local_buf, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity + 1);
                  traits_type::copy(__s._M_local_buf, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_buf, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity + 1);
                  traits_type::copy(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_buf, __tmp_data, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity + 1);
                }
              else
                {
                  if (__s.length())
                    {
                      traits_type::copy(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_buf, __s._M_local_buf, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity + 1);
                      (*this)._M_length(__s.length());
                      __s._M_set_length(0);
                      return ;
                    }
                  else
                    {
                      if ((*this).length())
                        {
                          traits_type::copy(__s._M_local_buf, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_buf, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity + 1);
                          __s._M_length((*this).length());
                          (*this)._M_set_length(0);
                          return ;
                        }
                    }
                }
            }
          else
            {
              const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __tmp_capacity = __s._M_allocated_capacity;
              traits_type::copy(__s._M_local_buf, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_buf, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity + 1);
              (*this)._M_data(__s._M_data());
              __s._M_data(__s._M_local_buf);
              (*this)._M_capacity(__tmp_capacity);
            }
        }
      else
        {
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __tmp_capacity = ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_allocated_capacity;
          if (__s._M_is_local())
            {
              traits_type::copy(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_buf, __s._M_local_buf, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity + 1);
              __s._M_data((*this)._M_data());
              (*this)._M_data(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_buf);
            }
          else
            {
              typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer __tmp_ptr = (*this)._M_data();
              (*this)._M_data(__s._M_data());
              __s._M_data(__tmp_ptr);
              (*this)._M_capacity(__s._M_allocated_capacity);
            }
          __s._M_capacity(__tmp_capacity);
        }
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __tmp_length = (*this).length();
      (*this)._M_length(__s.length());
      __s._M_length(__tmp_length);
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer basic_string<_CharT, _Traits, _Alloc>::_M_create(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type &__capacity, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __old_capacity)
    {
      if (__capacity > (*this).max_size())
        {
          std::__throw_length_error("basic_string::_M_create");
        }
      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
        {
          __capacity = 2 * __old_capacity;
          if (__capacity > (*this).max_size())
            {
              __capacity = (*this).max_size();
            }
        }
      return _Alloc_traits::allocate((*this)._M_get_allocator(), __capacity + 1);
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    template < typename _InIterator >
    void basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator __beg, _InIterator __end, ::std::input_iterator_tag)
    {
      typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len = 0;
      typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __capacity = ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity)));
      while (__beg != __end && __len < __capacity)
        {
          (*this)._M_data()[__len++] = *__beg;
           ++__beg;
        }
      try
      {
        while (__beg != __end)
          {
            if (__len == __capacity)
              {
                __capacity = __len + 1;
                typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer __another = (*this)._M_create(__capacity, __len);
                this->_S_copy(__another, (*this)._M_data(), __len);
                (*this)._M_dispose();
                (*this)._M_data(__another);
                (*this)._M_capacity(__capacity);
              }
            (*this)._M_data()[__len++] = *__beg;
             ++__beg;
          }
      }
      catch (...)
      {
        (*this)._M_dispose();
        throw;
      }
      (*this)._M_set_length(__len);
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    template < typename _InIterator >
    void basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator __beg, _InIterator __end, ::std::forward_iterator_tag)
    {
      if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
        {
          std::__throw_logic_error("basic_string::_M_construct null not valid");
        }
      typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __dnew = static_cast<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type>(std::distance(__beg, __end));
      if (__dnew > ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity))))
        {
          (*this)._M_data((*this)._M_create(__dnew, ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0)))));
          (*this)._M_capacity(__dnew);
        }
      try
      {
        this->_S_copy_chars((*this)._M_data(), __beg, __end);
      }
      catch (...)
      {
        (*this)._M_dispose();
        throw;
      }
      (*this)._M_set_length(__dnew);
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    void basic_string<_CharT, _Traits, _Alloc>::_M_construct(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
    {
      if (__n > ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity))))
        {
          (*this)._M_data((*this)._M_create(__n, ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0)))));
          (*this)._M_capacity(__n);
        }
      if (__n)
        {
          this->_S_assign((*this)._M_data(), __n, __c);
        }
      (*this)._M_set_length(__n);
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    void basic_string<_CharT, _Traits, _Alloc>::_M_assign(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
    {
      if (this != &__str)
        {
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __rsize = __str.length();
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __capacity = (*this).capacity();
          if (__rsize > __capacity)
            {
              typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __new_capacity = __rsize;
              typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer __tmp = (*this)._M_create(__new_capacity, __capacity);
              (*this)._M_dispose();
              (*this)._M_data(__tmp);
              (*this)._M_capacity(__new_capacity);
            }
          if (__rsize)
            {
              this->_S_copy((*this)._M_data(), __str._M_data(), __rsize);
            }
          (*this)._M_set_length(__rsize);
        }
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    void basic_string<_CharT, _Traits, _Alloc>::reserve(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __res)
    {
      if (__res < (*this).length())
        {
          __res = (*this).length();
        }
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __capacity = (*this).capacity();
      if (__res != __capacity)
        {
          if (__res > __capacity || __res > ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity))))
            {
              typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer __tmp = (*this)._M_create(__res, __capacity);
              this->_S_copy(__tmp, (*this)._M_data(), (*this).length() + 1);
              (*this)._M_dispose();
              (*this)._M_data(__tmp);
              (*this)._M_capacity(__res);
            }
          else
            {
              if (!(*this)._M_is_local())
                {
                  this->_S_copy((*this)._M_local_data(), (*this)._M_data(), (*this).length() + 1);
                  (*this)._M_destroy(__capacity);
                  (*this)._M_data((*this)._M_local_data());
                }
            }
        }
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    void basic_string<_CharT, _Traits, _Alloc>::_M_mutate(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len1, const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len2)
    {
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __how_much = (*this).length() - __pos - __len1;
      typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __new_capacity = (*this).length() + __len2 - __len1;
      typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer __r = (*this)._M_create(__new_capacity, (*this).capacity());
      if (__pos)
        {
          this->_S_copy(__r, (*this)._M_data(), __pos);
        }
      if (__s && __len2)
        {
          this->_S_copy(__r + __pos, __s, __len2);
        }
      if (__how_much)
        {
          this->_S_copy(__r + __pos + __len2, (*this)._M_data() + __pos + __len1, __how_much);
        }
      (*this)._M_dispose();
      (*this)._M_data(__r);
      (*this)._M_capacity(__new_capacity);
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    void basic_string<_CharT, _Traits, _Alloc>::_M_erase(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
    {
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __how_much = (*this).length() - __pos - __n;
      if (__how_much && __n)
        {
          this->_S_move((*this)._M_data() + __pos, (*this)._M_data() + __pos + __n, __how_much);
        }
      (*this)._M_set_length((*this).length() - __n);
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    void basic_string<_CharT, _Traits, _Alloc>::resize(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
    {
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
      if (__size < __n)
        {
          this->append(__n - __size, __c);
        }
      else
        {
          if (__n < __size)
            {
              this->_M_set_length(__n);
            }
        }
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_append(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
    {
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len = __n + this->size();
      if (__len <= this->capacity())
        {
          if (__n)
            {
              this->_S_copy(this->_M_data() + this->size(), __s, __n);
            }
        }
      else
        {
          this->_M_mutate(this->size(), ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __s, __n);
        }
      this->_M_set_length(__len);
      return *this;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    template < typename _InputIterator >
    ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace_dispatch(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __i1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, ::std::__false_type)
    {
      const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> __s(__k1, __k2);
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1 = __i2 - __i1;
      return (*this)._M_replace(__i1 - (*this).begin(), __n1, __s._M_data(), __s.size());
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace_aux(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n2, _CharT __c)
    {
      (*this)._M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __old_size = this->size();
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __new_size = __old_size + __n2 - __n1;
      if (__new_size <= this->capacity())
        {
          typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer __p = this->_M_data() + __pos1;
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __how_much = __old_size - __pos1 - __n1;
          if (__how_much && __n1 != __n2)
            {
              this->_S_move(__p + __n2, __p + __n1, __how_much);
            }
        }
      else
        {
          this->_M_mutate(__pos1, __n1, 0, __n2);
        }
      if (__n2)
        {
          this->_S_assign(this->_M_data() + __pos1, __n2, __c);
        }
      this->_M_set_length(__new_size);
      return *this;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len1, const _CharT *__s, const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len2)
    {
      (*this)._M_check_length(__len1, __len2, "basic_string::_M_replace");
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __old_size = this->size();
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __new_size = __old_size + __len2 - __len1;
      if (__new_size <= this->capacity())
        {
          typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer __p = this->_M_data() + __pos;
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __how_much = __old_size - __pos - __len1;
          if ((*this)._M_disjunct(__s))
            {
              if (__how_much && __len1 != __len2)
                {
                  this->_S_move(__p + __len2, __p + __len1, __how_much);
                }
              if (__len2)
                {
                  this->_S_copy(__p, __s, __len2);
                }
            }
          else
            {
              if (__len2 && __len2 <= __len1)
                {
                  this->_S_move(__p, __s, __len2);
                }
              if (__how_much && __len1 != __len2)
                {
                  this->_S_move(__p + __len2, __p + __len1, __how_much);
                }
              if (__len2 > __len1)
                {
                  if (__s + __len2 <= __p + __len1)
                    {
                      this->_S_move(__p, __s, __len2);
                    }
                  else
                    {
                      if (__s >= __p + __len1)
                        {
                          this->_S_copy(__p, __s + __len2 - __len1, __len2);
                        }
                      else
                        {
                          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __nleft = __p + __len1 - __s;
                          this->_S_move(__p, __s, __nleft);
                          this->_S_copy(__p + __nleft, __p + __len2, __len2 - __nleft);
                        }
                    }
                }
            }
        }
      else
        {
          this->_M_mutate(__pos, __len1, __s, __len2);
        }
      this->_M_set_length(__new_size);
      return *this;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::copy(_CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos) const 
    {
      (*this)._M_check(__pos, "basic_string::copy");
      __n = (*this)._M_limit(__pos, __n);
      ;
      if (__n)
        {
          _S_copy(__s, (*this)._M_data() + __pos, __n);
        }
      return __n;
    }
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    ;
    typedef ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> __string_type;
    typedef typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size_type;
    const __size_type __len = _Traits::length(__lhs);
    __string_type __str;
    __str.reserve(__len + __rhs.size());
    __str.append(__lhs, __len);
    __str.append(__rhs);
    return __str;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(_CharT __lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    typedef ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> __string_type;
    typedef typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size_type;
    __string_type __str;
    const __size_type __len = __rhs.size();
    __str.reserve(__len + 1);
    __str.append(__size_type(1), __lhs);
    __str.append(__rhs);
    return __str;
  }
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    template < typename _CharT, typename _Traits, typename _Alloc >
    typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
    {
      ;
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
      if (__n == 0)
        {
          return __pos <= __size ? __pos : ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos;
        }
      if (__pos >= __size)
        {
          return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos;
        }
      const _CharT __elem0 = __s[0];
      const _CharT *const __data = (*this).data();
      const _CharT *__first = __data + __pos;
      const _CharT *const __last = __data + __size;
      typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len = __size - __pos;
      while (__len >= __n)
        {
          __first = traits_type::find(__first, __len - __n + 1, __elem0);
          if (!__first)
            {
              return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos;
            }
          if (traits_type::compare(__first, __s, __n) == 0)
            {
              return __first - __data;
            }
          __len = __last -  ++__first;
        }
      return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find(_CharT __c, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos) const 
    {
      typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __ret = ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos;
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
      if (__pos < __size)
        {
          const _CharT *__data = (*this)._M_data();
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n = __size - __pos;
          const _CharT *__p = traits_type::find(__data + __pos, __n, __c);
          if (__p)
            {
              __ret = __p - __data;
            }
        }
      return __ret;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::rfind(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
    {
      ;
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
      if (__n <= __size)
        {
          __pos = std::min(((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(__size - __n))), __pos);
          const _CharT *__data = (*this)._M_data();
          do
            {
              if (traits_type::compare(__data + __pos, __s, __n) == 0)
                {
                  return __pos;
                }
            }
          while (__pos-- > 0);
        }
      return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::rfind(_CharT __c, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos) const 
    {
      typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
      if (__size)
        {
          if ( --__size > __pos)
            {
              __size = __pos;
            }
          for ( ++__size; __size-- > 0; )
            {
              if (traits_type::eq((*this)._M_data()[__size], __c))
                {
                  return __size;
                }
            }
        }
      return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_of(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
    {
      ;
      for (; __n && __pos < this->size();  ++__pos)
        {
          const _CharT *__p = traits_type::find(__s, __n, (*this)._M_data()[__pos]);
          if (__p)
            {
              return __pos;
            }
        }
      return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_of(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
    {
      ;
      typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
      if (__size && __n)
        {
          if ( --__size > __pos)
            {
              __size = __pos;
            }
          do
            {
              if (traits_type::find(__s, __n, (*this)._M_data()[__size]))
                {
                  return __size;
                }
            }
          while (__size-- != 0);
        }
      return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
    {
      ;
      for (; __pos < this->size();  ++__pos)
        {
          if (!traits_type::find(__s, __n, (*this)._M_data()[__pos]))
            {
              return __pos;
            }
        }
      return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(_CharT __c, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos) const 
    {
      for (; __pos < this->size();  ++__pos)
        {
          if (!traits_type::eq((*this)._M_data()[__pos], __c))
            {
              return __pos;
            }
        }
      return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
    {
      ;
      typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
      if (__size)
        {
          if ( --__size > __pos)
            {
              __size = __pos;
            }
          do
            {
              if (!traits_type::find(__s, __n, (*this)._M_data()[__size]))
                {
                  return __size;
                }
            }
          while (__size--);
        }
      return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(_CharT __c, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos) const 
    {
      typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
      if (__size)
        {
          if ( --__size > __pos)
            {
              __size = __pos;
            }
          do
            {
              if (!traits_type::eq((*this)._M_data()[__size], __c))
                {
                  return __size;
                }
            }
          while (__size--);
        }
      return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    int basic_string<_CharT, _Traits, _Alloc>::compare(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str) const 
    {
      (*this)._M_check(__pos, "basic_string::compare");
      __n = (*this)._M_limit(__pos, __n);
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __osize = __str.size();
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare((*this)._M_data() + __pos, __str.data(), __len);
      if (!__r)
        {
          __r = _S_compare(__n, __osize);
        }
      return __r;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    int basic_string<_CharT, _Traits, _Alloc>::compare(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos2, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n2) const 
    {
      (*this)._M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = (*this)._M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare((*this)._M_data() + __pos1, __str.data() + __pos2, __len);
      if (!__r)
        {
          __r = _S_compare(__n1, __n2);
        }
      return __r;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    int basic_string<_CharT, _Traits, _Alloc>::compare(const _CharT *__s) const 
    {
      ;
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __osize = traits_type::length(__s);
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare((*this)._M_data(), __s, __len);
      if (!__r)
        {
          __r = _S_compare(__size, __osize);
        }
      return __r;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    int basic_string<_CharT, _Traits, _Alloc>::compare(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s) const 
    {
      ;
      (*this)._M_check(__pos, "basic_string::compare");
      __n1 = (*this)._M_limit(__pos, __n1);
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __osize = traits_type::length(__s);
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare((*this)._M_data() + __pos, __s, __len);
      if (!__r)
        {
          __r = _S_compare(__n1, __osize);
        }
      return __r;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    int basic_string<_CharT, _Traits, _Alloc>::compare(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n2) const 
    {
      ;
      (*this)._M_check(__pos, "basic_string::compare");
      __n1 = (*this)._M_limit(__pos, __n1);
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare((*this)._M_data() + __pos, __s, __len);
      if (!__r)
        {
          __r = _S_compare(__n1, __n2);
        }
      return __r;
    }
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__in, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> __string_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    typedef typename ::std::basic_istream<_CharT, _Traits>::int_type __int_type;
    typedef typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size_type;
    typedef ::std::ctype<_CharT> __ctype_type;
    typedef typename ::std::ctype<_CharT>::ctype_base __ctype_base;
    __size_type __extracted = 0;
    typename ::std::basic_istream<_CharT, _Traits>::ios_base::iostate __err = __ios_base::goodbit;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(__in, false);
    if (__cerb)
      {
        try
        {
          __str.erase();
          _CharT __buf[128L];
          __size_type __len = 0;
          const ::std::streamsize __w = __in.width();
          const __size_type __n = __w > 0 ? static_cast<__size_type>(__w) : __str.max_size();
          const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
          const __int_type __eof = _Traits::eof();
          __int_type __c = __in.rdbuf()->sgetc();
          while ((__extracted < __n && !_Traits::eq_int_type(__c, __eof)) && !__ct.is(__ctype_base::space, _Traits::to_char_type(__c)))
            {
              if (__len == sizeof(__buf) / sizeof(_CharT))
                {
                  __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
                  __len = 0;
                }
              __buf[__len++] = _Traits::to_char_type(__c);
               ++__extracted;
              __c = __in.rdbuf()->snextc();
            }
          __str.append(__buf, __len);
          if (_Traits::eq_int_type(__c, __eof))
            {
              __err |= __ios_base::eofbit;
            }
          __in.width(0);
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __in._M_setstate(__ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __in._M_setstate(__ios_base::badbit);
        }
      }
    if (!__extracted)
      {
        __err |= __ios_base::failbit;
      }
    if (__err)
      {
        __in.setstate(__err);
      }
    return __in;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_istream<_CharT, _Traits> &getline(::std::basic_istream<_CharT, _Traits> &__in, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> __string_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    typedef typename ::std::basic_istream<_CharT, _Traits>::int_type __int_type;
    typedef typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size_type;
    __size_type __extracted = 0;
    const __size_type __n = __str.max_size();
    typename ::std::basic_istream<_CharT, _Traits>::ios_base::iostate __err = __ios_base::goodbit;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(__in, true);
    if (__cerb)
      {
        try
        {
          __str.erase();
          const __int_type __idelim = _Traits::to_int_type(__delim);
          const __int_type __eof = _Traits::eof();
          __int_type __c = __in.rdbuf()->sgetc();
          while ((__extracted < __n && !_Traits::eq_int_type(__c, __eof)) && !_Traits::eq_int_type(__c, __idelim))
            {
              __str += _Traits::to_char_type(__c);
               ++__extracted;
              __c = __in.rdbuf()->snextc();
            }
          if (_Traits::eq_int_type(__c, __eof))
            {
              __err |= __ios_base::eofbit;
            }
          else
            {
              if (_Traits::eq_int_type(__c, __idelim))
                {
                   ++__extracted;
                  __in.rdbuf()->sbumpc();
                }
              else
                {
                  __err |= __ios_base::failbit;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __in._M_setstate(__ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __in._M_setstate(__ios_base::badbit);
        }
      }
    if (!__extracted)
      {
        __err |= __ios_base::failbit;
      }
    if (__err)
      {
        __in.setstate(__err);
      }
    return __in;
  }
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    extern template class ::std::__cxx11::basic_string<char>;
  }
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, ::std::__cxx11::basic_string<char> &);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, const ::std::__cxx11::basic_string<char> &);
  extern template ::std::basic_istream<char> &getline(::std::basic_istream<char> &, ::std::__cxx11::basic_string<char> &, char);
  extern template ::std::basic_istream<char> &getline(::std::basic_istream<char> &, ::std::__cxx11::basic_string<char> &);
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    extern template class ::std::__cxx11::basic_string<wchar_t>;
  }
  extern template ::std::basic_istream<wchar_t> &operator >>(::std::basic_istream<wchar_t> &, ::std::__cxx11::basic_string<wchar_t> &);
  extern template ::std::basic_ostream<wchar_t> &operator <<(::std::basic_ostream<wchar_t> &, const ::std::__cxx11::basic_string<wchar_t> &);
  extern template ::std::basic_istream<wchar_t> &getline(::std::basic_istream<wchar_t> &, ::std::__cxx11::basic_string<wchar_t> &, wchar_t);
  extern template ::std::basic_istream<wchar_t> &getline(::std::basic_istream<wchar_t> &, ::std::__cxx11::basic_string<wchar_t> &);
  enum _Rb_tree_color
  {
    _S_red = false,
    _S_black = true
  };
  struct  _Rb_tree_node_base
  {
      typedef ::std::_Rb_tree_node_base *_Base_ptr;
      typedef const ::std::_Rb_tree_node_base *_Const_Base_ptr;
      ::std::_Rb_tree_color _M_color;
      ::std::_Rb_tree_node_base::_Base_ptr _M_parent;
      ::std::_Rb_tree_node_base::_Base_ptr _M_left;
      ::std::_Rb_tree_node_base::_Base_ptr _M_right;
      static inline ::std::_Rb_tree_node_base::_Base_ptr _S_minimum(::std::_Rb_tree_node_base::_Base_ptr __x)
      {
        while ((*__x)._M_left != 0)
          {
            __x = (*__x)._M_left;
          }
        return __x;
      }
      static inline ::std::_Rb_tree_node_base::_Const_Base_ptr _S_minimum(::std::_Rb_tree_node_base::_Const_Base_ptr __x)
      {
        while ((*__x)._M_left != 0)
          {
            __x = (*__x)._M_left;
          }
        return __x;
      }
      static inline ::std::_Rb_tree_node_base::_Base_ptr _S_maximum(::std::_Rb_tree_node_base::_Base_ptr __x)
      {
        while ((*__x)._M_right != 0)
          {
            __x = (*__x)._M_right;
          }
        return __x;
      }
      static inline ::std::_Rb_tree_node_base::_Const_Base_ptr _S_maximum(::std::_Rb_tree_node_base::_Const_Base_ptr __x)
      {
        while ((*__x)._M_right != 0)
          {
            __x = (*__x)._M_right;
          }
        return __x;
      }
  };
  template < typename _Key_compare >
  struct  _Rb_tree_key_compare
  {
      _Key_compare _M_key_compare;
      inline _Rb_tree_key_compare()
        : _M_key_compare()
      {
      }
      inline _Rb_tree_key_compare(const _Key_compare &__comp)
        : _M_key_compare(__comp)
      {
      }
  };
  struct  _Rb_tree_header
  {
      ::std::_Rb_tree_node_base _M_header;
      ::std::size_t _M_node_count;
      inline _Rb_tree_header()
      {
        (*this)._M_header._M_color = ::std::_S_red;
        (*this).::std::_Rb_tree_header::_M_reset();
      }
      inline void _M_move_data(::std::_Rb_tree_header &__from)
      {
        (*this)._M_header._M_color = __from._M_header._M_color;
        (*this)._M_header._M_parent = __from._M_header._M_parent;
        (*this)._M_header._M_left = __from._M_header._M_left;
        (*this)._M_header._M_right = __from._M_header._M_right;
        (*(*this)._M_header._M_parent)._M_parent = &(*this)._M_header;
        (*this)._M_node_count = __from._M_node_count;
        __from.::std::_Rb_tree_header::_M_reset();
      }
      inline void _M_reset()
      {
        (*this)._M_header._M_parent = 0;
        (*this)._M_header._M_left = &(*this)._M_header;
        (*this)._M_header._M_right = &(*this)._M_header;
        (*this)._M_node_count = 0;
      }
  };
  template < typename _Val >
  struct  _Rb_tree_node : ::std::_Rb_tree_node_base
  {
      typedef ::std::_Rb_tree_node<_Val> *_Link_type;
      _Val _M_value_field;
      inline _Val *_M_valptr()
      {
        return std::__addressof(::std::_Rb_tree_node<_Val>::_M_value_field);
      }
      inline const _Val *_M_valptr() const 
      {
        return std::__addressof(::std::_Rb_tree_node<_Val>::_M_value_field);
      }
  };
  ::std::_Rb_tree_node_base *_Rb_tree_increment(::std::_Rb_tree_node_base *__x) throw() __attribute__((__pure__));
  const ::std::_Rb_tree_node_base *_Rb_tree_increment(const ::std::_Rb_tree_node_base *__x) throw() __attribute__((__pure__));
  ::std::_Rb_tree_node_base *_Rb_tree_decrement(::std::_Rb_tree_node_base *__x) throw() __attribute__((__pure__));
  const ::std::_Rb_tree_node_base *_Rb_tree_decrement(const ::std::_Rb_tree_node_base *__x) throw() __attribute__((__pure__));
  template < typename _Tp >
  struct  _Rb_tree_iterator
  {
      typedef _Tp value_type;
      typedef _Tp &reference;
      typedef _Tp *pointer;
      typedef ::std::bidirectional_iterator_tag iterator_category;
      typedef ::std::ptrdiff_t difference_type;
      typedef ::std::_Rb_tree_iterator<_Tp> _Self;
      typedef ::std::_Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef ::std::_Rb_tree_node<_Tp> *_Link_type;
      inline _Rb_tree_iterator()
        : _M_node()
      {
      }
      inline explicit _Rb_tree_iterator(typename ::std::_Rb_tree_iterator<_Tp>::_Base_ptr __x)
        : _M_node(__x)
      {
      }
      inline typename ::std::_Rb_tree_iterator<_Tp>::reference operator *() const 
      {
        return *static_cast<typename ::std::_Rb_tree_iterator<_Tp>::_Link_type>(::std::_Rb_tree_iterator<_Tp>::_M_node)->_M_valptr();
      }
      inline typename ::std::_Rb_tree_iterator<_Tp>::pointer operator ->() const 
      {
        return static_cast<typename ::std::_Rb_tree_iterator<_Tp>::_Link_type>(::std::_Rb_tree_iterator<_Tp>::_M_node)->_M_valptr();
      }
      inline typename ::std::_Rb_tree_iterator<_Tp>::_Self &operator ++()
      {
        ::std::_Rb_tree_iterator<_Tp>::_M_node = _Rb_tree_increment(::std::_Rb_tree_iterator<_Tp>::_M_node);
        return *this;
      }
      inline typename ::std::_Rb_tree_iterator<_Tp>::_Self operator ++(int)
      {
        typename ::std::_Rb_tree_iterator<_Tp>::_Self __tmp = *this;
        ::std::_Rb_tree_iterator<_Tp>::_M_node = _Rb_tree_increment(::std::_Rb_tree_iterator<_Tp>::_M_node);
        return __tmp;
      }
      inline typename ::std::_Rb_tree_iterator<_Tp>::_Self &operator --()
      {
        ::std::_Rb_tree_iterator<_Tp>::_M_node = _Rb_tree_decrement(::std::_Rb_tree_iterator<_Tp>::_M_node);
        return *this;
      }
      inline typename ::std::_Rb_tree_iterator<_Tp>::_Self operator --(int)
      {
        typename ::std::_Rb_tree_iterator<_Tp>::_Self __tmp = *this;
        ::std::_Rb_tree_iterator<_Tp>::_M_node = _Rb_tree_decrement(::std::_Rb_tree_iterator<_Tp>::_M_node);
        return __tmp;
      }
      inline bool operator ==(const typename ::std::_Rb_tree_iterator<_Tp>::_Self &__x) const 
      {
        return ::std::_Rb_tree_iterator<_Tp>::_M_node == __x._M_node;
      }
      inline bool operator !=(const typename ::std::_Rb_tree_iterator<_Tp>::_Self &__x) const 
      {
        return ::std::_Rb_tree_iterator<_Tp>::_M_node != __x._M_node;
      }
      typename ::std::_Rb_tree_iterator<_Tp>::_Base_ptr _M_node;
  };
  template < typename _Tp >
  struct  _Rb_tree_const_iterator
  {
      typedef _Tp value_type;
      typedef const _Tp &reference;
      typedef const _Tp *pointer;
      typedef ::std::_Rb_tree_iterator<_Tp> iterator;
      typedef ::std::bidirectional_iterator_tag iterator_category;
      typedef ::std::ptrdiff_t difference_type;
      typedef ::std::_Rb_tree_const_iterator<_Tp> _Self;
      typedef ::std::_Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const ::std::_Rb_tree_node<_Tp> *_Link_type;
      inline _Rb_tree_const_iterator()
        : _M_node()
      {
      }
      inline explicit _Rb_tree_const_iterator(typename ::std::_Rb_tree_const_iterator<_Tp>::_Base_ptr __x)
        : _M_node(__x)
      {
      }
      inline _Rb_tree_const_iterator(const typename ::std::_Rb_tree_const_iterator<_Tp>::iterator &__it)
        : _M_node(__it._M_node)
      {
      }
      inline typename ::std::_Rb_tree_const_iterator<_Tp>::iterator _M_const_cast() const 
      {
        return ((typename ::std::_Rb_tree_const_iterator<_Tp>::iterator(const_cast<typename ::std::_Rb_tree_iterator<_Tp>::_Base_ptr>(::std::_Rb_tree_const_iterator<_Tp>::_M_node))));
      }
      inline typename ::std::_Rb_tree_const_iterator<_Tp>::reference operator *() const 
      {
        return *static_cast<typename ::std::_Rb_tree_const_iterator<_Tp>::_Link_type>(::std::_Rb_tree_const_iterator<_Tp>::_M_node)->_M_valptr();
      }
      inline typename ::std::_Rb_tree_const_iterator<_Tp>::pointer operator ->() const 
      {
        return static_cast<typename ::std::_Rb_tree_const_iterator<_Tp>::_Link_type>(::std::_Rb_tree_const_iterator<_Tp>::_M_node)->_M_valptr();
      }
      inline typename ::std::_Rb_tree_const_iterator<_Tp>::_Self &operator ++()
      {
        ::std::_Rb_tree_const_iterator<_Tp>::_M_node = _Rb_tree_increment(::std::_Rb_tree_const_iterator<_Tp>::_M_node);
        return *this;
      }
      inline typename ::std::_Rb_tree_const_iterator<_Tp>::_Self operator ++(int)
      {
        typename ::std::_Rb_tree_const_iterator<_Tp>::_Self __tmp = *this;
        ::std::_Rb_tree_const_iterator<_Tp>::_M_node = _Rb_tree_increment(::std::_Rb_tree_const_iterator<_Tp>::_M_node);
        return __tmp;
      }
      inline typename ::std::_Rb_tree_const_iterator<_Tp>::_Self &operator --()
      {
        ::std::_Rb_tree_const_iterator<_Tp>::_M_node = _Rb_tree_decrement(::std::_Rb_tree_const_iterator<_Tp>::_M_node);
        return *this;
      }
      inline typename ::std::_Rb_tree_const_iterator<_Tp>::_Self operator --(int)
      {
        typename ::std::_Rb_tree_const_iterator<_Tp>::_Self __tmp = *this;
        ::std::_Rb_tree_const_iterator<_Tp>::_M_node = _Rb_tree_decrement(::std::_Rb_tree_const_iterator<_Tp>::_M_node);
        return __tmp;
      }
      inline bool operator ==(const typename ::std::_Rb_tree_const_iterator<_Tp>::_Self &__x) const 
      {
        return ::std::_Rb_tree_const_iterator<_Tp>::_M_node == __x._M_node;
      }
      inline bool operator !=(const typename ::std::_Rb_tree_const_iterator<_Tp>::_Self &__x) const 
      {
        return ::std::_Rb_tree_const_iterator<_Tp>::_M_node != __x._M_node;
      }
      typename ::std::_Rb_tree_const_iterator<_Tp>::_Base_ptr _M_node;
  };
  template < typename _Val >
  inline bool operator ==(const ::std::_Rb_tree_iterator<_Val> &__x, const ::std::_Rb_tree_const_iterator<_Val> &__y);
  template < typename _Val >
  inline bool operator ==(const ::std::_Rb_tree_iterator<_Val> &__x, const ::std::_Rb_tree_const_iterator<_Val> &__y)
  {
    return __x._M_node == __y._M_node;
  }
  template < typename _Val >
  inline bool operator !=(const ::std::_Rb_tree_iterator<_Val> &__x, const ::std::_Rb_tree_const_iterator<_Val> &__y);
  template < typename _Val >
  inline bool operator !=(const ::std::_Rb_tree_iterator<_Val> &__x, const ::std::_Rb_tree_const_iterator<_Val> &__y)
  {
    return __x._M_node != __y._M_node;
  }
  void _Rb_tree_insert_and_rebalance(const bool __insert_left, ::std::_Rb_tree_node_base *__x, ::std::_Rb_tree_node_base *__p, ::std::_Rb_tree_node_base &__header) throw();
  ::std::_Rb_tree_node_base *_Rb_tree_rebalance_for_erase(::std::_Rb_tree_node_base *const __z, ::std::_Rb_tree_node_base &__header) throw();
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc = ::std::allocator<_Val> >
  class  _Rb_tree
  {
      typedef typename ::__gnu_cxx::__alloc_traits<_Alloc>::template rebind< ::std::_Rb_tree_node<_Val> >::other _Node_allocator;
      typedef ::__gnu_cxx::__alloc_traits<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator> _Alloc_traits;
    protected:
      typedef ::std::_Rb_tree_node_base *_Base_ptr;
      typedef const ::std::_Rb_tree_node_base *_Const_Base_ptr;
      typedef ::std::_Rb_tree_node<_Val> *_Link_type;
      typedef const ::std::_Rb_tree_node<_Val> *_Const_Link_type;
    private:
      struct  _Reuse_or_alloc_node
      {
          inline _Reuse_or_alloc_node(::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__t)
            : _M_root(__t._M_root()), _M_nodes(__t._M_rightmost()), _M_t(__t)
          {
            if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_root)
              {
                ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_root->_M_parent = 0;
                if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_nodes->_M_left)
                  {
                    ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_nodes = ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_nodes->_M_left;
                  }
              }
            else
              {
                ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_nodes = 0;
              }
          }
          inline ~_Reuse_or_alloc_node()
          {
            ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_t._M_erase(static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type>(::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_root));
          }
          template < typename _Arg >
          inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type operator ()(const _Arg &__arg)
          {
            typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __node = static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type>((*this)._M_extract());
            if (__node)
              {
                ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_t._M_destroy_node(__node);
                ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_t._M_construct_node(__node, __arg);
                return __node;
              }
            return ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_t._M_create_node(__arg);
          }
        private:
          inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr _M_extract()
          {
            if (!::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_nodes)
              {
                return ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_nodes;
              }
            typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __node = ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_nodes;
            ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_nodes = ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_nodes->_M_parent;
            if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_nodes)
              {
                if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_nodes->_M_right == __node)
                  {
                    ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_nodes->_M_right = 0;
                    if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_nodes->_M_left)
                      {
                        ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_nodes = ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_nodes->_M_left;
                        while (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_nodes->_M_right)
                          {
                            ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_nodes = ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_nodes->_M_right;
                          }
                        if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_nodes->_M_left)
                          {
                            ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_nodes = ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_nodes->_M_left;
                          }
                      }
                  }
                else
                  {
                    ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_nodes->_M_left = 0;
                  }
              }
            else
              {
                ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::_M_root = 0;
              }
            return __node;
          }
          typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr _M_root;
          typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr _M_nodes;
          ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &_M_t;
      };
      struct  _Alloc_node
      {
          inline _Alloc_node(::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__t)
            : _M_t(__t)
          {
          }
          template < typename _Arg >
          inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type operator ()(const _Arg &__arg) const 
          {
            return ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Alloc_node::_M_t._M_create_node(__arg);
          }
        private:
          ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &_M_t;
      };
    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type *pointer;
      typedef const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type *const_pointer;
      typedef typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type &reference;
      typedef const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type &const_reference;
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef _Alloc allocator_type;
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator &_M_get_Node_allocator()
      {
        return *static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator *>(&this->_M_impl);
      }
      inline const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator &_M_get_Node_allocator() const 
      {
        return *static_cast<const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator *>(&this->_M_impl);
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::allocator_type get_allocator() const 
      {
        return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::allocator_type((*this)._M_get_Node_allocator())));
      }
    protected:
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type _M_get_node()
      {
        return _Alloc_traits::allocate((*this)._M_get_Node_allocator(), 1);
      }
      inline void _M_put_node(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __p)
      {
        _Alloc_traits::deallocate((*this)._M_get_Node_allocator(), __p, 1);
      }
      inline void _M_construct_node(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __node, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type &__x)
      {
        try
        {
          (*this).get_allocator().construct(__node->_M_valptr(), __x);
        }
        catch (...)
        {
          (*this)._M_put_node(__node);
          throw;
        }
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type _M_create_node(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type &__x)
      {
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __tmp = (*this)._M_get_node();
        (*this)._M_construct_node(__tmp, __x);
        return __tmp;
      }
      inline void _M_destroy_node(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __p)
      {
        (*this).get_allocator().destroy(__p->_M_valptr());
      }
      inline void _M_drop_node(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __p)
      {
        (*this)._M_destroy_node(__p);
        (*this)._M_put_node(__p);
      }
      template < typename _NodeGen >
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type _M_clone_node(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x, _NodeGen &__node_gen)
      {
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __tmp = __node_gen(*__x->_M_valptr());
        __tmp->_M_color = __x->_M_color;
        __tmp->_M_left = 0;
        __tmp->_M_right = 0;
        return __tmp;
      }
      template < typename _Key_compare, bool __nontype_tpl_param_2_1__ = __is_pod(_Key_compare) >
      struct  _Rb_tree_impl : ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator, ::std::_Rb_tree_key_compare<_Key_compare>, ::std::_Rb_tree_header
      {
          typedef ::std::_Rb_tree_key_compare<_Key_compare> _Base_key_compare;
          inline _Rb_tree_impl()
          {
          }
          inline _Rb_tree_impl(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::template _Rb_tree_impl<_Key_compare, __nontype_tpl_param_2_1__> &__x)
            : _Node_allocator(_Alloc_traits::_S_select_on_copy(__x)), _Base_key_compare(__x._M_key_compare)
          {
          }
          inline _Rb_tree_impl(const _Key_compare &__comp, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator &__a)
            : _Node_allocator(__a), _Base_key_compare(__comp)
          {
          }
      };
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::template _Rb_tree_impl<_Compare> _M_impl;
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr &_M_root()
      {
        return this->_M_impl._M_header._M_parent;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr _M_root() const 
      {
        return this->_M_impl._M_header._M_parent;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr &_M_leftmost()
      {
        return this->_M_impl._M_header._M_left;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr _M_leftmost() const 
      {
        return this->_M_impl._M_header._M_left;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr &_M_rightmost()
      {
        return this->_M_impl._M_header._M_right;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr _M_rightmost() const 
      {
        return this->_M_impl._M_header._M_right;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type _M_begin()
      {
        return static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type>(this->_M_impl._M_header._M_parent);
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type _M_begin() const 
      {
        return static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type>(this->_M_impl._M_header._M_parent);
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr _M_end()
      {
        return &this->_M_impl._M_header;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr _M_end() const 
      {
        return &this->_M_impl._M_header;
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_reference _S_value(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x)
      {
        return *__x->_M_valptr();
      }
      static inline const _Key &_S_key(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x)
      {
        return _KeyOfValue()(_S_value(__x));
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type _S_left(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __x)
      {
        return static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type>((*__x)._M_left);
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type _S_left(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __x)
      {
        return static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type>((*__x)._M_left);
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type _S_right(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __x)
      {
        return static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type>((*__x)._M_right);
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type _S_right(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __x)
      {
        return static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type>((*__x)._M_right);
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_reference _S_value(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __x)
      {
        return *static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type>(__x)->_M_valptr();
      }
      static inline const _Key &_S_key(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __x)
      {
        return _KeyOfValue()(_S_value(__x));
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr _S_minimum(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __x)
      {
        return _Rb_tree_node_base::_S_minimum(__x);
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr _S_minimum(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __x)
      {
        return _Rb_tree_node_base::_S_minimum(__x);
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr _S_maximum(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __x)
      {
        return _Rb_tree_node_base::_S_maximum(__x);
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr _S_maximum(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __x)
      {
        return _Rb_tree_node_base::_S_maximum(__x);
      }
    public:
      typedef ::std::_Rb_tree_iterator<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type> iterator;
      typedef ::std::_Rb_tree_const_iterator<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type> const_iterator;
      typedef ::std::reverse_iterator<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator> reverse_iterator;
      typedef ::std::reverse_iterator<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator> const_reverse_iterator;
      ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> _M_get_insert_unique_pos(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k);
      ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> _M_get_insert_equal_pos(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k);
      ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> _M_get_insert_hint_unique_pos(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k);
      ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> _M_get_insert_hint_equal_pos(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k);
    private:
      template < typename _NodeGen >
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_insert_(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __p, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type &__v, _NodeGen &__node_gen);
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_insert_lower(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __p, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type &__v);
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_insert_equal_lower(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type &__v);
      template < typename _NodeGen >
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type _M_copy(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __p, _NodeGen &__node_gen);
      template < typename _NodeGen >
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type _M_copy(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, _NodeGen &__gen)
      {
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __root = (*this)._M_copy(__x._M_begin(), (*this)._M_end(), __gen);
        (*this)._M_leftmost() = _S_minimum(__root);
        (*this)._M_rightmost() = _S_maximum(__root);
        ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_node_count = __x._M_impl._M_node_count;
        return __root;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type _M_copy(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x)
      {
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Alloc_node __an(*this);
        return (*this)._M_copy(__x, __an);
      }
      void _M_erase(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x);
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_lower_bound(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __y, const _Key &__k);
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator _M_lower_bound(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __y, const _Key &__k) const ;
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_upper_bound(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __y, const _Key &__k);
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator _M_upper_bound(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __y, const _Key &__k) const ;
    public:
      inline _Rb_tree()
      {
      }
      inline _Rb_tree(const _Compare &__comp, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::allocator_type &__a  = (((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::allocator_type()))))
        : _M_impl(__comp, ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator(__a))))
      {
      }
      inline _Rb_tree(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x)
        : _M_impl(__x._M_impl)
      {
        if (__x._M_root() != 0)
          {
            (*this)._M_root() = (*this)._M_copy(__x);
          }
      }
      inline ~_Rb_tree()
      {
        (*this)._M_erase((*this)._M_begin());
      }
      ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &operator =(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x);
      inline _Compare key_comp() const 
      {
        return ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator begin()
      {
        return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(this->_M_impl._M_header._M_left)));
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator begin() const 
      {
        return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator(this->_M_impl._M_header._M_left)));
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator end()
      {
        return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(&this->_M_impl._M_header)));
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator end() const 
      {
        return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator(&this->_M_impl._M_header)));
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::reverse_iterator rbegin()
      {
        return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::reverse_iterator((*this).end())));
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_reverse_iterator rbegin() const 
      {
        return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_reverse_iterator((*this).end())));
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::reverse_iterator rend()
      {
        return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::reverse_iterator((*this).begin())));
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_reverse_iterator rend() const 
      {
        return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_reverse_iterator((*this).begin())));
      }
      inline bool empty() const 
      {
        return ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_node_count == 0;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type size() const 
      {
        return ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_node_count;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type max_size() const 
      {
        return _Alloc_traits::max_size((*this)._M_get_Node_allocator());
      }
      void swap(::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__t);
      ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, bool> _M_insert_unique(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type &__v);
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_insert_equal(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type &__v);
      template < typename _NodeGen >
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_insert_unique_(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type &__v, _NodeGen &__node_gen);
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_insert_unique_(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __pos, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type &__x)
      {
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Alloc_node __an(*this);
        return (*this)._M_insert_unique_(__pos, __x, __an);
      }
      template < typename _NodeGen >
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_insert_equal_(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type &__v, _NodeGen &__node_gen);
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_insert_equal_(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __pos, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type &__x)
      {
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Alloc_node __an(*this);
        return (*this)._M_insert_equal_(__pos, __x, __an);
      }
      template < typename _InputIterator >
      void _M_insert_unique(_InputIterator __first, _InputIterator __last);
      template < typename _InputIterator >
      void _M_insert_equal(_InputIterator __first, _InputIterator __last);
    private:
      void _M_erase_aux(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position);
      void _M_erase_aux(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __first, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __last);
    public:
      inline void erase(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __position)
      {
        ;
        (*this)._M_erase_aux(__position);
      }
      inline void erase(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position)
      {
        ;
        (*this)._M_erase_aux(__position);
      }
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type erase(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__x);
      inline void erase(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __first, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __last)
      {
        (*this)._M_erase_aux(__first, __last);
      }
      inline void erase(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __first, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __last)
      {
        (*this)._M_erase_aux(__first, __last);
      }
      void erase(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type *__first, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type *__last);
      inline void clear()
      {
        (*this)._M_erase((*this)._M_begin());
        ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_reset();
      }
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator find(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k);
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator find(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k) const ;
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type count(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k) const ;
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator lower_bound(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k)
      {
        return (*this)._M_lower_bound((*this)._M_begin(), (*this)._M_end(), __k);
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator lower_bound(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k) const 
      {
        return (*this)._M_lower_bound((*this)._M_begin(), (*this)._M_end(), __k);
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator upper_bound(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k)
      {
        return (*this)._M_upper_bound((*this)._M_begin(), (*this)._M_end(), __k);
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator upper_bound(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k) const 
      {
        return (*this)._M_upper_bound((*this)._M_begin(), (*this)._M_end(), __k);
      }
      ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator> equal_range(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k);
      ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator> equal_range(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k) const ;
      bool __rb_verify() const ;
  };
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator ==(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator ==(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y)
  {
    return __x.size() == __y.size() && std::equal(__x.begin(), __x.end(), __y.begin());
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator <(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator <(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y)
  {
    return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator !=(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator !=(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y)
  {
    return !(__x == __y);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator >(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator >(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y)
  {
    return __y < __x;
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator <=(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator <=(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator >=(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator >=(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline void swap(::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline void swap(::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y)
  {
    __x.swap(__y);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::operator =(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x)
  {
    if (this != &__x)
      {
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node __roan(*this);
        ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_reset();
        ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare = __x._M_impl._M_key_compare;
        if (__x._M_root() != 0)
          {
            (*this)._M_root() = (*this)._M_copy(__x, __roan);
          }
      }
    return *this;
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  template < typename _NodeGen >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __p, const _Val &__v, _NodeGen &__node_gen)
  {
    bool __insert_left = (__x != 0 || __p == (*this)._M_end()) || ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__p));
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __z = __node_gen(__v);
    _Rb_tree_insert_and_rebalance(__insert_left, __z, __p, this->_M_impl._M_header);
     ++::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_node_count;
    return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(__z)));
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_lower(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __p, const _Val &__v)
  {
    bool __insert_left = __p == (*this)._M_end() || !::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(__p), _KeyOfValue()(__v));
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __z = (*this)._M_create_node(__v);
    _Rb_tree_insert_and_rebalance(__insert_left, __z, __p, this->_M_impl._M_header);
     ++::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_node_count;
    return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(__z)));
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_equal_lower(const _Val &__v)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x = (*this)._M_begin();
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __y = (*this)._M_end();
    while (__x != 0)
      {
        __y = __x;
        __x = !::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ? _S_left(__x) : _S_right(__x);
      }
    return (*this)._M_insert_lower(__y, __v);
  }
  template < typename _Key, typename _Val, typename _KoV, typename _Compare, typename _Alloc >
  template < typename _NodeGen >
  typename ::std::_Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_M_copy(typename ::std::_Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Const_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Base_ptr __p, _NodeGen &__node_gen)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type __top = (*this)._M_clone_node(__x, __node_gen);
    __top->_M_parent = __p;
    try
    {
      if (__x->_M_right)
        {
          __top->_M_right = (*this)._M_copy(_S_right(__x), __top, __node_gen);
        }
      __p = __top;
      __x = _S_left(__x);
      while (__x != 0)
        {
          typename ::std::_Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type __y = (*this)._M_clone_node(__x, __node_gen);
          (*__p)._M_left = __y;
          __y->_M_parent = __p;
          if (__x->_M_right)
            {
              __y->_M_right = (*this)._M_copy(_S_right(__x), __y, __node_gen);
            }
          __p = __y;
          __x = _S_left(__x);
        }
    }
    catch (...)
    {
      (*this)._M_erase(__top);
      throw;
    }
    return __top;
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  void _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_erase(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x)
  {
    while (__x != 0)
      {
        (*this)._M_erase(_S_right(__x));
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __y = _S_left(__x);
        (*this)._M_drop_node(__x);
        __x = __y;
      }
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_lower_bound(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __y, const _Key &__k)
  {
    while (__x != 0)
      {
        if (!::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(__x), __k))
          {
            (__y = __x, __x = _S_left(__x));
          }
        else
          {
            __x = _S_right(__x);
          }
      }
    return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(__y)));
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_lower_bound(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __y, const _Key &__k) const 
  {
    while (__x != 0)
      {
        if (!::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(__x), __k))
          {
            (__y = __x, __x = _S_left(__x));
          }
        else
          {
            __x = _S_right(__x);
          }
      }
    return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator(__y)));
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_upper_bound(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __y, const _Key &__k)
  {
    while (__x != 0)
      {
        if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(__k, _S_key(__x)))
          {
            (__y = __x, __x = _S_left(__x));
          }
        else
          {
            __x = _S_right(__x);
          }
      }
    return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(__y)));
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_upper_bound(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __y, const _Key &__k) const 
  {
    while (__x != 0)
      {
        if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(__k, _S_key(__x)))
          {
            (__y = __x, __x = _S_left(__x));
          }
        else
          {
            __x = _S_right(__x);
          }
      }
    return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator(__y)));
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator> _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::equal_range(const _Key &__k)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x = (*this)._M_begin();
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __y = (*this)._M_end();
    while (__x != 0)
      {
        if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(__x), __k))
          {
            __x = _S_right(__x);
          }
        else
          {
            if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(__k, _S_key(__x)))
              {
                (__y = __x, __x = _S_left(__x));
              }
            else
              {
                typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __xu(__x);
                typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __yu(__y);
                (__y = __x, __x = _S_left(__x));
                __xu = _S_right(__xu);
                return ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator>((*this)._M_lower_bound(__x, __y, __k), (*this)._M_upper_bound(__xu, __yu, __k));
              }
          }
      }
    return ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator>(((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(__y))), ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(__y))));
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator> _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::equal_range(const _Key &__k) const 
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x = (*this)._M_begin();
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __y = (*this)._M_end();
    while (__x != 0)
      {
        if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(__x), __k))
          {
            __x = _S_right(__x);
          }
        else
          {
            if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(__k, _S_key(__x)))
              {
                (__y = __x, __x = _S_left(__x));
              }
            else
              {
                typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __xu(__x);
                typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __yu(__y);
                (__y = __x, __x = _S_left(__x));
                __xu = _S_right(__xu);
                return ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator>((*this)._M_lower_bound(__x, __y, __k), (*this)._M_upper_bound(__xu, __yu, __k));
              }
          }
      }
    return ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator>(((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator(__y))), ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator(__y))));
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  void _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::swap(::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__t)
  {
    if ((*this)._M_root() == 0)
      {
        if (__t._M_root() != 0)
          {
            ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_move_data(__t._M_impl);
          }
      }
    else
      {
        if (__t._M_root() == 0)
          {
            __t._M_impl._M_move_data(::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl);
          }
        else
          {
            std::swap((*this)._M_root(), __t._M_root());
            std::swap((*this)._M_leftmost(), __t._M_leftmost());
            std::swap((*this)._M_rightmost(), __t._M_rightmost());
            (*this)._M_root()->_M_parent = (*this)._M_end();
            __t._M_root()->_M_parent = __t._M_end();
            std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
          }
      }
    std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);
    _Alloc_traits::_S_on_swap((*this)._M_get_Node_allocator(), __t._M_get_Node_allocator());
  }
 /* Instantiation of class template '::std::__pair_base< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *>' */ 
 /* Instantiation of class template '::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *>' */ 
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_get_insert_unique_pos(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k)
  {
    typedef ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> _Res;
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x = (*this)._M_begin();
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __y = (*this)._M_end();
    bool __comp(true);
    while (__x != 0)
      {
        __y = __x;
        __comp = ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(__k, _S_key(__x));
        __x = __comp ? _S_left(__x) : _S_right(__x);
      }
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __j = ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(__y)));
    if (__comp)
      {
        if (__j == (*this).begin())
          {
            return _Res(__x, __y);
          }
        else
          {
             --__j;
          }
      }
    if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(__j._M_node), __k))
      {
        return _Res(__x, __y);
      }
    return _Res(__j._M_node, 0);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_get_insert_equal_pos(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k)
  {
    typedef ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> _Res;
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x = (*this)._M_begin();
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __y = (*this)._M_end();
    while (__x != 0)
      {
        __y = __x;
        __x = ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(__k, _S_key(__x)) ? _S_left(__x) : _S_right(__x);
      }
    return _Res(__x, __y);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, bool> _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_unique(const _Val &__v)
  {
    typedef ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, bool> _Res;
    ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> __res = (*this)._M_get_insert_unique_pos(_KeyOfValue()(__v));
    if (__res.second)
      {
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Alloc_node __an(*this);
        return _Res((*this)._M_insert_(__res.first, __res.second, __v, __an), true);
      }
    return _Res(((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(__res.first))), false);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_equal(const _Val &__v)
  {
    ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> __res = (*this)._M_get_insert_equal_pos(_KeyOfValue()(__v));
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Alloc_node __an(*this);
    return (*this)._M_insert_(__res.first, __res.second, __v, __an);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_get_insert_hint_unique_pos(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __pos = __position._M_const_cast();
    typedef ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> _Res;
    if (__pos._M_node == (*this)._M_end())
      {
        if ((*this).size() > 0 && ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key((*this)._M_rightmost()), __k))
          {
            return _Res(0, (*this)._M_rightmost());
          }
        else
          {
            return (*this)._M_get_insert_unique_pos(__k);
          }
      }
    else
      {
        if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(__k, _S_key(__pos._M_node)))
          {
            typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __before = __pos;
            if (__pos._M_node == (*this)._M_leftmost())
              {
                return _Res((*this)._M_leftmost(), (*this)._M_leftmost());
              }
            else
              {
                if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(( --__before)._M_node), __k))
                  {
                    if (_S_right(__before._M_node) == 0)
                      {
                        return _Res(0, __before._M_node);
                      }
                    else
                      {
                        return _Res(__pos._M_node, __pos._M_node);
                      }
                  }
                else
                  {
                    return (*this)._M_get_insert_unique_pos(__k);
                  }
              }
          }
        else
          {
            if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
              {
                typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __after = __pos;
                if (__pos._M_node == (*this)._M_rightmost())
                  {
                    return _Res(0, (*this)._M_rightmost());
                  }
                else
                  {
                    if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(__k, _S_key(( ++__after)._M_node)))
                      {
                        if (_S_right(__pos._M_node) == 0)
                          {
                            return _Res(0, __pos._M_node);
                          }
                        else
                          {
                            return _Res(__after._M_node, __after._M_node);
                          }
                      }
                    else
                      {
                        return (*this)._M_get_insert_unique_pos(__k);
                      }
                  }
              }
            else
              {
                return _Res(__pos._M_node, 0);
              }
          }
      }
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  template < typename _NodeGen >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_unique_(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position, const _Val &__v, _NodeGen &__node_gen)
  {
    ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> __res = (*this)._M_get_insert_hint_unique_pos(__position, _KeyOfValue()(__v));
    if (__res.second)
      {
        return (*this)._M_insert_(__res.first, __res.second, __v, __node_gen);
      }
    return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(__res.first)));
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_get_insert_hint_equal_pos(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __pos = __position._M_const_cast();
    typedef ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> _Res;
    if (__pos._M_node == (*this)._M_end())
      {
        if ((*this).size() > 0 && !::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(__k, _S_key((*this)._M_rightmost())))
          {
            return _Res(0, (*this)._M_rightmost());
          }
        else
          {
            return (*this)._M_get_insert_equal_pos(__k);
          }
      }
    else
      {
        if (!::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
          {
            typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __before = __pos;
            if (__pos._M_node == (*this)._M_leftmost())
              {
                return _Res((*this)._M_leftmost(), (*this)._M_leftmost());
              }
            else
              {
                if (!::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(__k, _S_key(( --__before)._M_node)))
                  {
                    if (_S_right(__before._M_node) == 0)
                      {
                        return _Res(0, __before._M_node);
                      }
                    else
                      {
                        return _Res(__pos._M_node, __pos._M_node);
                      }
                  }
                else
                  {
                    return (*this)._M_get_insert_equal_pos(__k);
                  }
              }
          }
        else
          {
            typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __after = __pos;
            if (__pos._M_node == (*this)._M_rightmost())
              {
                return _Res(0, (*this)._M_rightmost());
              }
            else
              {
                if (!::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(( ++__after)._M_node), __k))
                  {
                    if (_S_right(__pos._M_node) == 0)
                      {
                        return _Res(0, __pos._M_node);
                      }
                    else
                      {
                        return _Res(__after._M_node, __after._M_node);
                      }
                  }
                else
                  {
                    return ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *>(0, 0);
                  }
              }
          }
      }
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  template < typename _NodeGen >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_equal_(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position, const _Val &__v, _NodeGen &__node_gen)
  {
    ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> __res = (*this)._M_get_insert_hint_equal_pos(__position, _KeyOfValue()(__v));
    if (__res.second)
      {
        return (*this)._M_insert_(__res.first, __res.second, __v, __node_gen);
      }
    return (*this)._M_insert_equal_lower(__v);
  }
  template < typename _Key, typename _Val, typename _KoV, typename _Cmp, typename _Alloc >
  template < typename _II >
  void _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::_M_insert_unique(_II __first, _II __last)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::_Alloc_node __an(*this);
    for (; __first != __last;  ++__first)
      {
        (*this)._M_insert_unique_((*this).end(), *__first, __an);
      }
  }
  template < typename _Key, typename _Val, typename _KoV, typename _Cmp, typename _Alloc >
  template < typename _II >
  void _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::_M_insert_equal(_II __first, _II __last)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::_Alloc_node __an(*this);
    for (; __first != __last;  ++__first)
      {
        (*this)._M_insert_equal_((*this).end(), *__first, __an);
      }
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  void _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_erase_aux(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __y = static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type>(_Rb_tree_rebalance_for_erase(const_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr>(__position._M_node), this->_M_impl._M_header));
    (*this)._M_drop_node(__y);
     --::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_node_count;
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  void _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_erase_aux(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __first, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __last)
  {
    if (__first == (*this).begin() && __last == (*this).end())
      {
        (*this).clear();
      }
    else
      {
        while (__first != __last)
          {
            (*this)._M_erase_aux(__first++);
          }
      }
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::erase(const _Key &__x)
  {
    ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator> __p = (*this).equal_range(__x);
    const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type __old_size = (*this).size();
    (*this)._M_erase_aux(__p.first, __p.second);
    return __old_size - (*this).size();
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  void _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::erase(const _Key *__first, const _Key *__last)
  {
    while (__first != __last)
      {
        (*this).erase(*__first++);
      }
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::find(const _Key &__k)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __j = (*this)._M_lower_bound((*this)._M_begin(), (*this)._M_end(), __k);
    return __j == (*this).end() || ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(__k, _S_key(__j._M_node)) ? (*this).end() : __j;
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::find(const _Key &__k) const 
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __j = (*this)._M_lower_bound((*this)._M_begin(), (*this)._M_end(), __k);
    return __j == (*this).end() || ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(__k, _S_key(__j._M_node)) ? (*this).end() : __j;
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::count(const _Key &__k) const 
  {
    ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator> __p = (*this).equal_range(__k);
    const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type __n = std::distance(__p.first, __p.second);
    return __n;
  }
  unsigned int _Rb_tree_black_count(const ::std::_Rb_tree_node_base *__node, const ::std::_Rb_tree_node_base *__root) throw() __attribute__((__pure__));
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  bool _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::__rb_verify() const 
  {
    if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_node_count == 0 || (*this).begin() == (*this).end())
      {
        return ((::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_node_count == 0 && (*this).begin() == (*this).end()) && this->_M_impl._M_header._M_left == (*this)._M_end()) && this->_M_impl._M_header._M_right == (*this)._M_end();
      }
    unsigned int __len = _Rb_tree_black_count((*this)._M_leftmost(), (*this)._M_root());
    for (typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __it = (*this).begin(); __it != (*this).end();  ++__it)
      {
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x = static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type>(__it._M_node);
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __L = _S_left(__x);
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __R = _S_right(__x);
        if (__x->_M_color == ::std::_S_red)
          {
            if ((__L && __L->_M_color == ::std::_S_red) || (__R && __R->_M_color == ::std::_S_red))
              {
                return false;
              }
          }
        if (__L && ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
          {
            return false;
          }
        if (__R && ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
          {
            return false;
          }
        if ((!__L && !__R) && _Rb_tree_black_count(__x, (*this)._M_root()) != __len)
          {
            return false;
          }
      }
    if ((*this)._M_leftmost() != _Rb_tree_node_base::_S_minimum((*this)._M_root()))
      {
        return false;
      }
    if ((*this)._M_rightmost() != _Rb_tree_node_base::_S_maximum((*this)._M_root()))
      {
        return false;
      }
    return true;
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  class multimap;
  template < typename _Key, typename _Tp, typename _Compare = ::std::less<_Key>, typename _Alloc = ::std::allocator< ::std::pair<const _Key, _Tp> > >
  class  map
  {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef ::std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;
      class  value_compare : public ::std::binary_function<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type, bool>
      {
        protected:
          _Compare comp;
          inline value_compare(_Compare __c)
            : comp(__c)
          {
          }
        public:
          inline bool operator ()(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type &__x, const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type &__y) const 
          {
            return ::std::map<_Key, _Tp, _Compare, _Alloc>::value_compare::comp(__x.first, __y.first);
          }
        friend class ::std::map<_Key, _Tp, _Compare, _Alloc>;
      };
    private:
      typedef typename ::__gnu_cxx::__alloc_traits<_Alloc>::template rebind< typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type>::other _Pair_alloc_type;
      typedef ::std::_Rb_tree<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type> _Rep_type;
      typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Rep_type _M_t;
      typedef ::__gnu_cxx::__alloc_traits<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type> _Alloc_traits;
    public:
      typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::pointer pointer;
      typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::const_pointer const_pointer;
      typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::reference reference;
      typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::const_reference const_reference;
      typedef typename ::std::_Rb_tree<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::iterator iterator;
      typedef typename ::std::_Rb_tree<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::const_iterator const_iterator;
      typedef typename ::std::_Rb_tree<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::size_type size_type;
      typedef typename ::std::_Rb_tree<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::difference_type difference_type;
      typedef typename ::std::_Rb_tree<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::reverse_iterator reverse_iterator;
      typedef typename ::std::_Rb_tree<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::const_reverse_iterator const_reverse_iterator;
      inline map()
        : _M_t()
      {
      }
      inline explicit map(const _Compare &__comp, const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::allocator_type &__a  = (((typename ::std::map<_Key, _Tp, _Compare, _Alloc>::allocator_type()))))
        : _M_t(__comp, ((typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type(__a))))
      {
      }
      inline map(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x)
        : _M_t(__x._M_t)
      {
      }
      template < typename _InputIterator >
      inline map(_InputIterator __first, _InputIterator __last)
        : _M_t()
      {
        ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t._M_insert_unique(__first, __last);
      }
      template < typename _InputIterator >
      inline map(_InputIterator __first, _InputIterator __last, const _Compare &__comp, const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::allocator_type &__a  = (((typename ::std::map<_Key, _Tp, _Compare, _Alloc>::allocator_type()))))
        : _M_t(__comp, ((typename ::std::map<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type(__a))))
      {
        ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t._M_insert_unique(__first, __last);
      }
      inline ::std::map<_Key, _Tp, _Compare, _Alloc> &operator =(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x)
      {
        ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t = __x._M_t;
        return *this;
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::allocator_type get_allocator() const 
      {
        return ((typename ::std::map<_Key, _Tp, _Compare, _Alloc>::allocator_type(::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.get_allocator())));
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator begin()
      {
        return ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.begin();
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::const_iterator begin() const 
      {
        return ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.begin();
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator end()
      {
        return ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.end();
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::const_iterator end() const 
      {
        return ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.end();
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::reverse_iterator rbegin()
      {
        return ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.rbegin();
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::const_reverse_iterator rbegin() const 
      {
        return ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.rbegin();
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::reverse_iterator rend()
      {
        return ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.rend();
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::const_reverse_iterator rend() const 
      {
        return ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.rend();
      }
      inline bool empty() const 
      {
        return ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.empty();
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::size_type size() const 
      {
        return ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.size();
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::size_type max_size() const 
      {
        return ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.max_size();
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type &operator [](const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__k)
      {
        typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator __i = (*this).lower_bound(__k);
        if (__i == (*this).end() || (*this).key_comp()(__k, (*__i).first))
          {
            __i = (*this).insert(__i, ((typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type(__k, ((typename ::std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type()))))));
          }
        return (*__i).second;
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type &at(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__k)
      {
        typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator __i = (*this).lower_bound(__k);
        if (__i == (*this).end() || (*this).key_comp()(__k, (*__i).first))
          {
            ::std::__throw_out_of_range("map::at");
          }
        return (*__i).second;
      }
      inline const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type &at(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__k) const 
      {
        typename ::std::map<_Key, _Tp, _Compare, _Alloc>::const_iterator __i = (*this).lower_bound(__k);
        if (__i == (*this).end() || (*this).key_comp()(__k, (*__i).first))
          {
            ::std::__throw_out_of_range("map::at");
          }
        return (*__i).second;
      }
      inline ::std::pair<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator, bool> insert(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type &__x)
      {
        return ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t._M_insert_unique(__x);
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator insert(typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator __position, const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_type &__x)
      {
        return ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t._M_insert_unique_(__position, __x);
      }
      template < typename _InputIterator >
      inline void insert(_InputIterator __first, _InputIterator __last)
      {
        ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t._M_insert_unique(__first, __last);
      }
      inline void erase(typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator __position)
      {
        ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.erase(__position);
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::size_type erase(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__x)
      {
        return ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.erase(__x);
      }
      inline void erase(typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator __first, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator __last)
      {
        ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.erase(__first, __last);
      }
      inline void swap(::std::map<_Key, _Tp, _Compare, _Alloc> &__x)
      {
        ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.swap(__x._M_t);
      }
      inline void clear()
      {
        ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.clear();
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_compare key_comp() const 
      {
        return ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.key_comp();
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_compare value_comp() const 
      {
        return ((typename ::std::map<_Key, _Tp, _Compare, _Alloc>::value_compare(::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.key_comp())));
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator find(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__x)
      {
        return ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.find(__x);
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::const_iterator find(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__x) const 
      {
        return ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.find(__x);
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::size_type count(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__x) const 
      {
        return ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.find(__x) == ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.end() ? 0 : 1;
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator lower_bound(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__x)
      {
        return ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.lower_bound(__x);
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::const_iterator lower_bound(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__x) const 
      {
        return ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.lower_bound(__x);
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator upper_bound(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__x)
      {
        return ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.upper_bound(__x);
      }
      inline typename ::std::map<_Key, _Tp, _Compare, _Alloc>::const_iterator upper_bound(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__x) const 
      {
        return ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.upper_bound(__x);
      }
      inline ::std::pair<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::iterator> equal_range(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__x)
      {
        return ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.equal_range(__x);
      }
      inline ::std::pair<typename ::std::map<_Key, _Tp, _Compare, _Alloc>::const_iterator, typename ::std::map<_Key, _Tp, _Compare, _Alloc>::const_iterator> equal_range(const typename ::std::map<_Key, _Tp, _Compare, _Alloc>::key_type &__x) const 
      {
        return ::std::map<_Key, _Tp, _Compare, _Alloc>::_M_t.equal_range(__x);
      }
    template < typename _K1, typename _T1, typename _C1, typename _A1 >
    friend bool operator ==(const ::std::map<_K1, _T1, _C1, _A1> &, const ::std::map<_K1, _T1, _C1, _A1> &);
    template < typename _K1, typename _T1, typename _C1, typename _A1 >
    friend bool operator <(const ::std::map<_K1, _T1, _C1, _A1> &, const ::std::map<_K1, _T1, _C1, _A1> &);
  };
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator ==(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::map<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator ==(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::map<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    return __x._M_t == __y._M_t;
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator <(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::map<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator <(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::map<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    return __x._M_t < __y._M_t;
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator !=(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::map<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator !=(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::map<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    return !(__x == __y);
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator >(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::map<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator >(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::map<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    return __y < __x;
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator <=(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::map<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator <=(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::map<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator >=(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::map<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator >=(const ::std::map<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::map<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline void swap(::std::map<_Key, _Tp, _Compare, _Alloc> &__x, ::std::map<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline void swap(::std::map<_Key, _Tp, _Compare, _Alloc> &__x, ::std::map<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    __x.swap(__y);
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  class map;
  template < typename _Key, typename _Tp, typename _Compare = ::std::less<_Key>, typename _Alloc = ::std::allocator< ::std::pair<const _Key, _Tp> > >
  class  multimap
  {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef ::std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;
      class  value_compare : public ::std::binary_function<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type, bool>
      {
        protected:
          _Compare comp;
          inline value_compare(_Compare __c)
            : comp(__c)
          {
          }
        public:
          inline bool operator ()(const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type &__x, const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type &__y) const 
          {
            return ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_compare::comp(__x.first, __y.first);
          }
        friend class ::std::multimap<_Key, _Tp, _Compare, _Alloc>;
      };
    private:
      typedef typename ::__gnu_cxx::__alloc_traits<_Alloc>::template rebind< typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type>::other _Pair_alloc_type;
      typedef ::std::_Rb_tree<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type> _Rep_type;
      typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Rep_type _M_t;
      typedef ::__gnu_cxx::__alloc_traits<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type> _Alloc_traits;
    public:
      typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::pointer pointer;
      typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::const_pointer const_pointer;
      typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::reference reference;
      typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::const_reference const_reference;
      typedef typename ::std::_Rb_tree<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::iterator iterator;
      typedef typename ::std::_Rb_tree<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::const_iterator const_iterator;
      typedef typename ::std::_Rb_tree<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::size_type size_type;
      typedef typename ::std::_Rb_tree<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::difference_type difference_type;
      typedef typename ::std::_Rb_tree<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::reverse_iterator reverse_iterator;
      typedef typename ::std::_Rb_tree<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type, ::std::_Select1st<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type>, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_compare, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type>::const_reverse_iterator const_reverse_iterator;
      inline multimap()
        : _M_t()
      {
      }
      inline explicit multimap(const _Compare &__comp, const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::allocator_type &__a  = (((typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::allocator_type()))))
        : _M_t(__comp, ((typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type(__a))))
      {
      }
      inline multimap(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x)
        : _M_t(__x._M_t)
      {
      }
      template < typename _InputIterator >
      inline multimap(_InputIterator __first, _InputIterator __last)
        : _M_t()
      {
        ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t._M_insert_equal(__first, __last);
      }
      template < typename _InputIterator >
      inline multimap(_InputIterator __first, _InputIterator __last, const _Compare &__comp, const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::allocator_type &__a  = (((typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::allocator_type()))))
        : _M_t(__comp, ((typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_Pair_alloc_type(__a))))
      {
        ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t._M_insert_equal(__first, __last);
      }
      inline ::std::multimap<_Key, _Tp, _Compare, _Alloc> &operator =(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x)
      {
        ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t = __x._M_t;
        return *this;
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::allocator_type get_allocator() const 
      {
        return ((typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::allocator_type(::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.get_allocator())));
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator begin()
      {
        return ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.begin();
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::const_iterator begin() const 
      {
        return ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.begin();
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator end()
      {
        return ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.end();
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::const_iterator end() const 
      {
        return ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.end();
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::reverse_iterator rbegin()
      {
        return ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.rbegin();
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::const_reverse_iterator rbegin() const 
      {
        return ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.rbegin();
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::reverse_iterator rend()
      {
        return ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.rend();
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::const_reverse_iterator rend() const 
      {
        return ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.rend();
      }
      inline bool empty() const 
      {
        return ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.empty();
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::size_type size() const 
      {
        return ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.size();
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::size_type max_size() const 
      {
        return ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.max_size();
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator insert(const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type &__x)
      {
        return ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t._M_insert_equal(__x);
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator insert(typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator __position, const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_type &__x)
      {
        return ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t._M_insert_equal_(__position, __x);
      }
      template < typename _InputIterator >
      inline void insert(_InputIterator __first, _InputIterator __last)
      {
        ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t._M_insert_equal(__first, __last);
      }
      inline void erase(typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator __position)
      {
        ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.erase(__position);
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::size_type erase(const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type &__x)
      {
        return ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.erase(__x);
      }
      inline void erase(typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator __first, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator __last)
      {
        ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.erase(__first, __last);
      }
      inline void swap(::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x)
      {
        ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.swap(__x._M_t);
      }
      inline void clear()
      {
        ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.clear();
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_compare key_comp() const 
      {
        return ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.key_comp();
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_compare value_comp() const 
      {
        return ((typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::value_compare(::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.key_comp())));
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator find(const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type &__x)
      {
        return ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.find(__x);
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::const_iterator find(const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type &__x) const 
      {
        return ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.find(__x);
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::size_type count(const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type &__x) const 
      {
        return ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.count(__x);
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator lower_bound(const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type &__x)
      {
        return ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.lower_bound(__x);
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::const_iterator lower_bound(const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type &__x) const 
      {
        return ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.lower_bound(__x);
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator upper_bound(const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type &__x)
      {
        return ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.upper_bound(__x);
      }
      inline typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::const_iterator upper_bound(const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type &__x) const 
      {
        return ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.upper_bound(__x);
      }
      inline ::std::pair<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::iterator> equal_range(const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type &__x)
      {
        return ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.equal_range(__x);
      }
      inline ::std::pair<typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::const_iterator, typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::const_iterator> equal_range(const typename ::std::multimap<_Key, _Tp, _Compare, _Alloc>::key_type &__x) const 
      {
        return ::std::multimap<_Key, _Tp, _Compare, _Alloc>::_M_t.equal_range(__x);
      }
    template < typename _K1, typename _T1, typename _C1, typename _A1 >
    friend bool operator ==(const ::std::multimap<_K1, _T1, _C1, _A1> &, const ::std::multimap<_K1, _T1, _C1, _A1> &);
    template < typename _K1, typename _T1, typename _C1, typename _A1 >
    friend bool operator <(const ::std::multimap<_K1, _T1, _C1, _A1> &, const ::std::multimap<_K1, _T1, _C1, _A1> &);
  };
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator ==(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator ==(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    return __x._M_t == __y._M_t;
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator <(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator <(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    return __x._M_t < __y._M_t;
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator !=(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator !=(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    return !(__x == __y);
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator >(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator >(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    return __y < __x;
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator <=(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator <=(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator >=(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline bool operator >=(const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, const ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline void swap(::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
  inline void swap(::std::multimap<_Key, _Tp, _Compare, _Alloc> &__x, ::std::multimap<_Key, _Tp, _Compare, _Alloc> &__y)
  {
    __x.swap(__y);
  }
}
using namespace ::std;
class  AbstractBlockPruning
{
  public:
    AbstractBlockPruning();
    virtual ~AbstractBlockPruning();
    void updateBestScore(int score);
    const ::Grid *getGrid() const ;
    void setGrid(const ::Grid *grid);
    void setSuperPartition(::Partition superPartition);
    void setScoreParams(const ::score_params_t *score_params);
    void setLocalAlignment();
    void setGlobalAlignment();
    int getRecurrenceType() const ;
    void setRecurrenceType(int recurrenceType);
  protected:
    bool isBlockPrunable(int bx, int by, int score);
  private:
    const ::score_params_t *score_params;
    int max_i;
    int max_j;
    int bestScore;
    int recurrenceType;
    const ::Grid *grid;
    virtual void initialize() = 0 ;
    virtual void finalize() = 0 ;
  public:
};
class  AbstractAligner : public ::IAligner
{
  public:
    AbstractAligner();
    virtual ~AbstractAligner();
    virtual void setManager(::IManager *manager);
    virtual const int *getForkWeights();
    virtual ::match_result_t matchLastColumn(const ::cell_t *buffer, const ::cell_t *base, int len, int goalScore);
  protected:
    void setForkCount(const int forkCount, const int *forkWeights  = (0L));
    ::Grid *createGrid(::Partition partition);
    virtual const ::Grid *getGrid() const ;
    void initializeBlockPruning(::AbstractBlockPruning *blockPruner);
    int getRecurrenceType() const ;
    int getSpecialRowInterval() const ;
    int getSpecialColumnInterval() const ;
    int getFirstColumnInitType();
    ::Partition getSuperPartition();
    int getFirstRowInitType();
    void receiveFirstRow(::cell_t *buffer, int len);
    void receiveFirstColumn(::cell_t *buffer, int len);
    void dispatchColumn(int j, const ::cell_t *buffer, int len);
    void dispatchRow(int i, const ::cell_t *buffer, int len);
    void dispatchScore(::score_t score, int bx  = ( -1), int by  = ( -1));
    bool mustContinue();
    bool mustDispatchLastCell();
    bool mustDispatchLastRow();
    bool mustDispatchLastColumn();
    bool mustDispatchSpecialRows();
    bool mustDispatchSpecialColumns();
    bool mustDispatchScores();
    bool mustPruneBlocks();
    ::cell_t getFirstColumnTail() const ;
    ::cell_t getFirstRowTail() const ;
  private:
    ::IManager *manager;
    int *forkWeights;
    int forkCount;
    ::Grid *grid;
    ::cell_t firstColumnTail;
    ::cell_t firstRowTail;
  public:
};
class  BlockAlignerParameters : public ::AbstractAlignerParameters
{
    int gridWidth;
    int gridHeight;
    int blockHeight;
    int blockWidth;
  public:
    BlockAlignerParameters();
    virtual ~BlockAlignerParameters();
    virtual int processArgument(int argc, char **argv);
    virtual void printUsage() const ;
    int getBlockHeight() const ;
    int getBlockWidth() const ;
    int getGridWidth() const ;
    int getGridHeight() const ;
};
class  AbstractBlockProcessor
{
  public:
    AbstractBlockProcessor();
    virtual ~AbstractBlockProcessor();
    virtual void setSequences(const char *seq0, const char *seq1, int seq0_len, int seq1_len) = 0 ;
    virtual void unsetSequences() = 0 ;
    virtual ::score_t processBlock(::cell_t *row, ::cell_t *col, const int i0, const int j0, const int i1, const int j1, const int recurrenceType) = 0 ;
};
class  BlockPruningGenericN2 : public ::AbstractBlockPruning
{
  public:
    BlockPruningGenericN2();
    virtual ~BlockPruningGenericN2();
    virtual void pruningUpdate(int bx, int by, int score);
    virtual bool isBlockPruned(int bx, int by);
  private:
    int **k;
    int gridHeight;
    int gridWidth;
    virtual void initialize();
    virtual void finalize();
  public:
};
class  AbstractBlockAligner : public ::AbstractAligner
{
  public:
    AbstractBlockAligner(::AbstractBlockProcessor *blockProcessor  = (0L), ::BlockAlignerParameters *params  = (0L));
    virtual ~AbstractBlockAligner();
    virtual void initialize();
    virtual void alignPartition(::Partition partition);
    virtual void finalize();
    virtual ::aligner_capabilities_t getCapabilities();
    virtual const ::score_params_t *getScoreParameters();
    virtual ::IAlignerParameters *getParameters();
    virtual void setSequences(const char *seq0, const char *seq1, int seq0_len, int seq1_len);
    virtual void unsetSequences();
    virtual void clearStatistics();
    virtual void printInitialStatistics(::FILE *file);
    virtual void printStageStatistics(::FILE *file);
    virtual void printFinalStatistics(::FILE *file);
    virtual void printStatistics(::FILE *file);
    virtual const char *getProgressString() const ;
    virtual long long int getProcessedCells();
  protected:
    ::cell_t **row;
    ::cell_t **col;
    virtual void scheduleBlocks(int grid_width, int grid_height) = 0 ;
    virtual void alignBlock(int bx, int by, int i0, int j0, int i1, int j1) = 0 ;
    void ignoreBlock(int bx, int by);
    bool isBlockPruned(int bx, int by) const ;
    virtual void increaseBlockStat(const bool pruned);
    void alignBlock(int bx, int by);
    bool processBlock(int bx, int by, int i0, int j0, int i1, int j1);
    bool isSpecialRow(int by);
    bool isSpecialColumn(int by);
    void setPreferredSizes(int preferredBlockSize, int preferredGridSize);
    virtual void allocateStructures();
    virtual void deallocateStructures();
  private:
    ::BlockAlignerParameters *params;
    ::score_t **grid_scores;
    ::AbstractBlockProcessor *blockProcessor;
    ::BlockPruningGenericN2 *blockPruner;
    int preferredBlockSize;
    int preferredGridSize;
    int statMinBlockWidth;
    int statMaxBlockWidth;
    int statMinBlockHeight;
    int statMaxBlockHeight;
    int statMinGridWidth;
    int statMaxGridWidth;
    int statMinGridHeight;
    int statMaxGridHeight;
    int statTotalBlocks;
    int statPrunedBlocks;
    ::score_params_t score_params;
    ::Grid *configureGrid(::Partition partition);
    void pruningUpdate(int bx, int by, int score);
  public:
};
class BlockPruningDiagonal;
class  BlockPruningDiagonal : public ::AbstractBlockPruning
{
  public:
    virtual ~BlockPruningDiagonal();
    BlockPruningDiagonal();
    virtual void initialize();
    virtual void finalize();
    void updatePruningWindow(int diagonal, const ::score_t *block_scores);
    void getNonPrunableWindow(int *start, int *end);
  private:
    int windowStart;
    int windowEnd;
  public:
};
class  AbstractDiagonalAligner : public ::AbstractAligner
{
  public:
    AbstractDiagonalAligner();
    virtual ~AbstractDiagonalAligner();
    virtual void alignPartition(::Partition partition);
    virtual void clearStatistics();
    virtual void printInitialStatistics(::FILE *file);
    virtual void printStageStatistics(::FILE *file);
    virtual void printFinalStatistics(::FILE *file);
    virtual void printStatistics(::FILE *file);
    virtual long long int getProcessedCells();
    virtual const char *getProgressString() const ;
  protected:
    virtual int getGridWidth(int width) = 0 ;
    virtual int getBlockHeight() = 0 ;
    virtual const ::cell_t *getSpecialRow(int j, int len) = 0 ;
    virtual const ::cell_t *getLastRow(int j, int len) = 0 ;
    virtual const ::cell_t *getLastColumn(int i, int len) = 0 ;
    virtual const ::score_t *getBlockScores() = 0 ;
    virtual void setFirstRow(const ::cell_t *cells, int j, int len) = 0 ;
    virtual void setFirstColumn(const ::cell_t *cells, int i, int len) = 0 ;
    virtual void clearPrunedBlocks(int b0, int b1) = 0 ;
    virtual void initializeDiagonals() = 0 ;
    virtual void processDiagonal(int diagonal, int windowLeft, int windowRight) = 0 ;
    virtual void finalizeDiagonals() = 0 ;
    ::Partition getPartition() const ;
  private:
    ::cell_t *h_loadColumn;
    int gridWidth;
    int gridHeight;
    int externalDiagonalCount;
    int currentExternalDiagonal;
    ::Partition partition;
    ::BlockPruningDiagonal *pruner;
    int windowStart;
    int windowEnd;
    int statTotalBlocks;
    int statPrunedBlocksLeft;
    int statPrunedBlocksRight;
    long long int statTotalCells;
    int statMinGridWidth;
    int statMaxGridWidth;
    ::Grid *configureGrid(::Partition partition);
    void prepareIterations();
    void processNextIteration();
    bool hasMoreIterations();
    void finalizeIterations();
    void flushSpecialRows();
    void flushLastRow();
    void flushLastColumn();
    void flushLastCell();
    void flushBlockScores();
    void loadFirstRow();
    void loadFirstColumn();
    bool isSpecialRow(int by);
    void pruneBlocks();
  public:
};
namespace std __attribute__((__visibility__("default"))) {
  template < typename _T1, typename _T2 >
  inline void _Construct(_T1 *__p, const _T2 &__value);
  template < typename _T1, typename _T2 >
  inline void _Construct(_T1 *__p, const _T2 &__value)
  {
    ::new (static_cast<void *>(__p))_T1(__value);
  }
  template < typename _T1 >
  inline void _Construct_novalue(_T1 *__p);
  template < typename _T1 >
  inline void _Construct_novalue(_T1 *__p)
  {
    ::new (static_cast<void *>(__p))_T1();
  }
  template < typename _Tp >
  inline void _Destroy(_Tp *__pointer);
  template < typename _Tp >
  inline void _Destroy(_Tp *__pointer)
  {
    __pointer->~_Tp();
  }
  template < bool __nontype_tpl_param_1_0__ >
  struct  _Destroy_aux
  {
      template < typename _ForwardIterator >
      static inline void __destroy(_ForwardIterator __first, _ForwardIterator __last)
      {
        for (; __first != __last;  ++__first)
          {
            std::_Destroy(std::__addressof(*__first));
          }
      }
  };
  template <>
  struct  _Destroy_aux<true>
  {
      template < typename _ForwardIterator >
      static inline void __destroy(_ForwardIterator, _ForwardIterator)
      {
      }
  };
  template < typename _ForwardIterator >
  inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last);
  template < typename _ForwardIterator >
  inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _Value_type;
    std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::__destroy(__first, __last);
  }
  template < bool __nontype_tpl_param_1_0__ >
  struct  _Destroy_n_aux
  {
      template < typename _ForwardIterator, typename _Size >
      static inline _ForwardIterator __destroy_n(_ForwardIterator __first, _Size __count)
      {
        for (; __count > 0; ((void) ++__first,  --__count))
          {
            std::_Destroy(std::__addressof(*__first));
          }
        return __first;
      }
  };
  template <>
  struct  _Destroy_n_aux<true>
  {
      template < typename _ForwardIterator, typename _Size >
      static inline _ForwardIterator __destroy_n(_ForwardIterator __first, _Size __count)
      {
        std::advance(__first, __count);
        return __first;
      }
  };
  template < typename _ForwardIterator, typename _Size >
  inline _ForwardIterator _Destroy_n(_ForwardIterator __first, _Size __count);
  template < typename _ForwardIterator, typename _Size >
  inline _ForwardIterator _Destroy_n(_ForwardIterator __first, _Size __count)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _Value_type;
    return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::__destroy_n(__first, __count);
  }
  template < typename _ForwardIterator, typename _Allocator >
  void _Destroy(_ForwardIterator __first, _ForwardIterator __last, _Allocator &__alloc);
  template < typename _ForwardIterator, typename _Allocator >
  void _Destroy(_ForwardIterator __first, _ForwardIterator __last, _Allocator &__alloc)
  {
    typedef ::__gnu_cxx::__alloc_traits<_Allocator> __traits;
    for (; __first != __last;  ++__first)
      {
        __traits::destroy(__alloc, std::__addressof(*__first));
      }
  }
  template < typename _ForwardIterator, typename _Tp >
  inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last, ::std::allocator<_Tp> &);
  template < typename _ForwardIterator, typename _Tp >
  inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last, ::std::allocator<_Tp> &)
  {
    _Destroy(__first, __last);
  }
  template < bool _TrivialValueTypes >
  struct  __uninitialized_copy
  {
      template < typename _InputIterator, typename _ForwardIterator >
      static inline _ForwardIterator __uninit_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result)
      {
        _ForwardIterator __cur = __result;
        try
        {
          for (; __first != __last; ( ++__first, (void) ++__cur))
            {
              std::_Construct(std::__addressof(*__cur), *__first);
            }
          return __cur;
        }
        catch (...)
        {
          std::_Destroy(__result, __cur);
          throw;
        }
      }
  };
  template <>
  struct  __uninitialized_copy<true>
  {
      template < typename _InputIterator, typename _ForwardIterator >
      static inline _ForwardIterator __uninit_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result)
      {
        return std::copy(__first, __last, __result);
      }
  };
  template < typename _InputIterator, typename _ForwardIterator >
  inline _ForwardIterator uninitialized_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result);
  template < typename _InputIterator, typename _ForwardIterator >
  inline _ForwardIterator uninitialized_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result)
  {
    typedef typename ::std::iterator_traits<_InputIterator>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType2;
    const bool __assignable(true);
    return std::__uninitialized_copy<((__is_trivial(_ValueType1)) && (__is_trivial(_ValueType2))) && __assignable>::__uninit_copy(__first, __last, __result);
  }
  template < bool _TrivialValueType >
  struct  __uninitialized_fill
  {
      template < typename _ForwardIterator, typename _Tp >
      static inline void __uninit_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x)
      {
        _ForwardIterator __cur = __first;
        try
        {
          for (; __cur != __last;  ++__cur)
            {
              std::_Construct(std::__addressof(*__cur), __x);
            }
        }
        catch (...)
        {
          std::_Destroy(__first, __cur);
          throw;
        }
      }
  };
  template <>
  struct  __uninitialized_fill<true>
  {
      template < typename _ForwardIterator, typename _Tp >
      static inline void __uninit_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x)
      {
        std::fill(__first, __last, __x);
      }
  };
  template < typename _ForwardIterator, typename _Tp >
  inline void uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x);
  template < typename _ForwardIterator, typename _Tp >
  inline void uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
    const bool __assignable(true);
    std::__uninitialized_fill<(__is_trivial(_ValueType)) && __assignable>::__uninit_fill(__first, __last, __x);
  }
  template < bool _TrivialValueType >
  struct  __uninitialized_fill_n
  {
      template < typename _ForwardIterator, typename _Size, typename _Tp >
      static inline _ForwardIterator __uninit_fill_n(_ForwardIterator __first, _Size __n, const _Tp &__x)
      {
        _ForwardIterator __cur = __first;
        try
        {
          for (; __n > 0; ( --__n,  ++__cur))
            {
              std::_Construct(std::__addressof(*__cur), __x);
            }
          return __cur;
        }
        catch (...)
        {
          std::_Destroy(__first, __cur);
          throw;
        }
      }
  };
  template <>
  struct  __uninitialized_fill_n<true>
  {
      template < typename _ForwardIterator, typename _Size, typename _Tp >
      static inline _ForwardIterator __uninit_fill_n(_ForwardIterator __first, _Size __n, const _Tp &__x)
      {
        return std::fill_n(__first, __n, __x);
      }
  };
  template < typename _ForwardIterator, typename _Size, typename _Tp >
  inline _ForwardIterator uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp &__x);
  template < typename _ForwardIterator, typename _Size, typename _Tp >
  inline _ForwardIterator uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp &__x)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
    const bool __assignable(true);
    return __uninitialized_fill_n<(__is_trivial(_ValueType)) && __assignable>::__uninit_fill_n(__first, __n, __x);
  }
  template < typename _InputIterator, typename _ForwardIterator, typename _Allocator >
  _ForwardIterator __uninitialized_copy_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc);
  template < typename _InputIterator, typename _ForwardIterator, typename _Allocator >
  _ForwardIterator __uninitialized_copy_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc)
  {
    _ForwardIterator __cur = __result;
    try
    {
      typedef ::__gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __first != __last; ( ++__first, (void) ++__cur))
        {
          __traits::construct(__alloc, std::__addressof(*__cur), *__first);
        }
      return __cur;
    }
    catch (...)
    {
      std::_Destroy(__result, __cur, __alloc);
      throw;
    }
  }
  template < typename _InputIterator, typename _ForwardIterator, typename _Tp >
  inline _ForwardIterator __uninitialized_copy_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, ::std::allocator<_Tp> &);
  template < typename _InputIterator, typename _ForwardIterator, typename _Tp >
  inline _ForwardIterator __uninitialized_copy_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, ::std::allocator<_Tp> &)
  {
    return std::uninitialized_copy(__first, __last, __result);
  }
  template < typename _InputIterator, typename _ForwardIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_move_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc);
  template < typename _InputIterator, typename _ForwardIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_move_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc)
  {
    return std::__uninitialized_copy_a(__first, __last, __result, __alloc);
  }
  template < typename _InputIterator, typename _ForwardIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_move_if_noexcept_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc);
  template < typename _InputIterator, typename _ForwardIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_move_if_noexcept_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc)
  {
    return std::__uninitialized_copy_a(__first, __last, __result, __alloc);
  }
  template < typename _ForwardIterator, typename _Tp, typename _Allocator >
  void __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x, _Allocator &__alloc);
  template < typename _ForwardIterator, typename _Tp, typename _Allocator >
  void __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x, _Allocator &__alloc)
  {
    _ForwardIterator __cur = __first;
    try
    {
      typedef ::__gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __cur != __last;  ++__cur)
        {
          __traits::construct(__alloc, std::__addressof(*__cur), __x);
        }
    }
    catch (...)
    {
      std::_Destroy(__first, __cur, __alloc);
      throw;
    }
  }
  template < typename _ForwardIterator, typename _Tp, typename _Tp2 >
  inline void __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x, ::std::allocator<_Tp2> &);
  template < typename _ForwardIterator, typename _Tp, typename _Tp2 >
  inline void __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x, ::std::allocator<_Tp2> &)
  {
    std::uninitialized_fill(__first, __last, __x);
  }
  template < typename _ForwardIterator, typename _Size, typename _Tp, typename _Allocator >
  _ForwardIterator __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, const _Tp &__x, _Allocator &__alloc);
  template < typename _ForwardIterator, typename _Size, typename _Tp, typename _Allocator >
  _ForwardIterator __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, const _Tp &__x, _Allocator &__alloc)
  {
    _ForwardIterator __cur = __first;
    try
    {
      typedef ::__gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __n > 0; ( --__n,  ++__cur))
        {
          __traits::construct(__alloc, std::__addressof(*__cur), __x);
        }
      return __cur;
    }
    catch (...)
    {
      std::_Destroy(__first, __cur, __alloc);
      throw;
    }
  }
  template < typename _ForwardIterator, typename _Size, typename _Tp, typename _Tp2 >
  inline _ForwardIterator __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, const _Tp &__x, ::std::allocator<_Tp2> &);
  template < typename _ForwardIterator, typename _Size, typename _Tp, typename _Tp2 >
  inline _ForwardIterator __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, const _Tp &__x, ::std::allocator<_Tp2> &)
  {
    return std::uninitialized_fill_n(__first, __n, __x);
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _ForwardIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_copy_move(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _ForwardIterator __result, _Allocator &__alloc);
  template < typename _InputIterator1, typename _InputIterator2, typename _ForwardIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_copy_move(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _ForwardIterator __result, _Allocator &__alloc)
  {
    _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1, __result, __alloc);
    try
    {
      return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
    }
    catch (...)
    {
      std::_Destroy(__result, __mid, __alloc);
      throw;
    }
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _ForwardIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_move_copy(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _ForwardIterator __result, _Allocator &__alloc);
  template < typename _InputIterator1, typename _InputIterator2, typename _ForwardIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_move_copy(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _ForwardIterator __result, _Allocator &__alloc)
  {
    _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1, __result, __alloc);
    try
    {
      return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
    }
    catch (...)
    {
      std::_Destroy(__result, __mid, __alloc);
      throw;
    }
  }
  template < typename _ForwardIterator, typename _Tp, typename _InputIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid, const _Tp &__x, _InputIterator __first, _InputIterator __last, _Allocator &__alloc);
  template < typename _ForwardIterator, typename _Tp, typename _InputIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid, const _Tp &__x, _InputIterator __first, _InputIterator __last, _Allocator &__alloc)
  {
    std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
    try
    {
      return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
    }
    catch (...)
    {
      std::_Destroy(__result, __mid, __alloc);
      throw;
    }
  }
  template < typename _InputIterator, typename _ForwardIterator, typename _Tp, typename _Allocator >
  inline void __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2, const _Tp &__x, _Allocator &__alloc);
  template < typename _InputIterator, typename _ForwardIterator, typename _Tp, typename _Allocator >
  inline void __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2, const _Tp &__x, _Allocator &__alloc)
  {
    _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1, __first2, __alloc);
    try
    {
      std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
    }
    catch (...)
    {
      std::_Destroy(__first2, __mid2, __alloc);
      throw;
    }
  }
  inline ::std::size_t __deque_buf_size(::std::size_t __size)
  {
    return __size < 512 ? (::std::size_t)(512 / __size) : (::std::size_t)1;
  }
  template < typename _Tp, typename _Ref, typename _Ptr >
  struct  _Deque_iterator
  {
      typedef ::std::_Deque_iterator<_Tp, _Tp &, _Tp *> iterator;
      typedef ::std::_Deque_iterator<_Tp, const _Tp &, const _Tp *> const_iterator;
      typedef _Tp *_Elt_pointer;
      typedef _Tp **_Map_pointer;
      static inline ::std::size_t _S_buffer_size()
      {
        return ::std::__deque_buf_size(sizeof(_Tp));
      }
      typedef ::std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Ptr pointer;
      typedef _Ref reference;
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef ::std::_Deque_iterator<_Tp, _Ref, _Ptr> _Self;
      typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_Elt_pointer _M_cur;
      typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_Elt_pointer _M_first;
      typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_Elt_pointer _M_last;
      typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_Map_pointer _M_node;
      inline _Deque_iterator(typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_Elt_pointer __x, typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_Map_pointer __y)
        : _M_cur(__x), _M_first(*__y), _M_last(*__y + _S_buffer_size()), _M_node(__y)
      {
      }
      inline _Deque_iterator()
        : _M_cur(), _M_first(), _M_last(), _M_node()
      {
      }
      inline _Deque_iterator(const typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::iterator &__x)
        : _M_cur(__x._M_cur), _M_first(__x._M_first), _M_last(__x._M_last), _M_node(__x._M_node)
      {
      }
      inline typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::iterator _M_const_cast() const 
      {
        return ((typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::iterator(::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_cur, ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_node)));
      }
      inline typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::reference operator *() const 
      {
        return *::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_cur;
      }
      inline typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::pointer operator ->() const 
      {
        return ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_cur;
      }
      inline typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_Self &operator ++()
      {
         ++::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_cur;
        if (::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_cur == ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_last)
          {
            (*this)._M_set_node(::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_node + 1);
            ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_cur = ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_first;
          }
        return *this;
      }
      inline typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_Self operator ++(int)
      {
        typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_Self __tmp = *this;
         ++*this;
        return __tmp;
      }
      inline typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_Self &operator --()
      {
        if (::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_cur == ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_first)
          {
            (*this)._M_set_node(::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_node - 1);
            ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_cur = ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_last;
          }
         --::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_cur;
        return *this;
      }
      inline typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_Self operator --(int)
      {
        typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_Self __tmp = *this;
         --*this;
        return __tmp;
      }
      inline typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_Self &operator +=(typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::difference_type __n)
      {
        const typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::difference_type __offset = __n + (::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_cur - ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_first);
        if (__offset >= 0 && __offset < long(_S_buffer_size()))
          {
            ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_cur += __n;
          }
        else
          {
            const typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::difference_type __node_offset = __offset > 0 ? __offset / long(_S_buffer_size()) :  -long(( -__offset - 1) / _S_buffer_size()) - 1;
            (*this)._M_set_node(::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_node + __node_offset);
            ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_cur = ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_first + (__offset - __node_offset * long(_S_buffer_size()));
          }
        return *this;
      }
      inline typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_Self operator +(typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::difference_type __n) const 
      {
        typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_Self __tmp = *this;
        return __tmp += __n;
      }
      inline typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_Self &operator -=(typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::difference_type __n)
      {
        return *this +=  -__n;
      }
      inline typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_Self operator -(typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::difference_type __n) const 
      {
        typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_Self __tmp = *this;
        return __tmp -= __n;
      }
      inline typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::reference operator [](typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::difference_type __n) const 
      {
        return *(*this + __n);
      }
      inline void _M_set_node(typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_Map_pointer __new_node)
      {
        ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_node = __new_node;
        ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_first = *__new_node;
        ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_last = ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::_M_first + long(_S_buffer_size());
      }
  };
  template < typename _Tp, typename _Ref, typename _Ptr >
  inline bool operator ==(const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__x, const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__y);
  template < typename _Tp, typename _Ref, typename _Ptr >
  inline bool operator ==(const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__x, const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__y)
  {
    return __x._M_cur == __y._M_cur;
  }
  template < typename _Tp, typename _RefL, typename _PtrL, typename _RefR, typename _PtrR >
  inline bool operator ==(const ::std::_Deque_iterator<_Tp, _RefL, _PtrL> &__x, const ::std::_Deque_iterator<_Tp, _RefR, _PtrR> &__y);
  template < typename _Tp, typename _RefL, typename _PtrL, typename _RefR, typename _PtrR >
  inline bool operator ==(const ::std::_Deque_iterator<_Tp, _RefL, _PtrL> &__x, const ::std::_Deque_iterator<_Tp, _RefR, _PtrR> &__y)
  {
    return __x._M_cur == __y._M_cur;
  }
  template < typename _Tp, typename _Ref, typename _Ptr >
  inline bool operator !=(const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__x, const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__y);
  template < typename _Tp, typename _Ref, typename _Ptr >
  inline bool operator !=(const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__x, const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__y)
  {
    return !(__x == __y);
  }
  template < typename _Tp, typename _RefL, typename _PtrL, typename _RefR, typename _PtrR >
  inline bool operator !=(const ::std::_Deque_iterator<_Tp, _RefL, _PtrL> &__x, const ::std::_Deque_iterator<_Tp, _RefR, _PtrR> &__y);
  template < typename _Tp, typename _RefL, typename _PtrL, typename _RefR, typename _PtrR >
  inline bool operator !=(const ::std::_Deque_iterator<_Tp, _RefL, _PtrL> &__x, const ::std::_Deque_iterator<_Tp, _RefR, _PtrR> &__y)
  {
    return !(__x == __y);
  }
  template < typename _Tp, typename _Ref, typename _Ptr >
  inline bool operator <(const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__x, const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__y);
  template < typename _Tp, typename _Ref, typename _Ptr >
  inline bool operator <(const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__x, const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__y)
  {
    return __x._M_node == __y._M_node ? __x._M_cur < __y._M_cur : __x._M_node < __y._M_node;
  }
  template < typename _Tp, typename _RefL, typename _PtrL, typename _RefR, typename _PtrR >
  inline bool operator <(const ::std::_Deque_iterator<_Tp, _RefL, _PtrL> &__x, const ::std::_Deque_iterator<_Tp, _RefR, _PtrR> &__y);
  template < typename _Tp, typename _RefL, typename _PtrL, typename _RefR, typename _PtrR >
  inline bool operator <(const ::std::_Deque_iterator<_Tp, _RefL, _PtrL> &__x, const ::std::_Deque_iterator<_Tp, _RefR, _PtrR> &__y)
  {
    return __x._M_node == __y._M_node ? __x._M_cur < __y._M_cur : __x._M_node < __y._M_node;
  }
  template < typename _Tp, typename _Ref, typename _Ptr >
  inline bool operator >(const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__x, const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__y);
  template < typename _Tp, typename _Ref, typename _Ptr >
  inline bool operator >(const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__x, const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__y)
  {
    return __y < __x;
  }
  template < typename _Tp, typename _RefL, typename _PtrL, typename _RefR, typename _PtrR >
  inline bool operator >(const ::std::_Deque_iterator<_Tp, _RefL, _PtrL> &__x, const ::std::_Deque_iterator<_Tp, _RefR, _PtrR> &__y);
  template < typename _Tp, typename _RefL, typename _PtrL, typename _RefR, typename _PtrR >
  inline bool operator >(const ::std::_Deque_iterator<_Tp, _RefL, _PtrL> &__x, const ::std::_Deque_iterator<_Tp, _RefR, _PtrR> &__y)
  {
    return __y < __x;
  }
  template < typename _Tp, typename _Ref, typename _Ptr >
  inline bool operator <=(const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__x, const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__y);
  template < typename _Tp, typename _Ref, typename _Ptr >
  inline bool operator <=(const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__x, const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Tp, typename _RefL, typename _PtrL, typename _RefR, typename _PtrR >
  inline bool operator <=(const ::std::_Deque_iterator<_Tp, _RefL, _PtrL> &__x, const ::std::_Deque_iterator<_Tp, _RefR, _PtrR> &__y);
  template < typename _Tp, typename _RefL, typename _PtrL, typename _RefR, typename _PtrR >
  inline bool operator <=(const ::std::_Deque_iterator<_Tp, _RefL, _PtrL> &__x, const ::std::_Deque_iterator<_Tp, _RefR, _PtrR> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Tp, typename _Ref, typename _Ptr >
  inline bool operator >=(const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__x, const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__y);
  template < typename _Tp, typename _Ref, typename _Ptr >
  inline bool operator >=(const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__x, const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Tp, typename _RefL, typename _PtrL, typename _RefR, typename _PtrR >
  inline bool operator >=(const ::std::_Deque_iterator<_Tp, _RefL, _PtrL> &__x, const ::std::_Deque_iterator<_Tp, _RefR, _PtrR> &__y);
  template < typename _Tp, typename _RefL, typename _PtrL, typename _RefR, typename _PtrR >
  inline bool operator >=(const ::std::_Deque_iterator<_Tp, _RefL, _PtrL> &__x, const ::std::_Deque_iterator<_Tp, _RefR, _PtrR> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Tp, typename _Ref, typename _Ptr >
  inline typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::difference_type operator -(const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__x, const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__y);
  template < typename _Tp, typename _Ref, typename _Ptr >
  inline typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::difference_type operator -(const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__x, const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__y)
  {
    return typename ::std::_Deque_iterator<_Tp, _Ref, _Ptr>::difference_type(_Deque_iterator<_Tp, _Ref, _Ptr>::_S_buffer_size()) * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first) + (__y._M_last - __y._M_cur);
  }
  template < typename _Tp, typename _RefL, typename _PtrL, typename _RefR, typename _PtrR >
  inline typename ::std::_Deque_iterator<_Tp, _RefL, _PtrL>::difference_type operator -(const ::std::_Deque_iterator<_Tp, _RefL, _PtrL> &__x, const ::std::_Deque_iterator<_Tp, _RefR, _PtrR> &__y);
  template < typename _Tp, typename _RefL, typename _PtrL, typename _RefR, typename _PtrR >
  inline typename ::std::_Deque_iterator<_Tp, _RefL, _PtrL>::difference_type operator -(const ::std::_Deque_iterator<_Tp, _RefL, _PtrL> &__x, const ::std::_Deque_iterator<_Tp, _RefR, _PtrR> &__y)
  {
    return typename ::std::_Deque_iterator<_Tp, _RefL, _PtrL>::difference_type(_Deque_iterator<_Tp, _RefL, _PtrL>::_S_buffer_size()) * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first) + (__y._M_last - __y._M_cur);
  }
  template < typename _Tp, typename _Ref, typename _Ptr >
  inline ::std::_Deque_iterator<_Tp, _Ref, _Ptr> operator +(::std::ptrdiff_t __n, const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__x);
  template < typename _Tp, typename _Ref, typename _Ptr >
  inline ::std::_Deque_iterator<_Tp, _Ref, _Ptr> operator +(::std::ptrdiff_t __n, const ::std::_Deque_iterator<_Tp, _Ref, _Ptr> &__x)
  {
    return __x + __n;
  }
  template < typename _Tp >
  void fill(const ::std::_Deque_iterator<_Tp, _Tp &, _Tp *> &__first, const ::std::_Deque_iterator<_Tp, _Tp &, _Tp *> &__last, const _Tp &__value);
  template < typename _Tp >
  ::std::_Deque_iterator<_Tp, _Tp &, _Tp *> copy(::std::_Deque_iterator<_Tp, const _Tp &, const _Tp *> __first, ::std::_Deque_iterator<_Tp, const _Tp &, const _Tp *> __last, ::std::_Deque_iterator<_Tp, _Tp &, _Tp *> __result);
  template < typename _Tp >
  inline ::std::_Deque_iterator<_Tp, _Tp &, _Tp *> copy(::std::_Deque_iterator<_Tp, _Tp &, _Tp *> __first, ::std::_Deque_iterator<_Tp, _Tp &, _Tp *> __last, ::std::_Deque_iterator<_Tp, _Tp &, _Tp *> __result);
  template < typename _Tp >
  inline ::std::_Deque_iterator<_Tp, _Tp &, _Tp *> copy(::std::_Deque_iterator<_Tp, _Tp &, _Tp *> __first, ::std::_Deque_iterator<_Tp, _Tp &, _Tp *> __last, ::std::_Deque_iterator<_Tp, _Tp &, _Tp *> __result)
  {
    return std::copy(::std::_Deque_iterator<_Tp, const _Tp &, const _Tp *>(__first), ::std::_Deque_iterator<_Tp, const _Tp &, const _Tp *>(__last), __result);
  }
  template < typename _Tp >
  ::std::_Deque_iterator<_Tp, _Tp &, _Tp *> copy_backward(::std::_Deque_iterator<_Tp, const _Tp &, const _Tp *> __first, ::std::_Deque_iterator<_Tp, const _Tp &, const _Tp *> __last, ::std::_Deque_iterator<_Tp, _Tp &, _Tp *> __result);
  template < typename _Tp >
  inline ::std::_Deque_iterator<_Tp, _Tp &, _Tp *> copy_backward(::std::_Deque_iterator<_Tp, _Tp &, _Tp *> __first, ::std::_Deque_iterator<_Tp, _Tp &, _Tp *> __last, ::std::_Deque_iterator<_Tp, _Tp &, _Tp *> __result);
  template < typename _Tp >
  inline ::std::_Deque_iterator<_Tp, _Tp &, _Tp *> copy_backward(::std::_Deque_iterator<_Tp, _Tp &, _Tp *> __first, ::std::_Deque_iterator<_Tp, _Tp &, _Tp *> __last, ::std::_Deque_iterator<_Tp, _Tp &, _Tp *> __result)
  {
    return std::copy_backward(::std::_Deque_iterator<_Tp, const _Tp &, const _Tp *>(__first), ::std::_Deque_iterator<_Tp, const _Tp &, const _Tp *>(__last), __result);
  }
  template < typename _Tp, typename _Alloc >
  class  _Deque_base
  {
    protected:
      typedef typename ::__gnu_cxx::__alloc_traits<_Alloc>::template rebind< _Tp>::other _Tp_alloc_type;
      typedef ::__gnu_cxx::__alloc_traits<typename ::std::_Deque_base<_Tp, _Alloc>::_Tp_alloc_type> _Alloc_traits;
      typedef _Tp *_Ptr;
      typedef const _Tp *_Ptr_const;
      typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::_Deque_base<_Tp, _Alloc>::_Tp_alloc_type>::template rebind< typename ::std::_Deque_base<_Tp, _Alloc>::_Ptr>::other _Map_alloc_type;
      typedef ::__gnu_cxx::__alloc_traits<typename ::std::_Deque_base<_Tp, _Alloc>::_Map_alloc_type> _Map_alloc_traits;
    public:
      typedef _Alloc allocator_type;
      typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::_Deque_base<_Tp, _Alloc>::_Tp_alloc_type>::size_type size_type;
      inline typename ::std::_Deque_base<_Tp, _Alloc>::allocator_type get_allocator() const 
      {
        return ((typename ::std::_Deque_base<_Tp, _Alloc>::allocator_type((*this)._M_get_Tp_allocator())));
      }
      typedef ::std::_Deque_iterator<_Tp, _Tp &, typename ::std::_Deque_base<_Tp, _Alloc>::_Ptr> iterator;
      typedef ::std::_Deque_iterator<_Tp, const _Tp &, typename ::std::_Deque_base<_Tp, _Alloc>::_Ptr_const> const_iterator;
      inline _Deque_base()
        : _M_impl()
      {
        (*this)._M_initialize_map(0);
      }
      inline _Deque_base(::std::size_t __num_elements)
        : _M_impl()
      {
        (*this)._M_initialize_map(__num_elements);
      }
      inline _Deque_base(const typename ::std::_Deque_base<_Tp, _Alloc>::allocator_type &__a, ::std::size_t __num_elements)
        : _M_impl(__a)
      {
        (*this)._M_initialize_map(__num_elements);
      }
      inline _Deque_base(const typename ::std::_Deque_base<_Tp, _Alloc>::allocator_type &__a)
        : _M_impl(__a)
      {
      }
      ~_Deque_base();
    protected:
      typedef typename ::std::_Deque_iterator<_Tp, _Tp &, typename ::std::_Deque_base<_Tp, _Alloc>::_Ptr>::_Map_pointer _Map_pointer;
      struct  _Deque_impl : ::std::_Deque_base<_Tp, _Alloc>::_Tp_alloc_type
      {
          typename ::std::_Deque_base<_Tp, _Alloc>::_Map_pointer _M_map;
          ::std::size_t _M_map_size;
          typename ::std::_Deque_base<_Tp, _Alloc>::iterator _M_start;
          typename ::std::_Deque_base<_Tp, _Alloc>::iterator _M_finish;
          inline _Deque_impl()
            : _Tp_alloc_type(), _M_map(), _M_map_size(0), _M_start(), _M_finish()
          {
          }
          inline _Deque_impl(const typename ::std::_Deque_base<_Tp, _Alloc>::_Tp_alloc_type &__a)
            : _Tp_alloc_type(__a), _M_map(), _M_map_size(0), _M_start(), _M_finish()
          {
          }
          inline void _M_swap_data(typename ::std::_Deque_base<_Tp, _Alloc>::_Deque_impl &__x)
          {
            using ::std::swap;
            swap(this->_M_start, __x._M_start);
            swap(this->_M_finish, __x._M_finish);
            swap(this->_M_map, __x._M_map);
            swap(this->_M_map_size, __x._M_map_size);
          }
      };
      inline typename ::std::_Deque_base<_Tp, _Alloc>::_Tp_alloc_type &_M_get_Tp_allocator()
      {
        return *static_cast<typename ::std::_Deque_base<_Tp, _Alloc>::_Tp_alloc_type *>(&this->_M_impl);
      }
      inline const typename ::std::_Deque_base<_Tp, _Alloc>::_Tp_alloc_type &_M_get_Tp_allocator() const 
      {
        return *static_cast<const typename ::std::_Deque_base<_Tp, _Alloc>::_Tp_alloc_type *>(&this->_M_impl);
      }
      inline typename ::std::_Deque_base<_Tp, _Alloc>::_Map_alloc_type _M_get_map_allocator() const 
      {
        return ((typename ::std::_Deque_base<_Tp, _Alloc>::_Map_alloc_type((*this)._M_get_Tp_allocator())));
      }
      inline typename ::std::_Deque_base<_Tp, _Alloc>::_Ptr _M_allocate_node()
      {
        typedef ::__gnu_cxx::__alloc_traits<typename ::std::_Deque_base<_Tp, _Alloc>::_Tp_alloc_type> _Traits;
        return _Traits::allocate(::std::_Deque_base<_Tp, _Alloc>::_M_impl, ::std::__deque_buf_size(sizeof(_Tp)));
      }
      inline void _M_deallocate_node(typename ::std::_Deque_base<_Tp, _Alloc>::_Ptr __p)
      {
        typedef ::__gnu_cxx::__alloc_traits<typename ::std::_Deque_base<_Tp, _Alloc>::_Tp_alloc_type> _Traits;
        _Traits::deallocate(::std::_Deque_base<_Tp, _Alloc>::_M_impl, __p, ::std::__deque_buf_size(sizeof(_Tp)));
      }
      inline typename ::std::_Deque_base<_Tp, _Alloc>::_Map_pointer _M_allocate_map(::std::size_t __n)
      {
        typename ::std::_Deque_base<_Tp, _Alloc>::_Map_alloc_type __map_alloc = (*this)._M_get_map_allocator();
        return _Map_alloc_traits::allocate(__map_alloc, __n);
      }
      inline void _M_deallocate_map(typename ::std::_Deque_base<_Tp, _Alloc>::_Map_pointer __p, ::std::size_t __n)
      {
        typename ::std::_Deque_base<_Tp, _Alloc>::_Map_alloc_type __map_alloc = (*this)._M_get_map_allocator();
        _Map_alloc_traits::deallocate(__map_alloc, __p, __n);
      }
      void _M_initialize_map(::std::size_t __num_elements);
      void _M_create_nodes(typename ::std::_Deque_base<_Tp, _Alloc>::_Map_pointer __nstart, typename ::std::_Deque_base<_Tp, _Alloc>::_Map_pointer __nfinish);
      void _M_destroy_nodes(typename ::std::_Deque_base<_Tp, _Alloc>::_Map_pointer __nstart, typename ::std::_Deque_base<_Tp, _Alloc>::_Map_pointer __nfinish);
      enum mcc_enum_anon_47
      {
        _S_initial_map_size = 8
      };
      typename ::std::_Deque_base<_Tp, _Alloc>::_Deque_impl _M_impl;
  };
  template < typename _Tp, typename _Alloc >
  _Deque_base<_Tp, _Alloc>::~_Deque_base()
  {
    if (this->_M_impl._M_map)
      {
        (*this)._M_destroy_nodes(this->_M_impl._M_start._M_node, this->_M_impl._M_finish._M_node + 1);
        (*this)._M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
      }
  }
  template < typename _Tp, typename _Alloc >
  void _Deque_base<_Tp, _Alloc>::_M_initialize_map(::std::size_t __num_elements)
  {
    const ::std::size_t __num_nodes = __num_elements / ::std::__deque_buf_size(sizeof(_Tp)) + 1;
    this->_M_impl._M_map_size = std::max((::std::size_t)::std::_Deque_base<_Tp, _Alloc>::_S_initial_map_size, (::std::size_t)(__num_nodes + 2));
    this->_M_impl._M_map = (*this)._M_allocate_map(this->_M_impl._M_map_size);
    typename ::std::_Deque_base<_Tp, _Alloc>::_Map_pointer __nstart = (this->_M_impl._M_map + (this->_M_impl._M_map_size - __num_nodes) / 2);
    typename ::std::_Deque_base<_Tp, _Alloc>::_Map_pointer __nfinish = __nstart + __num_nodes;
    try
    {
      (*this)._M_create_nodes(__nstart, __nfinish);
    }
    catch (...)
    {
      (*this)._M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
      this->_M_impl._M_map = ((typename ::std::_Deque_base<_Tp, _Alloc>::_Map_pointer()));
      this->_M_impl._M_map_size = 0;
      throw;
    }
    this->_M_impl._M_start._M_set_node(__nstart);
    this->_M_impl._M_finish._M_set_node(__nfinish - 1);
    this->_M_impl._M_start._M_cur = ::std::_Deque_base<_Tp, _Alloc>::_M_impl._M_start._M_first;
    this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first + __num_elements % ::std::__deque_buf_size(sizeof(_Tp));
  }
  template < typename _Tp, typename _Alloc >
  void _Deque_base<_Tp, _Alloc>::_M_create_nodes(typename ::std::_Deque_base<_Tp, _Alloc>::_Map_pointer __nstart, typename ::std::_Deque_base<_Tp, _Alloc>::_Map_pointer __nfinish)
  {
    typename ::std::_Deque_base<_Tp, _Alloc>::_Map_pointer __cur;
    try
    {
      for (__cur = __nstart; __cur < __nfinish;  ++__cur)
        {
          *__cur = this->_M_allocate_node();
        }
    }
    catch (...)
    {
      (*this)._M_destroy_nodes(__nstart, __cur);
      throw;
    }
  }
  template < typename _Tp, typename _Alloc >
  void _Deque_base<_Tp, _Alloc>::_M_destroy_nodes(typename ::std::_Deque_base<_Tp, _Alloc>::_Map_pointer __nstart, typename ::std::_Deque_base<_Tp, _Alloc>::_Map_pointer __nfinish)
  {
    for (typename ::std::_Deque_base<_Tp, _Alloc>::_Map_pointer __n = __nstart; __n < __nfinish;  ++__n)
      {
        (*this)._M_deallocate_node(*__n);
      }
  }
  template < typename _Tp, typename _Alloc = ::std::allocator<_Tp> >
  class  deque : protected ::std::_Deque_base<_Tp, _Alloc>
  {
      typedef ::std::_Deque_base<_Tp, _Alloc> _Base;
      typedef typename ::std::_Deque_base<_Tp, _Alloc>::_Tp_alloc_type _Tp_alloc_type;
      typedef typename ::std::_Deque_base<_Tp, _Alloc>::_Alloc_traits _Alloc_traits;
      typedef typename ::std::_Deque_base<_Tp, _Alloc>::_Map_pointer _Map_pointer;
    public:
      typedef _Tp value_type;
      typedef typename ::std::_Deque_base<_Tp, _Alloc>::_Alloc_traits::pointer pointer;
      typedef typename ::std::_Deque_base<_Tp, _Alloc>::_Alloc_traits::const_pointer const_pointer;
      typedef typename ::std::_Deque_base<_Tp, _Alloc>::_Alloc_traits::reference reference;
      typedef typename ::std::_Deque_base<_Tp, _Alloc>::_Alloc_traits::const_reference const_reference;
      typedef typename ::std::_Deque_base<_Tp, _Alloc>::iterator iterator;
      typedef typename ::std::_Deque_base<_Tp, _Alloc>::const_iterator const_iterator;
      typedef ::std::reverse_iterator<typename ::std::deque<_Tp, _Alloc>::const_iterator> const_reverse_iterator;
      typedef ::std::reverse_iterator<typename ::std::deque<_Tp, _Alloc>::iterator> reverse_iterator;
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef _Alloc allocator_type;
    protected:
      static inline ::std::size_t _S_buffer_size()
      {
        return ::std::__deque_buf_size(sizeof(_Tp));
      }
      using _Base::_M_initialize_map;
      using _Base::_M_create_nodes;
      using _Base::_M_destroy_nodes;
      using _Base::_M_allocate_node;
      using _Base::_M_deallocate_node;
      using _Base::_M_allocate_map;
      using _Base::_M_deallocate_map;
      using _Base::_M_get_Tp_allocator;
      using _Base::_M_impl;
    public:
      inline deque()
        : _Base()
      {
      }
      inline explicit deque(const typename ::std::deque<_Tp, _Alloc>::allocator_type &__a)
        : _Base(__a, 0)
      {
      }
      inline explicit deque(typename ::std::deque<_Tp, _Alloc>::size_type __n, const typename ::std::deque<_Tp, _Alloc>::value_type &__value  = (((typename ::std::deque<_Tp, _Alloc>::value_type()))), const typename ::std::deque<_Tp, _Alloc>::allocator_type &__a  = (((typename ::std::deque<_Tp, _Alloc>::allocator_type()))))
        : _Base(__a, __n)
      {
        (*this)._M_fill_initialize(__value);
      }
      inline deque(const ::std::deque<_Tp, _Alloc> &__x)
        : _Base(_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()), __x.size())
      {
        std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, (_M_get_Tp_allocator)());
      }
      template < typename _InputIterator >
      inline deque(_InputIterator __first, _InputIterator __last, const typename ::std::deque<_Tp, _Alloc>::allocator_type &__a  = (((typename ::std::deque<_Tp, _Alloc>::allocator_type()))))
        : _Base(__a)
      {
        typedef typename ::std::__is_integer<_InputIterator>::__type _Integral;
        (*this)._M_initialize_dispatch(__first, __last, _Integral());
      }
      inline ~deque()
      {
        (*this)._M_destroy_data((*this).begin(), (*this).end(), (_M_get_Tp_allocator)());
      }
      ::std::deque<_Tp, _Alloc> &operator =(const ::std::deque<_Tp, _Alloc> &__x);
      inline void assign(typename ::std::deque<_Tp, _Alloc>::size_type __n, const typename ::std::deque<_Tp, _Alloc>::value_type &__val)
      {
        (*this)._M_fill_assign(__n, __val);
      }
      template < typename _InputIterator >
      inline void assign(_InputIterator __first, _InputIterator __last)
      {
        typedef typename ::std::__is_integer<_InputIterator>::__type _Integral;
        (*this)._M_assign_dispatch(__first, __last, _Integral());
      }
      inline typename ::std::deque<_Tp, _Alloc>::allocator_type get_allocator() const 
      {
        return _Base::get_allocator();
      }
      inline typename ::std::deque<_Tp, _Alloc>::iterator begin()
      {
        return this->_M_impl._M_start;
      }
      inline typename ::std::deque<_Tp, _Alloc>::const_iterator begin() const 
      {
        return this->_M_impl._M_start;
      }
      inline typename ::std::deque<_Tp, _Alloc>::iterator end()
      {
        return this->_M_impl._M_finish;
      }
      inline typename ::std::deque<_Tp, _Alloc>::const_iterator end() const 
      {
        return this->_M_impl._M_finish;
      }
      inline typename ::std::deque<_Tp, _Alloc>::reverse_iterator rbegin()
      {
        return ((typename ::std::deque<_Tp, _Alloc>::reverse_iterator(this->_M_impl._M_finish)));
      }
      inline typename ::std::deque<_Tp, _Alloc>::const_reverse_iterator rbegin() const 
      {
        return ((typename ::std::deque<_Tp, _Alloc>::const_reverse_iterator(this->_M_impl._M_finish)));
      }
      inline typename ::std::deque<_Tp, _Alloc>::reverse_iterator rend()
      {
        return ((typename ::std::deque<_Tp, _Alloc>::reverse_iterator(this->_M_impl._M_start)));
      }
      inline typename ::std::deque<_Tp, _Alloc>::const_reverse_iterator rend() const 
      {
        return ((typename ::std::deque<_Tp, _Alloc>::const_reverse_iterator(this->_M_impl._M_start)));
      }
      inline typename ::std::deque<_Tp, _Alloc>::size_type size() const 
      {
        return this->_M_impl._M_finish - this->_M_impl._M_start;
      }
      inline typename ::std::deque<_Tp, _Alloc>::size_type max_size() const 
      {
        return _Alloc_traits::max_size((_M_get_Tp_allocator)());
      }
      inline void resize(typename ::std::deque<_Tp, _Alloc>::size_type __new_size, typename ::std::deque<_Tp, _Alloc>::value_type __x  = (((typename ::std::deque<_Tp, _Alloc>::value_type()))))
      {
        const typename ::std::deque<_Tp, _Alloc>::size_type __len = (*this).size();
        if (__new_size > __len)
          {
            (*this)._M_fill_insert(this->_M_impl._M_finish, __new_size - __len, __x);
          }
        else
          {
            if (__new_size < __len)
              {
                (*this)._M_erase_at_end(this->_M_impl._M_start + (typename ::std::deque<_Tp, _Alloc>::difference_type)__new_size);
              }
          }
      }
      inline bool empty() const 
      {
        return this->_M_impl._M_finish == this->_M_impl._M_start;
      }
      inline typename ::std::deque<_Tp, _Alloc>::reference operator [](typename ::std::deque<_Tp, _Alloc>::size_type __n)
      {
        ;
        return this->_M_impl._M_start[(typename ::std::deque<_Tp, _Alloc>::difference_type)__n];
      }
      inline typename ::std::deque<_Tp, _Alloc>::const_reference operator [](typename ::std::deque<_Tp, _Alloc>::size_type __n) const 
      {
        ;
        return this->_M_impl._M_start[(typename ::std::deque<_Tp, _Alloc>::difference_type)__n];
      }
    protected:
      inline void _M_range_check(typename ::std::deque<_Tp, _Alloc>::size_type __n) const 
      {
        if (__n >= this->size())
          {
            __throw_out_of_range_fmt("deque::_M_range_check: __n (which is %zu)>= this->size() (which is %zu)", __n, this->size());
          }
      }
    public:
      inline typename ::std::deque<_Tp, _Alloc>::reference at(typename ::std::deque<_Tp, _Alloc>::size_type __n)
      {
        (*this)._M_range_check(__n);
        return (*this)[__n];
      }
      inline typename ::std::deque<_Tp, _Alloc>::const_reference at(typename ::std::deque<_Tp, _Alloc>::size_type __n) const 
      {
        (*this)._M_range_check(__n);
        return (*this)[__n];
      }
      inline typename ::std::deque<_Tp, _Alloc>::reference front()
      {
        ;
        return *(*this).begin();
      }
      inline typename ::std::deque<_Tp, _Alloc>::const_reference front() const 
      {
        ;
        return *(*this).begin();
      }
      inline typename ::std::deque<_Tp, _Alloc>::reference back()
      {
        ;
        typename ::std::deque<_Tp, _Alloc>::iterator __tmp = (*this).end();
         --__tmp;
        return *__tmp;
      }
      inline typename ::std::deque<_Tp, _Alloc>::const_reference back() const 
      {
        ;
        typename ::std::deque<_Tp, _Alloc>::const_iterator __tmp = (*this).end();
         --__tmp;
        return *__tmp;
      }
      inline void push_front(const typename ::std::deque<_Tp, _Alloc>::value_type &__x)
      {
        if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
          {
            _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_start._M_cur - 1, __x);
             --this->_M_impl._M_start._M_cur;
          }
        else
          {
            (*this)._M_push_front_aux(__x);
          }
      }
      inline void push_back(const typename ::std::deque<_Tp, _Alloc>::value_type &__x)
      {
        if (this->_M_impl._M_finish._M_cur != this->_M_impl._M_finish._M_last - 1)
          {
            _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish._M_cur, __x);
             ++this->_M_impl._M_finish._M_cur;
          }
        else
          {
            (*this)._M_push_back_aux(__x);
          }
      }
      inline void pop_front()
      {
        ;
        if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_last - 1)
          {
            _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_start._M_cur);
             ++this->_M_impl._M_start._M_cur;
          }
        else
          {
            (*this)._M_pop_front_aux();
          }
      }
      inline void pop_back()
      {
        ;
        if (this->_M_impl._M_finish._M_cur != this->_M_impl._M_finish._M_first)
          {
             --this->_M_impl._M_finish._M_cur;
            _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish._M_cur);
          }
        else
          {
            (*this)._M_pop_back_aux();
          }
      }
      typename ::std::deque<_Tp, _Alloc>::iterator insert(typename ::std::deque<_Tp, _Alloc>::iterator __position, const typename ::std::deque<_Tp, _Alloc>::value_type &__x);
      inline void insert(typename ::std::deque<_Tp, _Alloc>::iterator __position, typename ::std::deque<_Tp, _Alloc>::size_type __n, const typename ::std::deque<_Tp, _Alloc>::value_type &__x)
      {
        (*this)._M_fill_insert(__position, __n, __x);
      }
      template < typename _InputIterator >
      inline void insert(typename ::std::deque<_Tp, _Alloc>::iterator __position, _InputIterator __first, _InputIterator __last)
      {
        typedef typename ::std::__is_integer<_InputIterator>::__type _Integral;
        (*this)._M_insert_dispatch(__position, __first, __last, _Integral());
      }
      inline typename ::std::deque<_Tp, _Alloc>::iterator erase(typename ::std::deque<_Tp, _Alloc>::iterator __position)
      {
        return (*this)._M_erase(__position._M_const_cast());
      }
      inline typename ::std::deque<_Tp, _Alloc>::iterator erase(typename ::std::deque<_Tp, _Alloc>::iterator __first, typename ::std::deque<_Tp, _Alloc>::iterator __last)
      {
        return (*this)._M_erase(__first._M_const_cast(), __last._M_const_cast());
      }
      inline void swap(::std::deque<_Tp, _Alloc> &__x)
      {
        _M_impl._M_swap_data(__x._M_impl);
        _Alloc_traits::_S_on_swap((_M_get_Tp_allocator)(), __x._M_get_Tp_allocator());
      }
      inline void clear()
      {
        (*this)._M_erase_at_end((*this).begin());
      }
    protected:
      template < typename _Integer >
      inline void _M_initialize_dispatch(_Integer __n, _Integer __x, ::std::__true_type)
      {
        (_M_initialize_map)(static_cast<typename ::std::deque<_Tp, _Alloc>::size_type>(__n));
        (*this)._M_fill_initialize(__x);
      }
      template < typename _InputIterator >
      inline void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type)
      {
        (*this)._M_range_initialize(__first, __last, std::__iterator_category(__first));
      }
      template < typename _InputIterator >
      void _M_range_initialize(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag);
      template < typename _ForwardIterator >
      void _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag);
      void _M_fill_initialize(const typename ::std::deque<_Tp, _Alloc>::value_type &__value);
      template < typename _Integer >
      inline void _M_assign_dispatch(_Integer __n, _Integer __val, ::std::__true_type)
      {
        (*this)._M_fill_assign(__n, __val);
      }
      template < typename _InputIterator >
      inline void _M_assign_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type)
      {
        (*this)._M_assign_aux(__first, __last, std::__iterator_category(__first));
      }
      template < typename _InputIterator >
      void _M_assign_aux(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag);
      template < typename _ForwardIterator >
      inline void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag)
      {
        const typename ::std::deque<_Tp, _Alloc>::size_type __len = std::distance(__first, __last);
        if (__len > (*this).size())
          {
            _ForwardIterator __mid = __first;
            std::advance(__mid, (*this).size());
            std::copy(__first, __mid, (*this).begin());
            (*this)._M_range_insert_aux((*this).end(), __mid, __last, std::__iterator_category(__first));
          }
        else
          {
            (*this)._M_erase_at_end(std::copy(__first, __last, (*this).begin()));
          }
      }
      inline void _M_fill_assign(typename ::std::deque<_Tp, _Alloc>::size_type __n, const typename ::std::deque<_Tp, _Alloc>::value_type &__val)
      {
        if (__n > (*this).size())
          {
            std::fill((*this).begin(), (*this).end(), __val);
            (*this)._M_fill_insert((*this).end(), __n - (*this).size(), __val);
          }
        else
          {
            (*this)._M_erase_at_end((*this).begin() + (typename ::std::deque<_Tp, _Alloc>::difference_type)__n);
            std::fill((*this).begin(), (*this).end(), __val);
          }
      }
      void _M_push_back_aux(const typename ::std::deque<_Tp, _Alloc>::value_type &__t);
      void _M_push_front_aux(const typename ::std::deque<_Tp, _Alloc>::value_type &__t);
      void _M_pop_back_aux();
      void _M_pop_front_aux();
      template < typename _Integer >
      inline void _M_insert_dispatch(typename ::std::deque<_Tp, _Alloc>::iterator __pos, _Integer __n, _Integer __x, ::std::__true_type)
      {
        (*this)._M_fill_insert(__pos, __n, __x);
      }
      template < typename _InputIterator >
      inline void _M_insert_dispatch(typename ::std::deque<_Tp, _Alloc>::iterator __pos, _InputIterator __first, _InputIterator __last, ::std::__false_type)
      {
        (*this)._M_range_insert_aux(__pos, __first, __last, std::__iterator_category(__first));
      }
      template < typename _InputIterator >
      void _M_range_insert_aux(typename ::std::deque<_Tp, _Alloc>::iterator __pos, _InputIterator __first, _InputIterator __last, ::std::input_iterator_tag);
      template < typename _ForwardIterator >
      void _M_range_insert_aux(typename ::std::deque<_Tp, _Alloc>::iterator __pos, _ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag);
      void _M_fill_insert(typename ::std::deque<_Tp, _Alloc>::iterator __pos, typename ::std::deque<_Tp, _Alloc>::size_type __n, const typename ::std::deque<_Tp, _Alloc>::value_type &__x);
      typename ::std::deque<_Tp, _Alloc>::iterator _M_insert_aux(typename ::std::deque<_Tp, _Alloc>::iterator __pos, const typename ::std::deque<_Tp, _Alloc>::value_type &__x);
      void _M_insert_aux(typename ::std::deque<_Tp, _Alloc>::iterator __pos, typename ::std::deque<_Tp, _Alloc>::size_type __n, const typename ::std::deque<_Tp, _Alloc>::value_type &__x);
      template < typename _ForwardIterator >
      void _M_insert_aux(typename ::std::deque<_Tp, _Alloc>::iterator __pos, _ForwardIterator __first, _ForwardIterator __last, typename ::std::deque<_Tp, _Alloc>::size_type __n);
      void _M_destroy_data_aux(typename ::std::deque<_Tp, _Alloc>::iterator __first, typename ::std::deque<_Tp, _Alloc>::iterator __last);
      template < typename _Alloc1 >
      inline void _M_destroy_data(typename ::std::deque<_Tp, _Alloc>::iterator __first, typename ::std::deque<_Tp, _Alloc>::iterator __last, const _Alloc1 &)
      {
        (*this)._M_destroy_data_aux(__first, __last);
      }
      inline void _M_destroy_data(typename ::std::deque<_Tp, _Alloc>::iterator __first, typename ::std::deque<_Tp, _Alloc>::iterator __last, const ::std::allocator<_Tp> &)
      {
        if (!(__has_trivial_destructor(typename ::std::deque<_Tp, _Alloc>::value_type)))
          {
            (*this)._M_destroy_data_aux(__first, __last);
          }
      }
      inline void _M_erase_at_begin(typename ::std::deque<_Tp, _Alloc>::iterator __pos)
      {
        (*this)._M_destroy_data((*this).begin(), __pos, (_M_get_Tp_allocator)());
        _M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);
        this->_M_impl._M_start = __pos;
      }
      inline void _M_erase_at_end(typename ::std::deque<_Tp, _Alloc>::iterator __pos)
      {
        (*this)._M_destroy_data(__pos, (*this).end(), (_M_get_Tp_allocator)());
        _M_destroy_nodes(__pos._M_node + 1, this->_M_impl._M_finish._M_node + 1);
        this->_M_impl._M_finish = __pos;
      }
      typename ::std::deque<_Tp, _Alloc>::iterator _M_erase(typename ::std::deque<_Tp, _Alloc>::iterator __position);
      typename ::std::deque<_Tp, _Alloc>::iterator _M_erase(typename ::std::deque<_Tp, _Alloc>::iterator __first, typename ::std::deque<_Tp, _Alloc>::iterator __last);
      inline typename ::std::deque<_Tp, _Alloc>::iterator _M_reserve_elements_at_front(typename ::std::deque<_Tp, _Alloc>::size_type __n)
      {
        const typename ::std::deque<_Tp, _Alloc>::size_type __vacancies = this->_M_impl._M_start._M_cur - this->_M_impl._M_start._M_first;
        if (__n > __vacancies)
          {
            (*this)._M_new_elements_at_front(__n - __vacancies);
          }
        return this->_M_impl._M_start - (typename ::std::deque<_Tp, _Alloc>::difference_type)__n;
      }
      inline typename ::std::deque<_Tp, _Alloc>::iterator _M_reserve_elements_at_back(typename ::std::deque<_Tp, _Alloc>::size_type __n)
      {
        const typename ::std::deque<_Tp, _Alloc>::size_type __vacancies = this->_M_impl._M_finish._M_last - this->_M_impl._M_finish._M_cur - 1;
        if (__n > __vacancies)
          {
            (*this)._M_new_elements_at_back(__n - __vacancies);
          }
        return this->_M_impl._M_finish + (typename ::std::deque<_Tp, _Alloc>::difference_type)__n;
      }
      void _M_new_elements_at_front(typename ::std::deque<_Tp, _Alloc>::size_type __new_elems);
      void _M_new_elements_at_back(typename ::std::deque<_Tp, _Alloc>::size_type __new_elems);
      inline void _M_reserve_map_at_back(typename ::std::deque<_Tp, _Alloc>::size_type __nodes_to_add  = (1))
      {
        if (__nodes_to_add + 1 > this->_M_impl._M_map_size - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
          {
            (*this)._M_reallocate_map(__nodes_to_add, false);
          }
      }
      inline void _M_reserve_map_at_front(typename ::std::deque<_Tp, _Alloc>::size_type __nodes_to_add  = (1))
      {
        if (__nodes_to_add > ((typename ::std::deque<_Tp, _Alloc>::size_type(this->_M_impl._M_start._M_node - this->_M_impl._M_map))))
          {
            (*this)._M_reallocate_map(__nodes_to_add, true);
          }
      }
      void _M_reallocate_map(typename ::std::deque<_Tp, _Alloc>::size_type __nodes_to_add, bool __add_at_front);
  };
  template < typename _Tp, typename _Alloc >
  inline bool operator ==(const ::std::deque<_Tp, _Alloc> &__x, const ::std::deque<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator ==(const ::std::deque<_Tp, _Alloc> &__x, const ::std::deque<_Tp, _Alloc> &__y)
  {
    return __x.size() == __y.size() && std::equal(__x.begin(), __x.end(), __y.begin());
  }
  template < typename _Tp, typename _Alloc >
  inline bool operator <(const ::std::deque<_Tp, _Alloc> &__x, const ::std::deque<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator <(const ::std::deque<_Tp, _Alloc> &__x, const ::std::deque<_Tp, _Alloc> &__y)
  {
    return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
  }
  template < typename _Tp, typename _Alloc >
  inline bool operator !=(const ::std::deque<_Tp, _Alloc> &__x, const ::std::deque<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator !=(const ::std::deque<_Tp, _Alloc> &__x, const ::std::deque<_Tp, _Alloc> &__y)
  {
    return !(__x == __y);
  }
  template < typename _Tp, typename _Alloc >
  inline bool operator >(const ::std::deque<_Tp, _Alloc> &__x, const ::std::deque<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator >(const ::std::deque<_Tp, _Alloc> &__x, const ::std::deque<_Tp, _Alloc> &__y)
  {
    return __y < __x;
  }
  template < typename _Tp, typename _Alloc >
  inline bool operator <=(const ::std::deque<_Tp, _Alloc> &__x, const ::std::deque<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator <=(const ::std::deque<_Tp, _Alloc> &__x, const ::std::deque<_Tp, _Alloc> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Tp, typename _Alloc >
  inline bool operator >=(const ::std::deque<_Tp, _Alloc> &__x, const ::std::deque<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator >=(const ::std::deque<_Tp, _Alloc> &__x, const ::std::deque<_Tp, _Alloc> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Tp, typename _Alloc >
  inline void swap(::std::deque<_Tp, _Alloc> &__x, ::std::deque<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline void swap(::std::deque<_Tp, _Alloc> &__x, ::std::deque<_Tp, _Alloc> &__y)
  {
    __x.swap(__y);
  }
  template < typename _Tp, typename _Alloc >
  ::std::deque<_Tp, _Alloc> &deque<_Tp, _Alloc>::operator =(const ::std::deque<_Tp, _Alloc> &__x)
  {
    if (&__x != this)
      {
        const typename ::std::deque<_Tp, _Alloc>::size_type __len = (*this).size();
        if (__len >= __x.size())
          {
            (*this)._M_erase_at_end(std::copy(__x.begin(), __x.end(), this->_M_impl._M_start));
          }
        else
          {
            typename ::std::deque<_Tp, _Alloc>::const_iterator __mid = __x.begin() + (typename ::std::deque<_Tp, _Alloc>::difference_type)__len;
            std::copy(__x.begin(), __mid, this->_M_impl._M_start);
            (*this)._M_range_insert_aux(this->_M_impl._M_finish, __mid, __x.end(), ::std::random_access_iterator_tag());
          }
      }
    return *this;
  }
  template < typename _Tp, typename _Alloc >
  typename ::std::deque<_Tp, _Alloc>::iterator deque<_Tp, _Alloc>::insert(typename ::std::deque<_Tp, _Alloc>::iterator __position, const typename ::std::deque<_Tp, _Alloc>::value_type &__x)
  {
    if (__position._M_cur == this->_M_impl._M_start._M_cur)
      {
        (*this).push_front(__x);
        return this->_M_impl._M_start;
      }
    else
      {
        if (__position._M_cur == this->_M_impl._M_finish._M_cur)
          {
            (*this).push_back(__x);
            typename ::std::deque<_Tp, _Alloc>::iterator __tmp = this->_M_impl._M_finish;
             --__tmp;
            return __tmp;
          }
        else
          {
            return (*this)._M_insert_aux(__position._M_const_cast(), __x);
          }
      }
  }
  template < typename _Tp, typename _Alloc >
  typename ::std::deque<_Tp, _Alloc>::iterator deque<_Tp, _Alloc>::_M_erase(typename ::std::deque<_Tp, _Alloc>::iterator __position)
  {
    typename ::std::deque<_Tp, _Alloc>::iterator __next = __position;
     ++__next;
    const typename ::std::deque<_Tp, _Alloc>::difference_type __index = __position - (*this).begin();
    if (static_cast<typename ::std::deque<_Tp, _Alloc>::size_type>(__index) < (*this).size() >> 1)
      {
        if (__position != (*this).begin())
          {
            std::copy_backward((*this).begin(), __position, __next);
          }
        (*this).pop_front();
      }
    else
      {
        if (__next != (*this).end())
          {
            std::copy(__next, (*this).end(), __position);
          }
        (*this).pop_back();
      }
    return (*this).begin() + __index;
  }
  template < typename _Tp, typename _Alloc >
  typename ::std::deque<_Tp, _Alloc>::iterator deque<_Tp, _Alloc>::_M_erase(typename ::std::deque<_Tp, _Alloc>::iterator __first, typename ::std::deque<_Tp, _Alloc>::iterator __last)
  {
    if (__first == __last)
      {
        return __first;
      }
    else
      {
        if (__first == (*this).begin() && __last == (*this).end())
          {
            (*this).clear();
            return (*this).end();
          }
        else
          {
            const typename ::std::deque<_Tp, _Alloc>::difference_type __n = __last - __first;
            const typename ::std::deque<_Tp, _Alloc>::difference_type __elems_before = __first - (*this).begin();
            if (static_cast<typename ::std::deque<_Tp, _Alloc>::size_type>(__elems_before) <= ((*this).size() - __n) / 2)
              {
                if (__first != (*this).begin())
                  {
                    std::copy_backward((*this).begin(), __first, __last);
                  }
                (*this)._M_erase_at_begin((*this).begin() + __n);
              }
            else
              {
                if (__last != (*this).end())
                  {
                    std::copy(__last, (*this).end(), __first);
                  }
                (*this)._M_erase_at_end((*this).end() - __n);
              }
            return (*this).begin() + __elems_before;
          }
      }
  }
  template < typename _Tp, typename _Alloc >
  template < typename _InputIterator >
  void deque<_Tp, _Alloc>::_M_assign_aux(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag)
  {
    typename ::std::deque<_Tp, _Alloc>::iterator __cur = (*this).begin();
    for (; __first != __last && __cur != (*this).end(); ( ++__cur,  ++__first))
      {
        *__cur = *__first;
      }
    if (__first == __last)
      {
        (*this)._M_erase_at_end(__cur);
      }
    else
      {
        (*this)._M_range_insert_aux((*this).end(), __first, __last, std::__iterator_category(__first));
      }
  }
  template < typename _Tp, typename _Alloc >
  void deque<_Tp, _Alloc>::_M_fill_insert(typename ::std::deque<_Tp, _Alloc>::iterator __pos, typename ::std::deque<_Tp, _Alloc>::size_type __n, const typename ::std::deque<_Tp, _Alloc>::value_type &__x)
  {
    if (__pos._M_cur == this->_M_impl._M_start._M_cur)
      {
        typename ::std::deque<_Tp, _Alloc>::iterator __new_start = (*this)._M_reserve_elements_at_front(__n);
        try
        {
          std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start, __x, (_M_get_Tp_allocator)());
          this->_M_impl._M_start = __new_start;
        }
        catch (...)
        {
          _M_destroy_nodes(__new_start._M_node, this->_M_impl._M_start._M_node);
          throw;
        }
      }
    else
      {
        if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
          {
            typename ::std::deque<_Tp, _Alloc>::iterator __new_finish = (*this)._M_reserve_elements_at_back(__n);
            try
            {
              std::__uninitialized_fill_a(this->_M_impl._M_finish, __new_finish, __x, (_M_get_Tp_allocator)());
              this->_M_impl._M_finish = __new_finish;
            }
            catch (...)
            {
              _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1, __new_finish._M_node + 1);
              throw;
            }
          }
        else
          {
            (*this)._M_insert_aux(__pos, __n, __x);
          }
      }
  }
  template < typename _Tp, typename _Alloc >
  void deque<_Tp, _Alloc>::_M_fill_initialize(const typename ::std::deque<_Tp, _Alloc>::value_type &__value)
  {
    typename ::std::deque<_Tp, _Alloc>::_Map_pointer __cur;
    try
    {
      for (__cur = this->_M_impl._M_start._M_node; __cur < this->_M_impl._M_finish._M_node;  ++__cur)
        {
          std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(), __value, (_M_get_Tp_allocator)());
        }
      std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first, this->_M_impl._M_finish._M_cur, __value, (_M_get_Tp_allocator)());
    }
    catch (...)
    {
      std::_Destroy(this->_M_impl._M_start, ((typename ::std::deque<_Tp, _Alloc>::iterator(*__cur, __cur))), (_M_get_Tp_allocator)());
      throw;
    }
  }
  template < typename _Tp, typename _Alloc >
  template < typename _InputIterator >
  void deque<_Tp, _Alloc>::_M_range_initialize(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag)
  {
    this->_M_initialize_map(0);
    try
    {
      for (; __first != __last;  ++__first)
        {
          (*this).push_back(*__first);
        }
    }
    catch (...)
    {
      (*this).clear();
      throw;
    }
  }
  template < typename _Tp, typename _Alloc >
  template < typename _ForwardIterator >
  void deque<_Tp, _Alloc>::_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag)
  {
    const typename ::std::deque<_Tp, _Alloc>::size_type __n = std::distance(__first, __last);
    this->_M_initialize_map(__n);
    typename ::std::deque<_Tp, _Alloc>::_Map_pointer __cur_node;
    try
    {
      for (__cur_node = this->_M_impl._M_start._M_node; __cur_node < this->_M_impl._M_finish._M_node;  ++__cur_node)
        {
          _ForwardIterator __mid = __first;
          std::advance(__mid, _S_buffer_size());
          std::__uninitialized_copy_a(__first, __mid, *__cur_node, (_M_get_Tp_allocator)());
          __first = __mid;
        }
      std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_finish._M_first, (_M_get_Tp_allocator)());
    }
    catch (...)
    {
      std::_Destroy(this->_M_impl._M_start, ((typename ::std::deque<_Tp, _Alloc>::iterator(*__cur_node, __cur_node))), (_M_get_Tp_allocator)());
      throw;
    }
  }
  template < typename _Tp, typename _Alloc >
  void deque<_Tp, _Alloc>::_M_push_back_aux(const typename ::std::deque<_Tp, _Alloc>::value_type &__t)
  {
    (*this)._M_reserve_map_at_back();
    *(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
    try
    {
      this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __t);
      this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node + 1);
      this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
    }
    catch (...)
    {
      _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
      throw;
    }
  }
  template < typename _Tp, typename _Alloc >
  void deque<_Tp, _Alloc>::_M_push_front_aux(const typename ::std::deque<_Tp, _Alloc>::value_type &__t)
  {
    (*this)._M_reserve_map_at_front();
    *(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();
    try
    {
      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node - 1);
      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;
      this->_M_impl.construct(this->_M_impl._M_start._M_cur, __t);
    }
    catch (...)
    {
       ++this->_M_impl._M_start;
      _M_deallocate_node(*(this->_M_impl._M_start._M_node - 1));
      throw;
    }
  }
  template < typename _Tp, typename _Alloc >
  void deque<_Tp, _Alloc>::_M_pop_back_aux()
  {
    _M_deallocate_node(this->_M_impl._M_finish._M_first);
    this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);
    this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;
    _Alloc_traits::destroy((_M_get_Tp_allocator)(), this->_M_impl._M_finish._M_cur);
  }
  template < typename _Tp, typename _Alloc >
  void deque<_Tp, _Alloc>::_M_pop_front_aux()
  {
    _Alloc_traits::destroy((_M_get_Tp_allocator)(), this->_M_impl._M_start._M_cur);
    _M_deallocate_node(this->_M_impl._M_start._M_first);
    this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
    this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
  }
  template < typename _Tp, typename _Alloc >
  template < typename _InputIterator >
  void deque<_Tp, _Alloc>::_M_range_insert_aux(typename ::std::deque<_Tp, _Alloc>::iterator __pos, _InputIterator __first, _InputIterator __last, ::std::input_iterator_tag)
  {
    std::copy(__first, __last, std::inserter(*this, __pos));
  }
  template < typename _Tp, typename _Alloc >
  template < typename _ForwardIterator >
  void deque<_Tp, _Alloc>::_M_range_insert_aux(typename ::std::deque<_Tp, _Alloc>::iterator __pos, _ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag)
  {
    const typename ::std::deque<_Tp, _Alloc>::size_type __n = std::distance(__first, __last);
    if (__pos._M_cur == this->_M_impl._M_start._M_cur)
      {
        typename ::std::deque<_Tp, _Alloc>::iterator __new_start = (*this)._M_reserve_elements_at_front(__n);
        try
        {
          std::__uninitialized_copy_a(__first, __last, __new_start, (_M_get_Tp_allocator)());
          this->_M_impl._M_start = __new_start;
        }
        catch (...)
        {
          _M_destroy_nodes(__new_start._M_node, this->_M_impl._M_start._M_node);
          throw;
        }
      }
    else
      {
        if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
          {
            typename ::std::deque<_Tp, _Alloc>::iterator __new_finish = (*this)._M_reserve_elements_at_back(__n);
            try
            {
              std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
              this->_M_impl._M_finish = __new_finish;
            }
            catch (...)
            {
              _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1, __new_finish._M_node + 1);
              throw;
            }
          }
        else
          {
            (*this)._M_insert_aux(__pos, __first, __last, __n);
          }
      }
  }
  template < typename _Tp, typename _Alloc >
  typename ::std::deque<_Tp, _Alloc>::iterator deque<_Tp, _Alloc>::_M_insert_aux(typename ::std::deque<_Tp, _Alloc>::iterator __pos, const typename ::std::deque<_Tp, _Alloc>::value_type &__x)
  {
    typename ::std::deque<_Tp, _Alloc>::value_type __x_copy = __x;
    typename ::std::deque<_Tp, _Alloc>::difference_type __index = __pos - this->_M_impl._M_start;
    if (static_cast<typename ::std::deque<_Tp, _Alloc>::size_type>(__index) < (*this).size() / 2)
      {
        (*this).push_front((*this).front());
        typename ::std::deque<_Tp, _Alloc>::iterator __front1 = this->_M_impl._M_start;
         ++__front1;
        typename ::std::deque<_Tp, _Alloc>::iterator __front2 = __front1;
         ++__front2;
        __pos = this->_M_impl._M_start + __index;
        typename ::std::deque<_Tp, _Alloc>::iterator __pos1 = __pos;
         ++__pos1;
        std::copy(__front2, __pos1, __front1);
      }
    else
      {
        (*this).push_back((*this).back());
        typename ::std::deque<_Tp, _Alloc>::iterator __back1 = this->_M_impl._M_finish;
         --__back1;
        typename ::std::deque<_Tp, _Alloc>::iterator __back2 = __back1;
         --__back2;
        __pos = this->_M_impl._M_start + __index;
        std::copy_backward(__pos, __back2, __back1);
      }
    *__pos = __x_copy;
    return __pos;
  }
  template < typename _Tp, typename _Alloc >
  void deque<_Tp, _Alloc>::_M_insert_aux(typename ::std::deque<_Tp, _Alloc>::iterator __pos, typename ::std::deque<_Tp, _Alloc>::size_type __n, const typename ::std::deque<_Tp, _Alloc>::value_type &__x)
  {
    const typename ::std::deque<_Tp, _Alloc>::difference_type __elems_before = __pos - this->_M_impl._M_start;
    const typename ::std::deque<_Tp, _Alloc>::size_type __length = this->size();
    typename ::std::deque<_Tp, _Alloc>::value_type __x_copy = __x;
    if (__elems_before < (typename ::std::deque<_Tp, _Alloc>::difference_type)(__length / 2))
      {
        typename ::std::deque<_Tp, _Alloc>::iterator __new_start = (*this)._M_reserve_elements_at_front(__n);
        typename ::std::deque<_Tp, _Alloc>::iterator __old_start = this->_M_impl._M_start;
        __pos = this->_M_impl._M_start + __elems_before;
        try
        {
          if (__elems_before >= (typename ::std::deque<_Tp, _Alloc>::difference_type)__n)
            {
              typename ::std::deque<_Tp, _Alloc>::iterator __start_n = (this->_M_impl._M_start + (typename ::std::deque<_Tp, _Alloc>::difference_type)__n);
              std::__uninitialized_move_a(this->_M_impl._M_start, __start_n, __new_start, (_M_get_Tp_allocator)());
              this->_M_impl._M_start = __new_start;
              std::copy(__start_n, __pos, __old_start);
              std::fill(__pos - (typename ::std::deque<_Tp, _Alloc>::difference_type)__n, __pos, __x_copy);
            }
          else
            {
              std::__uninitialized_move_fill(this->_M_impl._M_start, __pos, __new_start, this->_M_impl._M_start, __x_copy, (_M_get_Tp_allocator)());
              this->_M_impl._M_start = __new_start;
              std::fill(__old_start, __pos, __x_copy);
            }
        }
        catch (...)
        {
          _M_destroy_nodes(__new_start._M_node, this->_M_impl._M_start._M_node);
          throw;
        }
      }
    else
      {
        typename ::std::deque<_Tp, _Alloc>::iterator __new_finish = (*this)._M_reserve_elements_at_back(__n);
        typename ::std::deque<_Tp, _Alloc>::iterator __old_finish = this->_M_impl._M_finish;
        const typename ::std::deque<_Tp, _Alloc>::difference_type __elems_after = (typename ::std::deque<_Tp, _Alloc>::difference_type)__length - __elems_before;
        __pos = this->_M_impl._M_finish - __elems_after;
        try
        {
          if (__elems_after > (typename ::std::deque<_Tp, _Alloc>::difference_type)__n)
            {
              typename ::std::deque<_Tp, _Alloc>::iterator __finish_n = (this->_M_impl._M_finish - (typename ::std::deque<_Tp, _Alloc>::difference_type)__n);
              std::__uninitialized_move_a(__finish_n, this->_M_impl._M_finish, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
              this->_M_impl._M_finish = __new_finish;
              std::copy_backward(__pos, __finish_n, __old_finish);
              std::fill(__pos, __pos + (typename ::std::deque<_Tp, _Alloc>::difference_type)__n, __x_copy);
            }
          else
            {
              std::__uninitialized_fill_move(this->_M_impl._M_finish, __pos + (typename ::std::deque<_Tp, _Alloc>::difference_type)__n, __x_copy, __pos, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
              this->_M_impl._M_finish = __new_finish;
              std::fill(__pos, __old_finish, __x_copy);
            }
        }
        catch (...)
        {
          _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1, __new_finish._M_node + 1);
          throw;
        }
      }
  }
  template < typename _Tp, typename _Alloc >
  template < typename _ForwardIterator >
  void deque<_Tp, _Alloc>::_M_insert_aux(typename ::std::deque<_Tp, _Alloc>::iterator __pos, _ForwardIterator __first, _ForwardIterator __last, typename ::std::deque<_Tp, _Alloc>::size_type __n)
  {
    const typename ::std::deque<_Tp, _Alloc>::difference_type __elemsbefore = __pos - this->_M_impl._M_start;
    const typename ::std::deque<_Tp, _Alloc>::size_type __length = (*this).size();
    if (static_cast<typename ::std::deque<_Tp, _Alloc>::size_type>(__elemsbefore) < __length / 2)
      {
        typename ::std::deque<_Tp, _Alloc>::iterator __new_start = (*this)._M_reserve_elements_at_front(__n);
        typename ::std::deque<_Tp, _Alloc>::iterator __old_start = this->_M_impl._M_start;
        __pos = this->_M_impl._M_start + __elemsbefore;
        try
        {
          if (__elemsbefore >= (typename ::std::deque<_Tp, _Alloc>::difference_type)__n)
            {
              typename ::std::deque<_Tp, _Alloc>::iterator __start_n = (this->_M_impl._M_start + (typename ::std::deque<_Tp, _Alloc>::difference_type)__n);
              std::__uninitialized_move_a(this->_M_impl._M_start, __start_n, __new_start, (_M_get_Tp_allocator)());
              this->_M_impl._M_start = __new_start;
              std::copy(__start_n, __pos, __old_start);
              std::copy(__first, __last, __pos - (typename ::std::deque<_Tp, _Alloc>::difference_type)__n);
            }
          else
            {
              _ForwardIterator __mid = __first;
              std::advance(__mid, (typename ::std::deque<_Tp, _Alloc>::difference_type)__n - __elemsbefore);
              std::__uninitialized_move_copy(this->_M_impl._M_start, __pos, __first, __mid, __new_start, (_M_get_Tp_allocator)());
              this->_M_impl._M_start = __new_start;
              std::copy(__mid, __last, __old_start);
            }
        }
        catch (...)
        {
          _M_destroy_nodes(__new_start._M_node, this->_M_impl._M_start._M_node);
          throw;
        }
      }
    else
      {
        typename ::std::deque<_Tp, _Alloc>::iterator __new_finish = (*this)._M_reserve_elements_at_back(__n);
        typename ::std::deque<_Tp, _Alloc>::iterator __old_finish = this->_M_impl._M_finish;
        const typename ::std::deque<_Tp, _Alloc>::difference_type __elemsafter = (typename ::std::deque<_Tp, _Alloc>::difference_type)__length - __elemsbefore;
        __pos = this->_M_impl._M_finish - __elemsafter;
        try
        {
          if (__elemsafter > (typename ::std::deque<_Tp, _Alloc>::difference_type)__n)
            {
              typename ::std::deque<_Tp, _Alloc>::iterator __finish_n = (this->_M_impl._M_finish - (typename ::std::deque<_Tp, _Alloc>::difference_type)__n);
              std::__uninitialized_move_a(__finish_n, this->_M_impl._M_finish, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
              this->_M_impl._M_finish = __new_finish;
              std::copy_backward(__pos, __finish_n, __old_finish);
              std::copy(__first, __last, __pos);
            }
          else
            {
              _ForwardIterator __mid = __first;
              std::advance(__mid, __elemsafter);
              std::__uninitialized_copy_move(__mid, __last, __pos, this->_M_impl._M_finish, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
              this->_M_impl._M_finish = __new_finish;
              std::copy(__first, __mid, __pos);
            }
        }
        catch (...)
        {
          _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1, __new_finish._M_node + 1);
          throw;
        }
      }
  }
  template < typename _Tp, typename _Alloc >
  void deque<_Tp, _Alloc>::_M_destroy_data_aux(typename ::std::deque<_Tp, _Alloc>::iterator __first, typename ::std::deque<_Tp, _Alloc>::iterator __last)
  {
    for (typename ::std::deque<_Tp, _Alloc>::_Map_pointer __node = __first._M_node + 1; __node < __last._M_node;  ++__node)
      {
        std::_Destroy(*__node, *__node + _S_buffer_size(), (_M_get_Tp_allocator)());
      }
    if (__first._M_node != __last._M_node)
      {
        std::_Destroy(__first._M_cur, __first._M_last, (_M_get_Tp_allocator)());
        std::_Destroy(__last._M_first, __last._M_cur, (_M_get_Tp_allocator)());
      }
    else
      {
        std::_Destroy(__first._M_cur, __last._M_cur, (_M_get_Tp_allocator)());
      }
  }
  template < typename _Tp, typename _Alloc >
  void deque<_Tp, _Alloc>::_M_new_elements_at_front(typename ::std::deque<_Tp, _Alloc>::size_type __new_elems)
  {
    if (this->max_size() - this->size() < __new_elems)
      {
        ::std::__throw_length_error("deque::_M_new_elements_at_front");
      }
    const typename ::std::deque<_Tp, _Alloc>::size_type __new_nodes = (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();
    (*this)._M_reserve_map_at_front(__new_nodes);
    typename ::std::deque<_Tp, _Alloc>::size_type __i;
    try
    {
      for (__i = 1; __i <= __new_nodes;  ++__i)
        {
          *(this->_M_impl._M_start._M_node - __i) = this->_M_allocate_node();
        }
    }
    catch (...)
    {
      for (typename ::std::deque<_Tp, _Alloc>::size_type __j(1); __j < __i;  ++__j)
        {
          _M_deallocate_node(*(this->_M_impl._M_start._M_node - __j));
        }
      throw;
    }
  }
  template < typename _Tp, typename _Alloc >
  void deque<_Tp, _Alloc>::_M_new_elements_at_back(typename ::std::deque<_Tp, _Alloc>::size_type __new_elems)
  {
    if (this->max_size() - this->size() < __new_elems)
      {
        ::std::__throw_length_error("deque::_M_new_elements_at_back");
      }
    const typename ::std::deque<_Tp, _Alloc>::size_type __new_nodes = (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();
    (*this)._M_reserve_map_at_back(__new_nodes);
    typename ::std::deque<_Tp, _Alloc>::size_type __i;
    try
    {
      for (__i = 1; __i <= __new_nodes;  ++__i)
        {
          *(this->_M_impl._M_finish._M_node + __i) = this->_M_allocate_node();
        }
    }
    catch (...)
    {
      for (typename ::std::deque<_Tp, _Alloc>::size_type __j(1); __j < __i;  ++__j)
        {
          _M_deallocate_node(*(this->_M_impl._M_finish._M_node + __j));
        }
      throw;
    }
  }
  template < typename _Tp, typename _Alloc >
  void deque<_Tp, _Alloc>::_M_reallocate_map(typename ::std::deque<_Tp, _Alloc>::size_type __nodes_to_add, bool __add_at_front)
  {
    const typename ::std::deque<_Tp, _Alloc>::size_type __old_num_nodes = this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
    const typename ::std::deque<_Tp, _Alloc>::size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;
    typename ::std::deque<_Tp, _Alloc>::_Map_pointer __new_nstart;
    if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
      {
        __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size - __new_num_nodes) / 2 + (__add_at_front ? __nodes_to_add : 0);
        if (__new_nstart < this->_M_impl._M_start._M_node)
          {
            std::copy(this->_M_impl._M_start._M_node, this->_M_impl._M_finish._M_node + 1, __new_nstart);
          }
        else
          {
            std::copy_backward(this->_M_impl._M_start._M_node, this->_M_impl._M_finish._M_node + 1, __new_nstart + __old_num_nodes);
          }
      }
    else
      {
        typename ::std::deque<_Tp, _Alloc>::size_type __new_map_size = this->_M_impl._M_map_size + std::max(this->_M_impl._M_map_size, __nodes_to_add) + 2;
        typename ::std::deque<_Tp, _Alloc>::_Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
        __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2 + (__add_at_front ? __nodes_to_add : 0);
        std::copy(this->_M_impl._M_start._M_node, this->_M_impl._M_finish._M_node + 1, __new_nstart);
        _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
        this->_M_impl._M_map = __new_map;
        this->_M_impl._M_map_size = __new_map_size;
      }
    this->_M_impl._M_start._M_set_node(__new_nstart);
    this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
  }
  template < typename _Tp >
  void fill(const ::std::_Deque_iterator<_Tp, _Tp &, _Tp *> &__first, const ::std::_Deque_iterator<_Tp, _Tp &, _Tp *> &__last, const _Tp &__value)
  {
    typedef typename ::std::_Deque_iterator<_Tp, _Tp &, _Tp *>::_Self _Self;
    for (typename ::std::_Deque_iterator<_Tp, _Tp &, _Tp *>::_Self::_Map_pointer __node = __first._M_node + 1; __node < __last._M_node;  ++__node)
      {
        std::fill(*__node, *__node + _Self::_S_buffer_size(), __value);
      }
    if (__first._M_node != __last._M_node)
      {
        std::fill(__first._M_cur, __first._M_last, __value);
        std::fill(__last._M_first, __last._M_cur, __value);
      }
    else
      {
        std::fill(__first._M_cur, __last._M_cur, __value);
      }
  }
  template < typename _Tp >
  ::std::_Deque_iterator<_Tp, _Tp &, _Tp *> copy(::std::_Deque_iterator<_Tp, const _Tp &, const _Tp *> __first, ::std::_Deque_iterator<_Tp, const _Tp &, const _Tp *> __last, ::std::_Deque_iterator<_Tp, _Tp &, _Tp *> __result)
  {
    typedef typename ::std::_Deque_iterator<_Tp, _Tp &, _Tp *>::_Self _Self;
    typedef typename ::std::_Deque_iterator<_Tp, _Tp &, _Tp *>::_Self::difference_type difference_type;
    difference_type __len = __last - __first;
    while (__len > 0)
      {
        const difference_type __clen = std::min(__len, std::min(__first._M_last - __first._M_cur, __result._M_last - __result._M_cur));
        std::copy(__first._M_cur, __first._M_cur + __clen, __result._M_cur);
        __first += __clen;
        __result += __clen;
        __len -= __clen;
      }
    return __result;
  }
  template < typename _Tp >
  ::std::_Deque_iterator<_Tp, _Tp &, _Tp *> copy_backward(::std::_Deque_iterator<_Tp, const _Tp &, const _Tp *> __first, ::std::_Deque_iterator<_Tp, const _Tp &, const _Tp *> __last, ::std::_Deque_iterator<_Tp, _Tp &, _Tp *> __result)
  {
    typedef typename ::std::_Deque_iterator<_Tp, _Tp &, _Tp *>::_Self _Self;
    typedef typename ::std::_Deque_iterator<_Tp, _Tp &, _Tp *>::_Self::difference_type difference_type;
    difference_type __len = __last - __first;
    while (__len > 0)
      {
        difference_type __llen = __last._M_cur - __last._M_first;
        _Tp *__lend = __last._M_cur;
        difference_type __rlen = __result._M_cur - __result._M_first;
        _Tp *__rend = __result._M_cur;
        if (!__llen)
          {
            __llen = _Self::_S_buffer_size();
            __lend = *(__last._M_node - 1) + __llen;
          }
        if (!__rlen)
          {
            __rlen = _Self::_S_buffer_size();
            __rend = *(__result._M_node - 1) + __rlen;
          }
        const difference_type __clen = std::min(__len, std::min(__llen, __rlen));
        std::copy_backward(__lend - __clen, __lend, __rend);
        __last -= __clen;
        __result -= __clen;
        __len -= __clen;
      }
    return __result;
  }
  template < typename _Tp, typename _Alloc >
  struct  _Vector_base
  {
      typedef typename ::__gnu_cxx::__alloc_traits<_Alloc>::template rebind< _Tp>::other _Tp_alloc_type;
      typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type>::pointer pointer;
      struct  _Vector_impl : ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type
      {
          typename ::std::_Vector_base<_Tp, _Alloc>::pointer _M_start;
          typename ::std::_Vector_base<_Tp, _Alloc>::pointer _M_finish;
          typename ::std::_Vector_base<_Tp, _Alloc>::pointer _M_end_of_storage;
          inline _Vector_impl()
            : _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
          {
          }
          inline _Vector_impl(const typename ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type &__a)
            : _Tp_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()
          {
          }
          inline void _M_swap_data(typename ::std::_Vector_base<_Tp, _Alloc>::_Vector_impl &__x)
          {
            std::swap(::std::_Vector_base<_Tp, _Alloc>::_Vector_impl::_M_start, __x._M_start);
            std::swap(::std::_Vector_base<_Tp, _Alloc>::_Vector_impl::_M_finish, __x._M_finish);
            std::swap(::std::_Vector_base<_Tp, _Alloc>::_Vector_impl::_M_end_of_storage, __x._M_end_of_storage);
          }
      };
      typedef _Alloc allocator_type;
      inline typename ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type &_M_get_Tp_allocator()
      {
        return *static_cast<typename ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type *>(&this->_M_impl);
      }
      inline const typename ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type &_M_get_Tp_allocator() const 
      {
        return *static_cast<const typename ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type *>(&this->_M_impl);
      }
      inline typename ::std::_Vector_base<_Tp, _Alloc>::allocator_type get_allocator() const 
      {
        return ((typename ::std::_Vector_base<_Tp, _Alloc>::allocator_type((*this)._M_get_Tp_allocator())));
      }
      inline _Vector_base()
        : _M_impl()
      {
      }
      inline _Vector_base(const typename ::std::_Vector_base<_Tp, _Alloc>::allocator_type &__a)
        : _M_impl(__a)
      {
      }
      inline _Vector_base(::std::size_t __n)
        : _M_impl()
      {
        (*this)._M_create_storage(__n);
      }
      inline _Vector_base(::std::size_t __n, const typename ::std::_Vector_base<_Tp, _Alloc>::allocator_type &__a)
        : _M_impl(__a)
      {
        (*this)._M_create_storage(__n);
      }
      inline ~_Vector_base()
      {
        (*this)._M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
      }
      typename ::std::_Vector_base<_Tp, _Alloc>::_Vector_impl _M_impl;
      inline typename ::std::_Vector_base<_Tp, _Alloc>::pointer _M_allocate(::std::size_t __n)
      {
        typedef ::__gnu_cxx::__alloc_traits<typename ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type> _Tr;
        return __n != 0 ? _Tr::allocate(::std::_Vector_base<_Tp, _Alloc>::_M_impl, __n) : ((typename ::std::_Vector_base<_Tp, _Alloc>::pointer()));
      }
      inline void _M_deallocate(typename ::std::_Vector_base<_Tp, _Alloc>::pointer __p, ::std::size_t __n)
      {
        typedef ::__gnu_cxx::__alloc_traits<typename ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type> _Tr;
        if (__p)
          {
            _Tr::deallocate(::std::_Vector_base<_Tp, _Alloc>::_M_impl, __p, __n);
          }
      }
    private:
      inline void _M_create_storage(::std::size_t __n)
      {
        this->_M_impl._M_start = this->_M_allocate(__n);
        this->_M_impl._M_finish = this->_M_impl._M_start;
        this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
  };
  template < typename _Tp, typename _Alloc = ::std::allocator<_Tp> >
  class  vector : protected ::std::_Vector_base<_Tp, _Alloc>
  {
      typedef ::std::_Vector_base<_Tp, _Alloc> _Base;
      typedef typename ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type _Tp_alloc_type;
      typedef ::__gnu_cxx::__alloc_traits<typename ::std::vector<_Tp, _Alloc>::_Tp_alloc_type> _Alloc_traits;
    public:
      typedef _Tp value_type;
      typedef typename ::std::_Vector_base<_Tp, _Alloc>::pointer pointer;
      typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::vector<_Tp, _Alloc>::_Tp_alloc_type>::const_pointer const_pointer;
      typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::vector<_Tp, _Alloc>::_Tp_alloc_type>::reference reference;
      typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::vector<_Tp, _Alloc>::_Tp_alloc_type>::const_reference const_reference;
      typedef ::__gnu_cxx::__normal_iterator<typename ::std::vector<_Tp, _Alloc>::pointer, ::std::vector<_Tp, _Alloc> > iterator;
      typedef ::__gnu_cxx::__normal_iterator<typename ::std::vector<_Tp, _Alloc>::const_pointer, ::std::vector<_Tp, _Alloc> > const_iterator;
      typedef ::std::reverse_iterator<typename ::std::vector<_Tp, _Alloc>::const_iterator> const_reverse_iterator;
      typedef ::std::reverse_iterator<typename ::std::vector<_Tp, _Alloc>::iterator> reverse_iterator;
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef _Alloc allocator_type;
    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;
    public:
      inline vector()
        : _Base()
      {
      }
      inline explicit vector(const typename ::std::vector<_Tp, _Alloc>::allocator_type &__a)
        : _Base(__a)
      {
      }
      inline explicit vector(typename ::std::vector<_Tp, _Alloc>::size_type __n, const typename ::std::vector<_Tp, _Alloc>::value_type &__value  = (((typename ::std::vector<_Tp, _Alloc>::value_type()))), const typename ::std::vector<_Tp, _Alloc>::allocator_type &__a  = (((typename ::std::vector<_Tp, _Alloc>::allocator_type()))))
        : _Base(__n, __a)
      {
        (*this)._M_fill_initialize(__n, __value);
      }
      inline vector(const ::std::vector<_Tp, _Alloc> &__x)
        : _Base(__x.size(), _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      {
        this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, (_M_get_Tp_allocator)());
      }
      template < typename _InputIterator >
      inline vector(_InputIterator __first, _InputIterator __last, const typename ::std::vector<_Tp, _Alloc>::allocator_type &__a  = (((typename ::std::vector<_Tp, _Alloc>::allocator_type()))))
        : _Base(__a)
      {
        typedef typename ::std::__is_integer<_InputIterator>::__type _Integral;
        (*this)._M_initialize_dispatch(__first, __last, _Integral());
      }
      inline ~vector()
      {
        std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
      }
      ::std::vector<_Tp, _Alloc> &operator =(const ::std::vector<_Tp, _Alloc> &__x);
      inline void assign(typename ::std::vector<_Tp, _Alloc>::size_type __n, const typename ::std::vector<_Tp, _Alloc>::value_type &__val)
      {
        (*this)._M_fill_assign(__n, __val);
      }
      template < typename _InputIterator >
      inline void assign(_InputIterator __first, _InputIterator __last)
      {
        typedef typename ::std::__is_integer<_InputIterator>::__type _Integral;
        (*this)._M_assign_dispatch(__first, __last, _Integral());
      }
      using _Base::get_allocator;
      inline typename ::std::vector<_Tp, _Alloc>::iterator begin()
      {
        return ((typename ::std::vector<_Tp, _Alloc>::iterator(this->_M_impl._M_start)));
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_iterator begin() const 
      {
        return ((typename ::std::vector<_Tp, _Alloc>::const_iterator(this->_M_impl._M_start)));
      }
      inline typename ::std::vector<_Tp, _Alloc>::iterator end()
      {
        return ((typename ::std::vector<_Tp, _Alloc>::iterator(this->_M_impl._M_finish)));
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_iterator end() const 
      {
        return ((typename ::std::vector<_Tp, _Alloc>::const_iterator(this->_M_impl._M_finish)));
      }
      inline typename ::std::vector<_Tp, _Alloc>::reverse_iterator rbegin()
      {
        return ((typename ::std::vector<_Tp, _Alloc>::reverse_iterator((*this).end())));
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_reverse_iterator rbegin() const 
      {
        return ((typename ::std::vector<_Tp, _Alloc>::const_reverse_iterator((*this).end())));
      }
      inline typename ::std::vector<_Tp, _Alloc>::reverse_iterator rend()
      {
        return ((typename ::std::vector<_Tp, _Alloc>::reverse_iterator((*this).begin())));
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_reverse_iterator rend() const 
      {
        return ((typename ::std::vector<_Tp, _Alloc>::const_reverse_iterator((*this).begin())));
      }
      inline typename ::std::vector<_Tp, _Alloc>::size_type size() const 
      {
        return ((typename ::std::vector<_Tp, _Alloc>::size_type(this->_M_impl._M_finish - this->_M_impl._M_start)));
      }
      inline typename ::std::vector<_Tp, _Alloc>::size_type max_size() const 
      {
        return _Alloc_traits::max_size((_M_get_Tp_allocator)());
      }
      inline void resize(typename ::std::vector<_Tp, _Alloc>::size_type __new_size, typename ::std::vector<_Tp, _Alloc>::value_type __x  = (((typename ::std::vector<_Tp, _Alloc>::value_type()))))
      {
        if (__new_size > (*this).size())
          {
            (*this)._M_fill_insert((*this).end(), __new_size - (*this).size(), __x);
          }
        else
          {
            if (__new_size < (*this).size())
              {
                (*this)._M_erase_at_end(this->_M_impl._M_start + __new_size);
              }
          }
      }
      inline typename ::std::vector<_Tp, _Alloc>::size_type capacity() const 
      {
        return ((typename ::std::vector<_Tp, _Alloc>::size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_start)));
      }
      inline bool empty() const 
      {
        return (*this).begin() == (*this).end();
      }
      void reserve(typename ::std::vector<_Tp, _Alloc>::size_type __n);
      inline typename ::std::vector<_Tp, _Alloc>::reference operator [](typename ::std::vector<_Tp, _Alloc>::size_type __n)
      {
        ;
        return *(this->_M_impl._M_start + __n);
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_reference operator [](typename ::std::vector<_Tp, _Alloc>::size_type __n) const 
      {
        ;
        return *(this->_M_impl._M_start + __n);
      }
    protected:
      inline void _M_range_check(typename ::std::vector<_Tp, _Alloc>::size_type __n) const 
      {
        if (__n >= this->size())
          {
            __throw_out_of_range_fmt("vector::_M_range_check: __n (which is %zu) >= this->size() (which is %zu)", __n, this->size());
          }
      }
    public:
      inline typename ::std::vector<_Tp, _Alloc>::reference at(typename ::std::vector<_Tp, _Alloc>::size_type __n)
      {
        (*this)._M_range_check(__n);
        return (*this)[__n];
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_reference at(typename ::std::vector<_Tp, _Alloc>::size_type __n) const 
      {
        (*this)._M_range_check(__n);
        return (*this)[__n];
      }
      inline typename ::std::vector<_Tp, _Alloc>::reference front()
      {
        ;
        return *(*this).begin();
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_reference front() const 
      {
        ;
        return *(*this).begin();
      }
      inline typename ::std::vector<_Tp, _Alloc>::reference back()
      {
        ;
        return *((*this).end() - 1);
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_reference back() const 
      {
        ;
        return *((*this).end() - 1);
      }
      inline _Tp *data()
      {
        return (*this)._M_data_ptr(this->_M_impl._M_start);
      }
      inline const _Tp *data() const 
      {
        return (*this)._M_data_ptr(this->_M_impl._M_start);
      }
      inline void push_back(const typename ::std::vector<_Tp, _Alloc>::value_type &__x)
      {
        if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
          {
            _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
             ++this->_M_impl._M_finish;
          }
        else
          {
            (*this)._M_realloc_insert((*this).end(), __x);
          }
      }
      inline void pop_back()
      {
        ;
         --this->_M_impl._M_finish;
        _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      }
      typename ::std::vector<_Tp, _Alloc>::iterator insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, const typename ::std::vector<_Tp, _Alloc>::value_type &__x);
      inline void insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, typename ::std::vector<_Tp, _Alloc>::size_type __n, const typename ::std::vector<_Tp, _Alloc>::value_type &__x)
      {
        (*this)._M_fill_insert(__position, __n, __x);
      }
      template < typename _InputIterator >
      inline void insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, _InputIterator __first, _InputIterator __last)
      {
        typedef typename ::std::__is_integer<_InputIterator>::__type _Integral;
        (*this)._M_insert_dispatch(__position, __first, __last, _Integral());
      }
      inline typename ::std::vector<_Tp, _Alloc>::iterator erase(typename ::std::vector<_Tp, _Alloc>::iterator __position)
      {
        return (*this)._M_erase(__position);
      }
      inline typename ::std::vector<_Tp, _Alloc>::iterator erase(typename ::std::vector<_Tp, _Alloc>::iterator __first, typename ::std::vector<_Tp, _Alloc>::iterator __last)
      {
        return (*this)._M_erase(__first, __last);
      }
      inline void swap(::std::vector<_Tp, _Alloc> &__x)
      {
        this->_M_impl._M_swap_data(__x._M_impl);
        _Alloc_traits::_S_on_swap((_M_get_Tp_allocator)(), __x._M_get_Tp_allocator());
      }
      inline void clear()
      {
        (*this)._M_erase_at_end(this->_M_impl._M_start);
      }
    protected:
      template < typename _ForwardIterator >
      inline typename ::std::vector<_Tp, _Alloc>::pointer _M_allocate_and_copy(typename ::std::vector<_Tp, _Alloc>::size_type __n, _ForwardIterator __first, _ForwardIterator __last)
      {
        typename ::std::vector<_Tp, _Alloc>::pointer __result = this->_M_allocate(__n);
        try
        {
          std::__uninitialized_copy_a(__first, __last, __result, (_M_get_Tp_allocator)());
          return __result;
        }
        catch (...)
        {
          _M_deallocate(__result, __n);
          throw;
        }
      }
      template < typename _Integer >
      inline void _M_initialize_dispatch(_Integer __n, _Integer __value, ::std::__true_type)
      {
        this->_M_impl._M_start = (_M_allocate)(static_cast<typename ::std::vector<_Tp, _Alloc>::size_type>(__n));
        this->_M_impl._M_end_of_storage = this->_M_impl._M_start + static_cast<typename ::std::vector<_Tp, _Alloc>::size_type>(__n);
        (*this)._M_fill_initialize(static_cast<typename ::std::vector<_Tp, _Alloc>::size_type>(__n), __value);
      }
      template < typename _InputIterator >
      inline void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type)
      {
        typedef typename ::std::iterator_traits<_InputIterator>::iterator_category _IterCategory;
        (*this)._M_range_initialize(__first, __last, _IterCategory());
      }
      template < typename _InputIterator >
      inline void _M_range_initialize(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag)
      {
        try
        {
          for (; __first != __last;  ++__first)
            {
              (*this).push_back(*__first);
            }
        }
        catch (...)
        {
          (*this).clear();
          throw;
        }
      }
      template < typename _ForwardIterator >
      inline void _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag)
      {
        const typename ::std::vector<_Tp, _Alloc>::size_type __n = std::distance(__first, __last);
        this->_M_impl._M_start = this->_M_allocate(__n);
        this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
        this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, (_M_get_Tp_allocator)());
      }
      inline void _M_fill_initialize(typename ::std::vector<_Tp, _Alloc>::size_type __n, const typename ::std::vector<_Tp, _Alloc>::value_type &__value)
      {
        this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, (_M_get_Tp_allocator)());
      }
      template < typename _Integer >
      inline void _M_assign_dispatch(_Integer __n, _Integer __val, ::std::__true_type)
      {
        (*this)._M_fill_assign(__n, __val);
      }
      template < typename _InputIterator >
      inline void _M_assign_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type)
      {
        (*this)._M_assign_aux(__first, __last, std::__iterator_category(__first));
      }
      template < typename _InputIterator >
      void _M_assign_aux(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag);
      template < typename _ForwardIterator >
      void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag);
      void _M_fill_assign(typename ::std::vector<_Tp, _Alloc>::size_type __n, const typename ::std::vector<_Tp, _Alloc>::value_type &__val);
      template < typename _Integer >
      inline void _M_insert_dispatch(typename ::std::vector<_Tp, _Alloc>::iterator __pos, _Integer __n, _Integer __val, ::std::__true_type)
      {
        (*this)._M_fill_insert(__pos, __n, __val);
      }
      template < typename _InputIterator >
      inline void _M_insert_dispatch(typename ::std::vector<_Tp, _Alloc>::iterator __pos, _InputIterator __first, _InputIterator __last, ::std::__false_type)
      {
        (*this)._M_range_insert(__pos, __first, __last, std::__iterator_category(__first));
      }
      template < typename _InputIterator >
      void _M_range_insert(typename ::std::vector<_Tp, _Alloc>::iterator __pos, _InputIterator __first, _InputIterator __last, ::std::input_iterator_tag);
      template < typename _ForwardIterator >
      void _M_range_insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, _ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag);
      void _M_fill_insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, typename ::std::vector<_Tp, _Alloc>::size_type __n, const typename ::std::vector<_Tp, _Alloc>::value_type &__x);
      void _M_insert_aux(typename ::std::vector<_Tp, _Alloc>::iterator __position, const typename ::std::vector<_Tp, _Alloc>::value_type &__x);
      void _M_realloc_insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, const typename ::std::vector<_Tp, _Alloc>::value_type &__x);
      inline typename ::std::vector<_Tp, _Alloc>::size_type _M_check_len(typename ::std::vector<_Tp, _Alloc>::size_type __n, const char *__s) const 
      {
        if ((*this).max_size() - (*this).size() < __n)
          {
            ::std::__throw_length_error(__s);
          }
        const typename ::std::vector<_Tp, _Alloc>::size_type __len = (*this).size() + std::max((*this).size(), __n);
        return __len < (*this).size() || __len > (*this).max_size() ? (*this).max_size() : __len;
      }
      inline void _M_erase_at_end(typename ::std::vector<_Tp, _Alloc>::pointer __pos)
      {
        std::_Destroy(__pos, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
        this->_M_impl._M_finish = __pos;
      }
      typename ::std::vector<_Tp, _Alloc>::iterator _M_erase(typename ::std::vector<_Tp, _Alloc>::iterator __position);
      typename ::std::vector<_Tp, _Alloc>::iterator _M_erase(typename ::std::vector<_Tp, _Alloc>::iterator __first, typename ::std::vector<_Tp, _Alloc>::iterator __last);
      template < typename _Up >
      inline _Up *_M_data_ptr(_Up *__ptr) const 
      {
        return __ptr;
      }
      template < typename _Up >
      inline _Up *_M_data_ptr(_Up *__ptr)
      {
        return __ptr;
      }
      template < typename _Ptr >
      inline typename ::std::vector<_Tp, _Alloc>::value_type *_M_data_ptr(_Ptr __ptr)
      {
        return __ptr.operator ->();
      }
      template < typename _Ptr >
      inline const typename ::std::vector<_Tp, _Alloc>::value_type *_M_data_ptr(_Ptr __ptr) const 
      {
        return __ptr.operator ->();
      }
  };
  template < typename _Tp, typename _Alloc >
  inline bool operator ==(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator ==(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y)
  {
    return __x.size() == __y.size() && std::equal(__x.begin(), __x.end(), __y.begin());
  }
  template < typename _Tp, typename _Alloc >
  inline bool operator <(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator <(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y)
  {
    return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
  }
  template < typename _Tp, typename _Alloc >
  inline bool operator !=(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator !=(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y)
  {
    return !(__x == __y);
  }
  template < typename _Tp, typename _Alloc >
  inline bool operator >(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator >(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y)
  {
    return __y < __x;
  }
  template < typename _Tp, typename _Alloc >
  inline bool operator <=(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator <=(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Tp, typename _Alloc >
  inline bool operator >=(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator >=(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Tp, typename _Alloc >
  inline void swap(::std::vector<_Tp, _Alloc> &__x, ::std::vector<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline void swap(::std::vector<_Tp, _Alloc> &__x, ::std::vector<_Tp, _Alloc> &__y)
  {
    __x.swap(__y);
  }
  typedef unsigned long int _Bit_type;
  enum mcc_enum_anon_48
  {
    _S_word_bit = (int)(8 * sizeof(::std::_Bit_type))
  };
  struct  _Bit_reference
  {
      ::std::_Bit_type *_M_p;
      ::std::_Bit_type _M_mask;
      inline _Bit_reference(::std::_Bit_type *__x, ::std::_Bit_type __y)
        : _M_p(__x), _M_mask(__y)
      {
      }
      inline _Bit_reference()
        : _M_p(0), _M_mask(0)
      {
      }
      inline operator bool() const 
      {
        return !!(*(*this)._M_p & (*this)._M_mask);
      }
      inline ::std::_Bit_reference &operator =(bool __x)
      {
        if (__x)
          {
            *(*this)._M_p |= (*this)._M_mask;
          }
        else
          {
            *(*this)._M_p &= ~(*this)._M_mask;
          }
        return *this;
      }
      inline ::std::_Bit_reference &operator =(const ::std::_Bit_reference &__x)
      {
        return *this = (bool)__x;
      }
      inline bool operator ==(const ::std::_Bit_reference &__x) const 
      {
        return (bool)*this == (bool)__x;
      }
      inline bool operator <(const ::std::_Bit_reference &__x) const 
      {
        return !((bool)*this) && (bool)__x;
      }
      inline void flip()
      {
        *(*this)._M_p ^= (*this)._M_mask;
      }
  };
 /* Instantiation of class template '::std::iterator< ::std::random_access_iterator_tag, bool>' */ 
  struct  _Bit_iterator_base : ::std::iterator< ::std::random_access_iterator_tag, bool>
  {
      ::std::_Bit_type *_M_p;
      unsigned int _M_offset;
      inline _Bit_iterator_base(::std::_Bit_type *__x, unsigned int __y)
        : _M_p(__x), _M_offset(__y)
      {
      }
      inline void _M_bump_up()
      {
        if ((*this)._M_offset++ == (int)::std::_S_word_bit - 1)
          {
            (*this)._M_offset = 0;
             ++(*this)._M_p;
          }
      }
      inline void _M_bump_down()
      {
        if ((*this)._M_offset-- == 0)
          {
            (*this)._M_offset = (int)::std::_S_word_bit - 1;
             --(*this)._M_p;
          }
      }
      inline void _M_incr(::std::ptrdiff_t __i)
      {
        ::std::iterator< ::std::random_access_iterator_tag, bool>::difference_type __n(__i + (*this)._M_offset);
        (*this)._M_p += __n / (int)::std::_S_word_bit;
        __n = __n % (int)::std::_S_word_bit;
        if (__n < 0)
          {
            __n += (int)::std::_S_word_bit;
             --(*this)._M_p;
          }
        (*this)._M_offset = static_cast<unsigned int>(__n);
      }
      inline bool operator ==(const ::std::_Bit_iterator_base &__i) const 
      {
        return (*this)._M_p == __i._M_p && (*this)._M_offset == __i._M_offset;
      }
      inline bool operator <(const ::std::_Bit_iterator_base &__i) const 
      {
        return (*this)._M_p < __i._M_p || ((*this)._M_p == __i._M_p && (*this)._M_offset < __i._M_offset);
      }
      inline bool operator !=(const ::std::_Bit_iterator_base &__i) const 
      {
        return !(*this == __i);
      }
      inline bool operator >(const ::std::_Bit_iterator_base &__i) const 
      {
        return __i < *this;
      }
      inline bool operator <=(const ::std::_Bit_iterator_base &__i) const 
      {
        return !(__i < *this);
      }
      inline bool operator >=(const ::std::_Bit_iterator_base &__i) const 
      {
        return !(*this < __i);
      }
  };
  inline ::std::ptrdiff_t operator -(const ::std::_Bit_iterator_base &__x, const ::std::_Bit_iterator_base &__y)
  {
    return (int)::std::_S_word_bit * (__x._M_p - __y._M_p) + __x._M_offset - __y._M_offset;
  }
  struct  _Bit_iterator : ::std::_Bit_iterator_base
  {
      typedef ::std::_Bit_reference reference;
      typedef ::std::_Bit_reference *pointer;
      typedef ::std::_Bit_iterator iterator;
      inline _Bit_iterator()
        : ::std::_Bit_iterator_base(0, 0)
      {
      }
      inline _Bit_iterator(::std::_Bit_type *__x, unsigned int __y)
        : ::std::_Bit_iterator_base(__x, __y)
      {
      }
      inline ::std::_Bit_iterator::iterator _M_const_cast() const 
      {
        return *this;
      }
      inline ::std::_Bit_iterator::reference operator *() const 
      {
        return ::std::_Bit_reference((*this)._M_p, 1LU << (*this)._M_offset);
      }
      inline ::std::_Bit_iterator::iterator &operator ++()
      {
        (*this).::std::_Bit_iterator_base::_M_bump_up();
        return *this;
      }
      inline ::std::_Bit_iterator::iterator operator ++(int)
      {
        ::std::_Bit_iterator::iterator __tmp((*this));
        (*this).::std::_Bit_iterator_base::_M_bump_up();
        return __tmp;
      }
      inline ::std::_Bit_iterator::iterator &operator --()
      {
        (*this).::std::_Bit_iterator_base::_M_bump_down();
        return *this;
      }
      inline ::std::_Bit_iterator::iterator operator --(int)
      {
        ::std::_Bit_iterator::iterator __tmp((*this));
        (*this).::std::_Bit_iterator_base::_M_bump_down();
        return __tmp;
      }
      inline ::std::_Bit_iterator::iterator &operator +=(::std::iterator< ::std::random_access_iterator_tag, bool>::difference_type __i)
      {
        (*this).::std::_Bit_iterator_base::_M_incr(__i);
        return *this;
      }
      inline ::std::_Bit_iterator::iterator &operator -=(::std::iterator< ::std::random_access_iterator_tag, bool>::difference_type __i)
      {
        *this +=  -__i;
        return *this;
      }
      inline ::std::_Bit_iterator::iterator operator +(::std::iterator< ::std::random_access_iterator_tag, bool>::difference_type __i) const 
      {
        ::std::_Bit_iterator::iterator __tmp((*this));
        return __tmp += __i;
      }
      inline ::std::_Bit_iterator::iterator operator -(::std::iterator< ::std::random_access_iterator_tag, bool>::difference_type __i) const 
      {
        ::std::_Bit_iterator::iterator __tmp((*this));
        return __tmp -= __i;
      }
      inline ::std::_Bit_iterator::reference operator [](::std::iterator< ::std::random_access_iterator_tag, bool>::difference_type __i) const 
      {
        return  *(*this + __i);
      }
  };
  inline ::std::_Bit_iterator operator +(::std::ptrdiff_t __n, const ::std::_Bit_iterator &__x)
  {
    return __x + __n;
  }
  struct  _Bit_const_iterator : ::std::_Bit_iterator_base
  {
      typedef bool reference;
      typedef bool const_reference;
      typedef const bool *pointer;
      typedef ::std::_Bit_const_iterator const_iterator;
      inline _Bit_const_iterator()
        : ::std::_Bit_iterator_base(0, 0)
      {
      }
      inline _Bit_const_iterator(::std::_Bit_type *__x, unsigned int __y)
        : ::std::_Bit_iterator_base(__x, __y)
      {
      }
      inline _Bit_const_iterator(const ::std::_Bit_iterator &__x)
        : ::std::_Bit_iterator_base(__x._M_p, __x._M_offset)
      {
      }
      inline ::std::_Bit_iterator _M_const_cast() const 
      {
        return ::std::_Bit_iterator((*this)._M_p, (*this)._M_offset);
      }
      inline ::std::_Bit_const_iterator::const_reference operator *() const 
      {
        return ::std::_Bit_reference((*this)._M_p, 1LU << (*this)._M_offset);
      }
      inline ::std::_Bit_const_iterator::const_iterator &operator ++()
      {
        (*this).::std::_Bit_iterator_base::_M_bump_up();
        return *this;
      }
      inline ::std::_Bit_const_iterator::const_iterator operator ++(int)
      {
        ::std::_Bit_const_iterator::const_iterator __tmp((*this));
        (*this).::std::_Bit_iterator_base::_M_bump_up();
        return __tmp;
      }
      inline ::std::_Bit_const_iterator::const_iterator &operator --()
      {
        (*this).::std::_Bit_iterator_base::_M_bump_down();
        return *this;
      }
      inline ::std::_Bit_const_iterator::const_iterator operator --(int)
      {
        ::std::_Bit_const_iterator::const_iterator __tmp((*this));
        (*this).::std::_Bit_iterator_base::_M_bump_down();
        return __tmp;
      }
      inline ::std::_Bit_const_iterator::const_iterator &operator +=(::std::iterator< ::std::random_access_iterator_tag, bool>::difference_type __i)
      {
        (*this).::std::_Bit_iterator_base::_M_incr(__i);
        return *this;
      }
      inline ::std::_Bit_const_iterator::const_iterator &operator -=(::std::iterator< ::std::random_access_iterator_tag, bool>::difference_type __i)
      {
        *this +=  -__i;
        return *this;
      }
      inline ::std::_Bit_const_iterator::const_iterator operator +(::std::iterator< ::std::random_access_iterator_tag, bool>::difference_type __i) const 
      {
        ::std::_Bit_const_iterator::const_iterator __tmp((*this));
        return __tmp += __i;
      }
      inline ::std::_Bit_const_iterator::const_iterator operator -(::std::iterator< ::std::random_access_iterator_tag, bool>::difference_type __i) const 
      {
        ::std::_Bit_const_iterator::const_iterator __tmp((*this));
        return __tmp -= __i;
      }
      inline ::std::_Bit_const_iterator::const_reference operator [](::std::iterator< ::std::random_access_iterator_tag, bool>::difference_type __i) const 
      {
        return  *(*this + __i);
      }
  };
  inline ::std::_Bit_const_iterator operator +(::std::ptrdiff_t __n, const ::std::_Bit_const_iterator &__x)
  {
    return __x + __n;
  }
  inline void __fill_bvector(::std::_Bit_iterator __first, ::std::_Bit_iterator __last, bool __x)
  {
    for (; __first != __last;  ++__first)
      {
         *__first = __x;
      }
  }
 /* Instantiation of template function 'void ::std::fill<unsigned long int *, int>(unsigned long int *, unsigned long int *, const int &)' */ 
  inline void fill(::std::_Bit_iterator __first, ::std::_Bit_iterator __last, const bool &__x)
  {
    if (__first._M_p != __last._M_p)
      {
        std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
        ::std::__fill_bvector(__first, ::std::_Bit_iterator(__first._M_p + 1, 0), __x);
        ::std::__fill_bvector(::std::_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      {
        ::std::__fill_bvector(__first, __last, __x);
      }
  }
  template < typename _Alloc >
  struct  _Bvector_base
  {
      typedef typename ::__gnu_cxx::__alloc_traits<_Alloc>::template rebind< ::std::_Bit_type>::other _Bit_alloc_type;
      typedef ::__gnu_cxx::__alloc_traits<typename ::std::_Bvector_base<_Alloc>::_Bit_alloc_type> _Bit_alloc_traits;
      typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::_Bvector_base<_Alloc>::_Bit_alloc_type>::pointer _Bit_pointer;
      struct  _Bvector_impl : ::std::_Bvector_base<_Alloc>::_Bit_alloc_type
      {
          ::std::_Bit_iterator _M_start;
          ::std::_Bit_iterator _M_finish;
          typename ::std::_Bvector_base<_Alloc>::_Bit_pointer _M_end_of_storage;
          inline _Bvector_impl()
            : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
          {
          }
          inline _Bvector_impl(const typename ::std::_Bvector_base<_Alloc>::_Bit_alloc_type &__a)
            : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()
          {
          }
          inline ::std::_Bit_type *_M_end_addr() const 
          {
            if (::std::_Bvector_base<_Alloc>::_Bvector_impl::_M_end_of_storage)
              {
                return std::__addressof(::std::_Bvector_base<_Alloc>::_Bvector_impl::_M_end_of_storage[ -1]) + 1;
              }
            return 0;
          }
      };
      typedef _Alloc allocator_type;
      inline typename ::std::_Bvector_base<_Alloc>::_Bit_alloc_type &_M_get_Bit_allocator()
      {
        return *static_cast<typename ::std::_Bvector_base<_Alloc>::_Bit_alloc_type *>(&this->_M_impl);
      }
      inline const typename ::std::_Bvector_base<_Alloc>::_Bit_alloc_type &_M_get_Bit_allocator() const 
      {
        return *static_cast<const typename ::std::_Bvector_base<_Alloc>::_Bit_alloc_type *>(&this->_M_impl);
      }
      inline typename ::std::_Bvector_base<_Alloc>::allocator_type get_allocator() const 
      {
        return ((typename ::std::_Bvector_base<_Alloc>::allocator_type((*this)._M_get_Bit_allocator())));
      }
      inline _Bvector_base()
        : _M_impl()
      {
      }
      inline _Bvector_base(const typename ::std::_Bvector_base<_Alloc>::allocator_type &__a)
        : _M_impl(__a)
      {
      }
      inline ~_Bvector_base()
      {
        this->_M_deallocate();
      }
    protected:
      typename ::std::_Bvector_base<_Alloc>::_Bvector_impl _M_impl;
      inline typename ::std::_Bvector_base<_Alloc>::_Bit_pointer _M_allocate(::std::size_t __n)
      {
        return _Bit_alloc_traits::allocate(::std::_Bvector_base<_Alloc>::_M_impl, _S_nword(__n));
      }
      inline void _M_deallocate()
      {
        if (::std::_Bvector_base<_Alloc>::_M_impl._M_start._M_p)
          {
            const ::std::size_t __n = ::std::_Bvector_base<_Alloc>::_M_impl._M_end_addr() - ::std::_Bvector_base<_Alloc>::_M_impl._M_start._M_p;
            _Bit_alloc_traits::deallocate(::std::_Bvector_base<_Alloc>::_M_impl, ::std::_Bvector_base<_Alloc>::_M_impl._M_end_of_storage - __n, __n);
            ::std::_Bvector_base<_Alloc>::_M_impl._M_start = ::std::_Bvector_base<_Alloc>::_M_impl._M_finish = ::std::_Bit_iterator();
            ::std::_Bvector_base<_Alloc>::_M_impl._M_end_of_storage = ((typename ::std::_Bvector_base<_Alloc>::_Bit_pointer()));
          }
      }
      static inline ::std::size_t _S_nword(::std::size_t __n)
      {
        return (__n + (int)::std::_S_word_bit - 1) / (int)::std::_S_word_bit;
      }
  };
 /* Instantiation of class template '::std::iterator_traits< ::std::_Bit_iterator>' */ 
 /* Instantiation of class template '::std::iterator< ::std::random_access_iterator_tag, bool, long int, ::std::_Bit_reference *, ::std::_Bit_reference>' */ 
 /* Instantiation of class template '::std::reverse_iterator< ::std::_Bit_iterator>' */ 
 /* Instantiation of class template '::std::iterator_traits< ::std::_Bit_const_iterator>' */ 
 /* Instantiation of class template '::std::iterator< ::std::random_access_iterator_tag, bool, long int, const bool *, bool>' */ 
 /* Instantiation of class template '::std::reverse_iterator< ::std::_Bit_const_iterator>' */ 
 /* Instantiation of class template '::__gnu_cxx::__conditional_type<true, ::__gnu_cxx::__numeric_traits_integer<long int>, ::__gnu_cxx::__numeric_traits_floating<long int> >' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits_integer<long int>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits<long int>' */ 
  template < typename _Alloc >
  class  vector<bool, _Alloc> : protected ::std::_Bvector_base<_Alloc>
  {
      typedef ::std::_Bvector_base<_Alloc> _Base;
      typedef typename ::std::_Bvector_base<_Alloc>::_Bit_pointer _Bit_pointer;
      typedef typename ::std::_Bvector_base<_Alloc>::_Bit_alloc_traits _Bit_alloc_traits;
    public:
      typedef bool value_type;
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef ::std::_Bit_reference reference;
      typedef bool const_reference;
      typedef ::std::_Bit_reference *pointer;
      typedef const bool *const_pointer;
      typedef ::std::_Bit_iterator iterator;
      typedef ::std::_Bit_const_iterator const_iterator;
      typedef ::std::reverse_iterator< ::std::_Bit_const_iterator> const_reverse_iterator;
      typedef ::std::reverse_iterator< ::std::_Bit_iterator> reverse_iterator;
      typedef _Alloc allocator_type;
      inline typename ::std::vector<bool, _Alloc>::allocator_type get_allocator() const 
      {
        return _Base::get_allocator();
      }
    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_S_nword;
      using _Base::_M_get_Bit_allocator;
    public:
      inline vector()
        : _Base()
      {
      }
      inline explicit vector(const typename ::std::vector<bool, _Alloc>::allocator_type &__a)
        : _Base(__a)
      {
      }
      inline explicit vector(typename ::std::vector<bool, _Alloc>::size_type __n, const bool &__value  = (bool()), const typename ::std::vector<bool, _Alloc>::allocator_type &__a  = (((typename ::std::vector<bool, _Alloc>::allocator_type()))))
        : _Base(__a)
      {
        (*this)._M_initialize(__n);
        std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_addr(), __value ? ~0 : 0);
      }
      inline vector(const ::std::vector<bool, _Alloc> &__x)
        : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator()))
      {
        (*this)._M_initialize(__x.size());
        (*this)._M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
      }
      template < typename _InputIterator >
      inline vector(_InputIterator __first, _InputIterator __last, const typename ::std::vector<bool, _Alloc>::allocator_type &__a  = (((typename ::std::vector<bool, _Alloc>::allocator_type()))))
        : _Base(__a)
      {
        typedef typename ::std::__is_integer<_InputIterator>::__type _Integral;
        (*this)._M_initialize_dispatch(__first, __last, _Integral());
      }
      inline ~vector()
      {
      }
      inline ::std::vector<bool, _Alloc> &operator =(const ::std::vector<bool, _Alloc> &__x)
      {
        if (&__x == this)
          {
            return *this;
          }
        if (__x.size() > (*this).capacity())
          {
            this->_M_deallocate();
            (*this)._M_initialize(__x.size());
          }
        this->_M_impl._M_finish = (*this)._M_copy_aligned(__x.begin(), __x.end(), (*this).begin());
        return *this;
      }
      inline void assign(typename ::std::vector<bool, _Alloc>::size_type __n, const bool &__x)
      {
        (*this)._M_fill_assign(__n, __x);
      }
      template < typename _InputIterator >
      inline void assign(_InputIterator __first, _InputIterator __last)
      {
        typedef typename ::std::__is_integer<_InputIterator>::__type _Integral;
        (*this)._M_assign_dispatch(__first, __last, _Integral());
      }
      inline typename ::std::vector<bool, _Alloc>::iterator begin()
      {
        return this->_M_impl._M_start;
      }
      inline typename ::std::vector<bool, _Alloc>::const_iterator begin() const 
      {
        return this->_M_impl._M_start;
      }
      inline typename ::std::vector<bool, _Alloc>::iterator end()
      {
        return this->_M_impl._M_finish;
      }
      inline typename ::std::vector<bool, _Alloc>::const_iterator end() const 
      {
        return this->_M_impl._M_finish;
      }
      inline typename ::std::vector<bool, _Alloc>::reverse_iterator rbegin()
      {
        return ((typename ::std::vector<bool, _Alloc>::reverse_iterator((*this).end())));
      }
      inline typename ::std::vector<bool, _Alloc>::const_reverse_iterator rbegin() const 
      {
        return ((typename ::std::vector<bool, _Alloc>::const_reverse_iterator((*this).end())));
      }
      inline typename ::std::vector<bool, _Alloc>::reverse_iterator rend()
      {
        return ((typename ::std::vector<bool, _Alloc>::reverse_iterator((*this).begin())));
      }
      inline typename ::std::vector<bool, _Alloc>::const_reverse_iterator rend() const 
      {
        return ((typename ::std::vector<bool, _Alloc>::const_reverse_iterator((*this).begin())));
      }
      inline typename ::std::vector<bool, _Alloc>::size_type size() const 
      {
        return ((typename ::std::vector<bool, _Alloc>::size_type((*this).end() - (*this).begin())));
      }
      inline typename ::std::vector<bool, _Alloc>::size_type max_size() const 
      {
        const typename ::std::vector<bool, _Alloc>::size_type __isize(::__gnu_cxx::__numeric_traits_integer<long int>::__max - (int)::std::_S_word_bit + 1);
        const typename ::std::vector<bool, _Alloc>::size_type __asize = _Bit_alloc_traits::max_size((_M_get_Bit_allocator)());
        return __asize <= __isize / (int)::std::_S_word_bit ? __asize * (int)::std::_S_word_bit : __isize;
      }
      inline typename ::std::vector<bool, _Alloc>::size_type capacity() const 
      {
        return ((typename ::std::vector<bool, _Alloc>::size_type(((typename ::std::vector<bool, _Alloc>::const_iterator(this->_M_impl._M_end_addr(), 0))) - (*this).begin())));
      }
      inline bool empty() const 
      {
        return (*this).begin() == (*this).end();
      }
      inline typename ::std::vector<bool, _Alloc>::reference operator [](typename ::std::vector<bool, _Alloc>::size_type __n)
      {
        return  *((typename ::std::vector<bool, _Alloc>::iterator(this->_M_impl._M_start._M_p + __n / (int)::std::_S_word_bit, __n % (int)::std::_S_word_bit)));
      }
      inline typename ::std::vector<bool, _Alloc>::const_reference operator [](typename ::std::vector<bool, _Alloc>::size_type __n) const 
      {
        return  *((typename ::std::vector<bool, _Alloc>::const_iterator(this->_M_impl._M_start._M_p + __n / (int)::std::_S_word_bit, __n % (int)::std::_S_word_bit)));
      }
    protected:
      inline void _M_range_check(typename ::std::vector<bool, _Alloc>::size_type __n) const 
      {
        if (__n >= this->size())
          {
            __throw_out_of_range_fmt("vector<bool>::_M_range_check: __n (which is %zu) >= this->size() (which is %zu)", __n, this->size());
          }
      }
    public:
      inline typename ::std::vector<bool, _Alloc>::reference at(typename ::std::vector<bool, _Alloc>::size_type __n)
      {
        (*this)._M_range_check(__n);
        return (*this)[__n];
      }
      inline typename ::std::vector<bool, _Alloc>::const_reference at(typename ::std::vector<bool, _Alloc>::size_type __n) const 
      {
        (*this)._M_range_check(__n);
        return (*this)[__n];
      }
      inline void reserve(typename ::std::vector<bool, _Alloc>::size_type __n)
      {
        if (__n > (*this).max_size())
          {
            ::std::__throw_length_error("vector::reserve");
          }
        if ((*this).capacity() < __n)
          {
            (*this)._M_reallocate(__n);
          }
      }
      inline typename ::std::vector<bool, _Alloc>::reference front()
      {
        return *(*this).begin();
      }
      inline typename ::std::vector<bool, _Alloc>::const_reference front() const 
      {
        return *(*this).begin();
      }
      inline typename ::std::vector<bool, _Alloc>::reference back()
      {
        return *((*this).end() - 1);
      }
      inline typename ::std::vector<bool, _Alloc>::const_reference back() const 
      {
        return *((*this).end() - 1);
      }
      inline void data()
      {
      }
      inline void push_back(bool __x)
      {
        if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
          {
            *this->_M_impl._M_finish++ = __x;
          }
        else
          {
            (*this)._M_insert_aux((*this).end(), __x);
          }
      }
      inline void swap(::std::vector<bool, _Alloc> &__x)
      {
        std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
        std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
        std::swap(this->_M_impl._M_end_of_storage, __x._M_impl._M_end_of_storage);
        _Bit_alloc_traits::_S_on_swap((_M_get_Bit_allocator)(), __x._M_get_Bit_allocator());
      }
      static inline void swap(typename ::std::vector<bool, _Alloc>::reference __x, typename ::std::vector<bool, _Alloc>::reference __y)
      {
        bool __tmp(__x);
        __x = __y;
        __y = __tmp;
      }
      inline typename ::std::vector<bool, _Alloc>::iterator insert(typename ::std::vector<bool, _Alloc>::iterator __position, const bool &__x  = (bool()))
      {
        const typename ::std::vector<bool, _Alloc>::difference_type __n = __position - (*this).begin();
        if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr() && __position == (*this).end())
          {
            *this->_M_impl._M_finish++ = __x;
          }
        else
          {
            (*this)._M_insert_aux(__position.::std::_Bit_iterator::_M_const_cast(), __x);
          }
        return (*this).begin() + __n;
      }
      template < typename _InputIterator >
      inline void insert(typename ::std::vector<bool, _Alloc>::iterator __position, _InputIterator __first, _InputIterator __last)
      {
        typedef typename ::std::__is_integer<_InputIterator>::__type _Integral;
        (*this)._M_insert_dispatch(__position, __first, __last, _Integral());
      }
      inline void insert(typename ::std::vector<bool, _Alloc>::iterator __position, typename ::std::vector<bool, _Alloc>::size_type __n, const bool &__x)
      {
        (*this)._M_fill_insert(__position, __n, __x);
      }
      inline void pop_back()
      {
         --this->_M_impl._M_finish;
      }
      inline typename ::std::vector<bool, _Alloc>::iterator erase(typename ::std::vector<bool, _Alloc>::iterator __position)
      {
        return (*this)._M_erase(__position.::std::_Bit_iterator::_M_const_cast());
      }
      inline typename ::std::vector<bool, _Alloc>::iterator erase(typename ::std::vector<bool, _Alloc>::iterator __first, typename ::std::vector<bool, _Alloc>::iterator __last)
      {
        return (*this)._M_erase(__first.::std::_Bit_iterator::_M_const_cast(), __last.::std::_Bit_iterator::_M_const_cast());
      }
      inline void resize(typename ::std::vector<bool, _Alloc>::size_type __new_size, bool __x  = (bool()))
      {
        if (__new_size < (*this).size())
          {
            (*this)._M_erase_at_end((*this).begin() + (typename ::std::vector<bool, _Alloc>::difference_type)__new_size);
          }
        else
          {
            (*this).insert((*this).end(), __new_size - (*this).size(), __x);
          }
      }
      inline void flip()
      {
        ::std::_Bit_type *const __end = this->_M_impl._M_end_addr();
        for (::std::_Bit_type *__p = this->_M_impl._M_start._M_p; __p != __end;  ++__p)
          {
            *__p = ~*__p;
          }
      }
      inline void clear()
      {
        (*this)._M_erase_at_end((*this).begin());
      }
    protected:
      inline typename ::std::vector<bool, _Alloc>::iterator _M_copy_aligned(typename ::std::vector<bool, _Alloc>::const_iterator __first, typename ::std::vector<bool, _Alloc>::const_iterator __last, typename ::std::vector<bool, _Alloc>::iterator __result)
      {
        ::std::_Bit_type *__q(std::copy(__first._M_p, __last._M_p, __result._M_p));
        return std::copy(::std::_Bit_const_iterator(__last._M_p, 0), __last, ::std::_Bit_iterator(__q, 0));
      }
      inline void _M_initialize(typename ::std::vector<bool, _Alloc>::size_type __n)
      {
        if (__n)
          {
            typename ::std::vector<bool, _Alloc>::_Bit_pointer __q = this->_M_allocate(__n);
            this->_M_impl._M_end_of_storage = __q + (_S_nword)(__n);
            this->_M_impl._M_start = ((typename ::std::vector<bool, _Alloc>::iterator(std::__addressof(*__q), 0)));
          }
        else
          {
            this->_M_impl._M_end_of_storage = ((typename ::std::vector<bool, _Alloc>::_Bit_pointer()));
            this->_M_impl._M_start = ::std::_Bit_iterator(0, 0);
          }
        this->_M_impl._M_finish = this->_M_impl._M_start + (typename ::std::vector<bool, _Alloc>::difference_type)__n;
      }
      void _M_reallocate(typename ::std::vector<bool, _Alloc>::size_type __n);
      template < typename _Integer >
      inline void _M_initialize_dispatch(_Integer __n, _Integer __x, ::std::__true_type)
      {
        (*this)._M_initialize(static_cast<typename ::std::vector<bool, _Alloc>::size_type>(__n));
        std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_addr(), __x ? ~0 : 0);
      }
      template < typename _InputIterator >
      inline void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type)
      {
        (*this)._M_initialize_range(__first, __last, std::__iterator_category(__first));
      }
      template < typename _InputIterator >
      inline void _M_initialize_range(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag)
      {
        for (; __first != __last;  ++__first)
          {
            (*this).push_back(*__first);
          }
      }
      template < typename _ForwardIterator >
      inline void _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag)
      {
        const typename ::std::vector<bool, _Alloc>::size_type __n = std::distance(__first, __last);
        (*this)._M_initialize(__n);
        std::copy(__first, __last, this->_M_impl._M_start);
      }
      template < typename _Integer >
      inline void _M_assign_dispatch(_Integer __n, _Integer __val, ::std::__true_type)
      {
        (*this)._M_fill_assign(__n, __val);
      }
      template < typename _InputIterator >
      inline void _M_assign_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type)
      {
        (*this)._M_assign_aux(__first, __last, std::__iterator_category(__first));
      }
      inline void _M_fill_assign(::std::size_t __n, bool __x)
      {
        if (__n > (*this).size())
          {
            std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_addr(), __x ? ~0 : 0);
            (*this).insert((*this).end(), __n - (*this).size(), __x);
          }
        else
          {
            (*this)._M_erase_at_end((*this).begin() + __n);
            std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_addr(), __x ? ~0 : 0);
          }
      }
      template < typename _InputIterator >
      inline void _M_assign_aux(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag)
      {
        typename ::std::vector<bool, _Alloc>::iterator __cur = (*this).begin();
        for (; __first != __last && __cur != (*this).end(); ( ++__cur,  ++__first))
          {
             *__cur = *__first;
          }
        if (__first == __last)
          {
            (*this)._M_erase_at_end(__cur);
          }
        else
          {
            (*this).insert((*this).end(), __first, __last);
          }
      }
      template < typename _ForwardIterator >
      inline void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag)
      {
        const typename ::std::vector<bool, _Alloc>::size_type __len = std::distance(__first, __last);
        if (__len < (*this).size())
          {
            (*this)._M_erase_at_end(std::copy(__first, __last, (*this).begin()));
          }
        else
          {
            _ForwardIterator __mid = __first;
            std::advance(__mid, (*this).size());
            std::copy(__first, __mid, (*this).begin());
            (*this).insert((*this).end(), __mid, __last);
          }
      }
      template < typename _Integer >
      inline void _M_insert_dispatch(typename ::std::vector<bool, _Alloc>::iterator __pos, _Integer __n, _Integer __x, ::std::__true_type)
      {
        (*this)._M_fill_insert(__pos, __n, __x);
      }
      template < typename _InputIterator >
      inline void _M_insert_dispatch(typename ::std::vector<bool, _Alloc>::iterator __pos, _InputIterator __first, _InputIterator __last, ::std::__false_type)
      {
        (*this)._M_insert_range(__pos, __first, __last, std::__iterator_category(__first));
      }
      void _M_fill_insert(typename ::std::vector<bool, _Alloc>::iterator __position, typename ::std::vector<bool, _Alloc>::size_type __n, bool __x);
      template < typename _InputIterator >
      inline void _M_insert_range(typename ::std::vector<bool, _Alloc>::iterator __pos, _InputIterator __first, _InputIterator __last, ::std::input_iterator_tag)
      {
        for (; __first != __last;  ++__first)
          {
            __pos = (*this).insert(__pos, *__first);
             ++__pos;
          }
      }
      template < typename _ForwardIterator >
      void _M_insert_range(typename ::std::vector<bool, _Alloc>::iterator __position, _ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag);
      void _M_insert_aux(typename ::std::vector<bool, _Alloc>::iterator __position, bool __x);
      inline typename ::std::vector<bool, _Alloc>::size_type _M_check_len(typename ::std::vector<bool, _Alloc>::size_type __n, const char *__s) const 
      {
        if ((*this).max_size() - (*this).size() < __n)
          {
            ::std::__throw_length_error(__s);
          }
        const typename ::std::vector<bool, _Alloc>::size_type __len = (*this).size() + std::max((*this).size(), __n);
        return __len < (*this).size() || __len > (*this).max_size() ? (*this).max_size() : __len;
      }
      inline void _M_erase_at_end(typename ::std::vector<bool, _Alloc>::iterator __pos)
      {
        this->_M_impl._M_finish = __pos;
      }
      typename ::std::vector<bool, _Alloc>::iterator _M_erase(typename ::std::vector<bool, _Alloc>::iterator __position);
      typename ::std::vector<bool, _Alloc>::iterator _M_erase(typename ::std::vector<bool, _Alloc>::iterator __first, typename ::std::vector<bool, _Alloc>::iterator __last);
  };
  template < typename _Tp, typename _Alloc >
  void vector<_Tp, _Alloc>::reserve(typename ::std::vector<_Tp, _Alloc>::size_type __n)
  {
    if (__n > this->max_size())
      {
        ::std::__throw_length_error("vector::reserve");
      }
    if (this->capacity() < __n)
      {
        const typename ::std::vector<_Tp, _Alloc>::size_type __old_size = (*this).size();
        typename ::std::vector<_Tp, _Alloc>::pointer __tmp = (*this)._M_allocate_and_copy(__n, this->_M_impl._M_start, this->_M_impl._M_finish);
        std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
        _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
        this->_M_impl._M_start = __tmp;
        this->_M_impl._M_finish = __tmp + __old_size;
        this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
  }
  template < typename _Tp, typename _Alloc >
  typename ::std::vector<_Tp, _Alloc>::iterator vector<_Tp, _Alloc>::insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, const typename ::std::vector<_Tp, _Alloc>::value_type &__x)
  {
    const typename ::std::vector<_Tp, _Alloc>::size_type __n = __position - (*this).begin();
    if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
      {
        if (__position == (*this).end())
          {
            _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
             ++this->_M_impl._M_finish;
          }
        else
          {
            (*this)._M_insert_aux(__position, __x);
          }
      }
    else
      {
        (*this)._M_realloc_insert(__position, __x);
      }
    return ((typename ::std::vector<_Tp, _Alloc>::iterator(this->_M_impl._M_start + __n)));
  }
  template < typename _Tp, typename _Alloc >
  typename ::std::vector<_Tp, _Alloc>::iterator vector<_Tp, _Alloc>::_M_erase(typename ::std::vector<_Tp, _Alloc>::iterator __position)
  {
    if (__position + 1 != (*this).end())
      {
        std::copy(__position + 1, (*this).end(), __position);
      }
     --this->_M_impl._M_finish;
    _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
    return __position;
  }
  template < typename _Tp, typename _Alloc >
  typename ::std::vector<_Tp, _Alloc>::iterator vector<_Tp, _Alloc>::_M_erase(typename ::std::vector<_Tp, _Alloc>::iterator __first, typename ::std::vector<_Tp, _Alloc>::iterator __last)
  {
    if (__first != __last)
      {
        if (__last != (*this).end())
          {
            std::copy(__last, (*this).end(), __first);
          }
        (*this)._M_erase_at_end(__first.base() + ((*this).end() - __last));
      }
    return __first;
  }
  template < typename _Tp, typename _Alloc >
  ::std::vector<_Tp, _Alloc> &vector<_Tp, _Alloc>::operator =(const ::std::vector<_Tp, _Alloc> &__x)
  {
    if (&__x != this)
      {
        const typename ::std::vector<_Tp, _Alloc>::size_type __xlen = __x.size();
        if (__xlen > (*this).capacity())
          {
            typename ::std::vector<_Tp, _Alloc>::pointer __tmp = (*this)._M_allocate_and_copy(__xlen, __x.begin(), __x.end());
            std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
            _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
            this->_M_impl._M_start = __tmp;
            this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
          }
        else
          {
            if ((*this).size() >= __xlen)
              {
                std::_Destroy(std::copy(__x.begin(), __x.end(), (*this).begin()), (*this).end(), (_M_get_Tp_allocator)());
              }
            else
              {
                std::copy(__x._M_impl._M_start, __x._M_impl._M_start + (*this).size(), this->_M_impl._M_start);
                std::__uninitialized_copy_a(__x._M_impl._M_start + (*this).size(), __x._M_impl._M_finish, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
              }
          }
        this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
      }
    return *this;
  }
  template < typename _Tp, typename _Alloc >
  void vector<_Tp, _Alloc>::_M_fill_assign(::std::size_t __n, const typename ::std::vector<_Tp, _Alloc>::value_type &__val)
  {
    if (__n > (*this).capacity())
      {
        ::std::vector<_Tp, _Alloc> __tmp(__n, __val, (_M_get_Tp_allocator)());
        __tmp._M_impl._M_swap_data(this->_M_impl);
      }
    else
      {
        if (__n > (*this).size())
          {
            std::fill((*this).begin(), (*this).end(), __val);
            this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - (*this).size(), __val, (_M_get_Tp_allocator)());
          }
        else
          {
            (*this)._M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
          }
      }
  }
  template < typename _Tp, typename _Alloc >
  template < typename _InputIterator >
  void vector<_Tp, _Alloc>::_M_assign_aux(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag)
  {
    typename ::std::vector<_Tp, _Alloc>::pointer __cur(this->_M_impl._M_start);
    for (; __first != __last && __cur != this->_M_impl._M_finish; ( ++__cur,  ++__first))
      {
        *__cur = *__first;
      }
    if (__first == __last)
      {
        (*this)._M_erase_at_end(__cur);
      }
    else
      {
        (*this)._M_range_insert((*this).end(), __first, __last, std::__iterator_category(__first));
      }
  }
  template < typename _Tp, typename _Alloc >
  template < typename _ForwardIterator >
  void vector<_Tp, _Alloc>::_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag)
  {
    const typename ::std::vector<_Tp, _Alloc>::size_type __len = std::distance(__first, __last);
    if (__len > (*this).capacity())
      {
        typename ::std::vector<_Tp, _Alloc>::pointer __tmp((*this)._M_allocate_and_copy(__len, __first, __last));
        std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
        _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
        this->_M_impl._M_start = __tmp;
        this->_M_impl._M_finish = this->_M_impl._M_start + __len;
        this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
      }
    else
      {
        if ((*this).size() >= __len)
          {
            (*this)._M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
          }
        else
          {
            _ForwardIterator __mid = __first;
            std::advance(__mid, (*this).size());
            std::copy(__first, __mid, this->_M_impl._M_start);
            this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
          }
      }
  }
  template < typename _Tp, typename _Alloc >
  void vector<_Tp, _Alloc>::_M_insert_aux(typename ::std::vector<_Tp, _Alloc>::iterator __position, const _Tp &__x)
  {
    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, *(this->_M_impl._M_finish - 1));
     ++this->_M_impl._M_finish;
    _Tp __x_copy = __x;
    std::copy_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1);
    *__position = __x_copy;
  }
  template < typename _Tp, typename _Alloc >
  void vector<_Tp, _Alloc>::_M_realloc_insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, const _Tp &__x)
  {
    const typename ::std::vector<_Tp, _Alloc>::size_type __len = (*this)._M_check_len((typename ::std::vector<_Tp, _Alloc>::size_type)1, "vector::_M_realloc_insert");
    const typename ::std::vector<_Tp, _Alloc>::size_type __elems_before = __position - (*this).begin();
    typename ::std::vector<_Tp, _Alloc>::pointer __new_start(this->_M_allocate(__len));
    typename ::std::vector<_Tp, _Alloc>::pointer __new_finish(__new_start);
    try
    {
      _Alloc_traits::construct(this->_M_impl, __new_start + __elems_before, __x);
      __new_finish = ((typename ::std::vector<_Tp, _Alloc>::pointer()));
      __new_finish = std::__uninitialized_move_if_noexcept_a(this->_M_impl._M_start, __position.base(), __new_start, (_M_get_Tp_allocator)());
       ++__new_finish;
      __new_finish = std::__uninitialized_move_if_noexcept_a(__position.base(), this->_M_impl._M_finish, __new_finish, (_M_get_Tp_allocator)());
    }
    catch (...)
    {
      if (!__new_finish)
        {
          _Alloc_traits::destroy(this->_M_impl, __new_start + __elems_before);
        }
      else
        {
          std::_Destroy(__new_start, __new_finish, (_M_get_Tp_allocator)());
        }
      _M_deallocate(__new_start, __len);
      throw;
    }
    std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
    _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
    this->_M_impl._M_start = __new_start;
    this->_M_impl._M_finish = __new_finish;
    this->_M_impl._M_end_of_storage = __new_start + __len;
  }
  template < typename _Tp, typename _Alloc >
  void vector<_Tp, _Alloc>::_M_fill_insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, typename ::std::vector<_Tp, _Alloc>::size_type __n, const typename ::std::vector<_Tp, _Alloc>::value_type &__x)
  {
    if (__n != 0)
      {
        if (((typename ::std::vector<_Tp, _Alloc>::size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_finish))) >= __n)
          {
            typename ::std::vector<_Tp, _Alloc>::value_type __x_copy = __x;
            const typename ::std::vector<_Tp, _Alloc>::size_type __elems_after = (*this).end() - __position;
            typename ::std::vector<_Tp, _Alloc>::pointer __old_finish(this->_M_impl._M_finish);
            if (__elems_after > __n)
              {
                std::__uninitialized_move_a(this->_M_impl._M_finish - __n, this->_M_impl._M_finish, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
                this->_M_impl._M_finish += __n;
                std::copy_backward(__position.base(), __old_finish - __n, __old_finish);
                std::fill(__position.base(), __position.base() + __n, __x_copy);
              }
            else
              {
                this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - __elems_after, __x_copy, (_M_get_Tp_allocator)());
                std::__uninitialized_move_a(__position.base(), __old_finish, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
                this->_M_impl._M_finish += __elems_after;
                std::fill(__position.base(), __old_finish, __x_copy);
              }
          }
        else
          {
            const typename ::std::vector<_Tp, _Alloc>::size_type __len = (*this)._M_check_len(__n, "vector::_M_fill_insert");
            const typename ::std::vector<_Tp, _Alloc>::size_type __elems_before = __position - (*this).begin();
            typename ::std::vector<_Tp, _Alloc>::pointer __new_start(this->_M_allocate(__len));
            typename ::std::vector<_Tp, _Alloc>::pointer __new_finish(__new_start);
            try
            {
              std::__uninitialized_fill_n_a(__new_start + __elems_before, __n, __x, (_M_get_Tp_allocator)());
              __new_finish = ((typename ::std::vector<_Tp, _Alloc>::pointer()));
              __new_finish = std::__uninitialized_move_if_noexcept_a(this->_M_impl._M_start, __position.base(), __new_start, (_M_get_Tp_allocator)());
              __new_finish += __n;
              __new_finish = std::__uninitialized_move_if_noexcept_a(__position.base(), this->_M_impl._M_finish, __new_finish, (_M_get_Tp_allocator)());
            }
            catch (...)
            {
              if (!__new_finish)
                {
                  std::_Destroy(__new_start + __elems_before, __new_start + __elems_before + __n, (_M_get_Tp_allocator)());
                }
              else
                {
                  std::_Destroy(__new_start, __new_finish, (_M_get_Tp_allocator)());
                }
              _M_deallocate(__new_start, __len);
              throw;
            }
            std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
            _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
            this->_M_impl._M_start = __new_start;
            this->_M_impl._M_finish = __new_finish;
            this->_M_impl._M_end_of_storage = __new_start + __len;
          }
      }
  }
  template < typename _Tp, typename _Alloc >
  template < typename _InputIterator >
  void vector<_Tp, _Alloc>::_M_range_insert(typename ::std::vector<_Tp, _Alloc>::iterator __pos, _InputIterator __first, _InputIterator __last, ::std::input_iterator_tag)
  {
    for (; __first != __last;  ++__first)
      {
        __pos = (*this).insert(__pos, *__first);
         ++__pos;
      }
  }
  template < typename _Tp, typename _Alloc >
  template < typename _ForwardIterator >
  void vector<_Tp, _Alloc>::_M_range_insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, _ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag)
  {
    if (__first != __last)
      {
        const typename ::std::vector<_Tp, _Alloc>::size_type __n = std::distance(__first, __last);
        if (((typename ::std::vector<_Tp, _Alloc>::size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_finish))) >= __n)
          {
            const typename ::std::vector<_Tp, _Alloc>::size_type __elems_after = (*this).end() - __position;
            typename ::std::vector<_Tp, _Alloc>::pointer __old_finish(this->_M_impl._M_finish);
            if (__elems_after > __n)
              {
                std::__uninitialized_move_a(this->_M_impl._M_finish - __n, this->_M_impl._M_finish, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
                this->_M_impl._M_finish += __n;
                std::copy_backward(__position.base(), __old_finish - __n, __old_finish);
                std::copy(__first, __last, __position);
              }
            else
              {
                _ForwardIterator __mid = __first;
                std::advance(__mid, __elems_after);
                std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
                this->_M_impl._M_finish += __n - __elems_after;
                std::__uninitialized_move_a(__position.base(), __old_finish, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
                this->_M_impl._M_finish += __elems_after;
                std::copy(__first, __mid, __position);
              }
          }
        else
          {
            const typename ::std::vector<_Tp, _Alloc>::size_type __len = (*this)._M_check_len(__n, "vector::_M_range_insert");
            typename ::std::vector<_Tp, _Alloc>::pointer __new_start(this->_M_allocate(__len));
            typename ::std::vector<_Tp, _Alloc>::pointer __new_finish(__new_start);
            try
            {
              __new_finish = std::__uninitialized_move_if_noexcept_a(this->_M_impl._M_start, __position.base(), __new_start, (_M_get_Tp_allocator)());
              __new_finish = std::__uninitialized_copy_a(__first, __last, __new_finish, (_M_get_Tp_allocator)());
              __new_finish = std::__uninitialized_move_if_noexcept_a(__position.base(), this->_M_impl._M_finish, __new_finish, (_M_get_Tp_allocator)());
            }
            catch (...)
            {
              std::_Destroy(__new_start, __new_finish, (_M_get_Tp_allocator)());
              _M_deallocate(__new_start, __len);
              throw;
            }
            std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
            _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
            this->_M_impl._M_start = __new_start;
            this->_M_impl._M_finish = __new_finish;
            this->_M_impl._M_end_of_storage = __new_start + __len;
          }
      }
  }
  template < typename _Alloc >
  void vector<bool, _Alloc>::_M_reallocate(typename ::std::vector<bool, _Alloc>::size_type __n)
  {
    typename ::std::vector<bool, _Alloc>::_Bit_pointer __q = this->_M_allocate(__n);
    typename ::std::vector<bool, _Alloc>::iterator __start(std::__addressof(*__q), 0);
    typename ::std::vector<bool, _Alloc>::iterator __finish((*this)._M_copy_aligned((*this).begin(), (*this).end(), __start));
    this->_M_deallocate();
    this->_M_impl._M_start = __start;
    this->_M_impl._M_finish = __finish;
    this->_M_impl._M_end_of_storage = __q + (_S_nword)(__n);
  }
  template < typename _Alloc >
  void vector<bool, _Alloc>::_M_fill_insert(typename ::std::vector<bool, _Alloc>::iterator __position, typename ::std::vector<bool, _Alloc>::size_type __n, bool __x)
  {
    if (__n == 0)
      {
        return ;
      }
    if ((*this).capacity() - (*this).size() >= __n)
      {
        std::copy_backward(__position, (*this).end(), this->_M_impl._M_finish + (typename ::std::vector<bool, _Alloc>::difference_type)__n);
        std::fill(__position, __position + (typename ::std::vector<bool, _Alloc>::difference_type)__n, __x);
        this->_M_impl._M_finish += (typename ::std::vector<bool, _Alloc>::difference_type)__n;
      }
    else
      {
        const typename ::std::vector<bool, _Alloc>::size_type __len = (*this)._M_check_len(__n, "vector<bool>::_M_fill_insert");
        typename ::std::vector<bool, _Alloc>::_Bit_pointer __q = this->_M_allocate(__len);
        typename ::std::vector<bool, _Alloc>::iterator __start(std::__addressof(*__q), 0);
        typename ::std::vector<bool, _Alloc>::iterator __i = (*this)._M_copy_aligned((*this).begin(), __position, __start);
        std::fill(__i, __i + (typename ::std::vector<bool, _Alloc>::difference_type)__n, __x);
        typename ::std::vector<bool, _Alloc>::iterator __finish = std::copy(__position, (*this).end(), __i + (typename ::std::vector<bool, _Alloc>::difference_type)__n);
        this->_M_deallocate();
        this->_M_impl._M_end_of_storage = __q + (_S_nword)(__len);
        this->_M_impl._M_start = __start;
        this->_M_impl._M_finish = __finish;
      }
  }
  template < typename _Alloc >
  template < typename _ForwardIterator >
  void vector<bool, _Alloc>::_M_insert_range(typename ::std::vector<bool, _Alloc>::iterator __position, _ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag)
  {
    if (__first != __last)
      {
        typename ::std::vector<bool, _Alloc>::size_type __n = std::distance(__first, __last);
        if ((*this).capacity() - (*this).size() >= __n)
          {
            std::copy_backward(__position, (*this).end(), this->_M_impl._M_finish + (typename ::std::vector<bool, _Alloc>::difference_type)__n);
            std::copy(__first, __last, __position);
            this->_M_impl._M_finish += (typename ::std::vector<bool, _Alloc>::difference_type)__n;
          }
        else
          {
            const typename ::std::vector<bool, _Alloc>::size_type __len = (*this)._M_check_len(__n, "vector<bool>::_M_insert_range");
            typename ::std::vector<bool, _Alloc>::_Bit_pointer __q = this->_M_allocate(__len);
            typename ::std::vector<bool, _Alloc>::iterator __start(std::__addressof(*__q), 0);
            typename ::std::vector<bool, _Alloc>::iterator __i = (*this)._M_copy_aligned((*this).begin(), __position, __start);
            __i = std::copy(__first, __last, __i);
            typename ::std::vector<bool, _Alloc>::iterator __finish = std::copy(__position, (*this).end(), __i);
            this->_M_deallocate();
            this->_M_impl._M_end_of_storage = __q + (_S_nword)(__len);
            this->_M_impl._M_start = __start;
            this->_M_impl._M_finish = __finish;
          }
      }
  }
  template < typename _Alloc >
  void vector<bool, _Alloc>::_M_insert_aux(typename ::std::vector<bool, _Alloc>::iterator __position, bool __x)
  {
    if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
      {
        std::copy_backward(__position, this->_M_impl._M_finish, this->_M_impl._M_finish + 1);
         *__position = __x;
         ++this->_M_impl._M_finish;
      }
    else
      {
        const typename ::std::vector<bool, _Alloc>::size_type __len = (*this)._M_check_len((typename ::std::vector<bool, _Alloc>::size_type)1, "vector<bool>::_M_insert_aux");
        typename ::std::vector<bool, _Alloc>::_Bit_pointer __q = this->_M_allocate(__len);
        typename ::std::vector<bool, _Alloc>::iterator __start(std::__addressof(*__q), 0);
        typename ::std::vector<bool, _Alloc>::iterator __i = (*this)._M_copy_aligned((*this).begin(), __position, __start);
         *__i++ = __x;
        typename ::std::vector<bool, _Alloc>::iterator __finish = std::copy(__position, (*this).end(), __i);
        this->_M_deallocate();
        this->_M_impl._M_end_of_storage = __q + (_S_nword)(__len);
        this->_M_impl._M_start = __start;
        this->_M_impl._M_finish = __finish;
      }
  }
  template < typename _Alloc >
  typename ::std::vector<bool, _Alloc>::iterator vector<bool, _Alloc>::_M_erase(typename ::std::vector<bool, _Alloc>::iterator __position)
  {
    if (__position + 1 != (*this).end())
      {
        std::copy(__position + 1, (*this).end(), __position);
      }
     --this->_M_impl._M_finish;
    return __position;
  }
  template < typename _Alloc >
  typename ::std::vector<bool, _Alloc>::iterator vector<bool, _Alloc>::_M_erase(typename ::std::vector<bool, _Alloc>::iterator __first, typename ::std::vector<bool, _Alloc>::iterator __last)
  {
    if (__first != __last)
      {
        (*this)._M_erase_at_end(std::copy(__last, (*this).end(), __first));
      }
    return __first;
  }
  template < typename _RandomAccessIterator, typename _Distance, typename _Compare >
  _Distance __is_heap_until(_RandomAccessIterator __first, _Distance __n, _Compare &__comp);
  template < typename _RandomAccessIterator, typename _Distance, typename _Compare >
  _Distance __is_heap_until(_RandomAccessIterator __first, _Distance __n, _Compare &__comp)
  {
    _Distance __parent = 0;
    for (_Distance __child = 1; __child < __n;  ++__child)
      {
        if (__comp(__first + __parent, __first + __child))
          {
            return __child;
          }
        if ((__child & 1) == 0)
          {
             ++__parent;
          }
      }
    return __n;
  }
  template < typename _RandomAccessIterator, typename _Distance >
  inline bool __is_heap(_RandomAccessIterator __first, _Distance __n);
  template < typename _RandomAccessIterator, typename _Distance >
  inline bool __is_heap(_RandomAccessIterator __first, _Distance __n)
  {
    ::__gnu_cxx::__ops::_Iter_less_iter __comp /* () */ ;
    return std::__is_heap_until(__first, __n, __comp) == __n;
  }
  template < typename _RandomAccessIterator, typename _Compare, typename _Distance >
  inline bool __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n);
  template < typename _RandomAccessIterator, typename _Compare, typename _Distance >
  inline bool __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
  {
    typedef __decltype(__comp) _Cmp;
    ::__gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp((__comp));
    return std::__is_heap_until(__first, __n, __cmp) == __n;
  }
  template < typename _RandomAccessIterator >
  inline bool __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last);
  template < typename _RandomAccessIterator >
  inline bool __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    return std::__is_heap(__first, std::distance(__first, __last));
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline bool __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Compare >
  inline bool __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    return std::__is_heap(__first, __comp, std::distance(__first, __last));
  }
  template < typename _RandomAccessIterator, typename _Distance, typename _Tp, typename _Compare >
  void __push_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __topIndex, _Tp __value, _Compare &__comp);
  template < typename _RandomAccessIterator, typename _Distance, typename _Tp, typename _Compare >
  void __push_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __topIndex, _Tp __value, _Compare &__comp)
  {
    _Distance __parent = (__holeIndex - 1) / 2;
    while (__holeIndex > __topIndex && __comp(__first + __parent, __value))
      {
        *(__first + __holeIndex) = *(__first + __parent);
        __holeIndex = __parent;
        __parent = (__holeIndex - 1) / 2;
      }
    *(__first + __holeIndex) = __value;
  }
  template < typename _RandomAccessIterator >
  inline void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last);
  template < typename _RandomAccessIterator >
  inline void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
    ;
    ;
    ;
    ::__gnu_cxx::__ops::_Iter_less_val __comp /* () */ ;
    _ValueType __value = (*(__last - 1));
    std::__push_heap(__first, _DistanceType(__last - __first - 1), _DistanceType(0), __value, __comp);
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Compare >
  inline void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
    ;
    ;
    ;
    __decltype(__gnu_cxx::__ops::__iter_comp_val(__comp)) __cmp((__comp));
    _ValueType __value = (*(__last - 1));
    std::__push_heap(__first, _DistanceType(__last - __first - 1), _DistanceType(0), __value, __cmp);
  }
  template < typename _RandomAccessIterator, typename _Distance, typename _Tp, typename _Compare >
  void __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __len, _Tp __value, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Distance, typename _Tp, typename _Compare >
  void __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __len, _Tp __value, _Compare __comp)
  {
    const _Distance __topIndex = __holeIndex;
    _Distance __secondChild = __holeIndex;
    while (__secondChild < (__len - 1) / 2)
      {
        __secondChild = 2 * (__secondChild + 1);
        if (__comp(__first + __secondChild, __first + (__secondChild - 1)))
          {
            __secondChild--;
          }
        *(__first + __holeIndex) = *(__first + __secondChild);
        __holeIndex = __secondChild;
      }
    if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
      {
        __secondChild = 2 * (__secondChild + 1);
        *(__first + __holeIndex) = *(__first + (__secondChild - 1));
        __holeIndex = __secondChild - 1;
      }
    __decltype(__gnu_cxx::__ops::__iter_comp_val(__comp)) __cmp((__comp));
    std::__push_heap(__first, __holeIndex, __topIndex, __value, __cmp);
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline void __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomAccessIterator __result, _Compare &__comp);
  template < typename _RandomAccessIterator, typename _Compare >
  inline void __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomAccessIterator __result, _Compare &__comp)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
    _ValueType __value = (*__result);
    *__result = *__first;
    std::__adjust_heap(__first, _DistanceType(0), _DistanceType(__last - __first), __value, __comp);
  }
  template < typename _RandomAccessIterator >
  inline void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last);
  template < typename _RandomAccessIterator >
  inline void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    ;
    ;
    ;
    ;
    if (__last - __first > 1)
      {
         --__last;
        ::__gnu_cxx::__ops::_Iter_less_iter __comp /* () */ ;
        std::__pop_heap(__first, __last, __last, __comp);
      }
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Compare >
  inline void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    ;
    ;
    ;
    ;
    if (__last - __first > 1)
      {
        typedef __decltype(__comp) _Cmp;
        ::__gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp((__comp));
         --__last;
        std::__pop_heap(__first, __last, __last, __cmp);
      }
  }
  template < typename _RandomAccessIterator, typename _Compare >
  void __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare &__comp);
  template < typename _RandomAccessIterator, typename _Compare >
  void __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare &__comp)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
    if (__last - __first < 2)
      {
        return ;
      }
    const _DistanceType __len = __last - __first;
    _DistanceType __parent = (__len - 2) / 2;
    while (true)
      {
        _ValueType __value = (*(__first + __parent));
        std::__adjust_heap(__first, __parent, __len, __value, __comp);
        if (__parent == 0)
          {
            return ;
          }
        __parent--;
      }
  }
  template < typename _RandomAccessIterator >
  inline void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last);
  template < typename _RandomAccessIterator >
  inline void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    ;
    ;
    ::__gnu_cxx::__ops::_Iter_less_iter __comp /* () */ ;
    std::__make_heap(__first, __last, __comp);
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Compare >
  inline void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    ;
    ;
    typedef __decltype(__comp) _Cmp;
    ::__gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp((__comp));
    std::__make_heap(__first, __last, __cmp);
  }
  template < typename _RandomAccessIterator, typename _Compare >
  void __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare &__comp);
  template < typename _RandomAccessIterator, typename _Compare >
  void __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare &__comp)
  {
    while (__last - __first > 1)
      {
         --__last;
        std::__pop_heap(__first, __last, __last, __comp);
      }
  }
  template < typename _RandomAccessIterator >
  inline void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last);
  template < typename _RandomAccessIterator >
  inline void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    ;
    ;
    ;
    ::__gnu_cxx::__ops::_Iter_less_iter __comp /* () */ ;
    std::__sort_heap(__first, __last, __comp);
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Compare >
  inline void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    ;
    ;
    ;
    typedef __decltype(__comp) _Cmp;
    ::__gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp((__comp));
    std::__sort_heap(__first, __last, __cmp);
  }
  template < typename _Tp, typename _Sequence = ::std::deque<_Tp> >
  class  queue
  {
    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;
    protected:
      _Sequence c;
    public:
      inline explicit queue(const _Sequence &__c  = (_Sequence()))
        : c(__c)
      {
      }
      inline bool empty() const 
      {
        return ::std::queue<_Tp, _Sequence>::c.empty();
      }
      inline typename ::std::queue<_Tp, _Sequence>::size_type size() const 
      {
        return ::std::queue<_Tp, _Sequence>::c.size();
      }
      inline typename ::std::queue<_Tp, _Sequence>::reference front()
      {
        ;
        return ::std::queue<_Tp, _Sequence>::c.front();
      }
      inline typename ::std::queue<_Tp, _Sequence>::const_reference front() const 
      {
        ;
        return ::std::queue<_Tp, _Sequence>::c.front();
      }
      inline typename ::std::queue<_Tp, _Sequence>::reference back()
      {
        ;
        return ::std::queue<_Tp, _Sequence>::c.back();
      }
      inline typename ::std::queue<_Tp, _Sequence>::const_reference back() const 
      {
        ;
        return ::std::queue<_Tp, _Sequence>::c.back();
      }
      inline void push(const typename ::std::queue<_Tp, _Sequence>::value_type &__x)
      {
        ::std::queue<_Tp, _Sequence>::c.push_back(__x);
      }
      inline void pop()
      {
        ;
        ::std::queue<_Tp, _Sequence>::c.pop_front();
      }
    template < typename _Tp1, typename _Seq1 >
    friend bool operator ==(const ::std::queue<_Tp1, _Seq1> &, const ::std::queue<_Tp1, _Seq1> &);
    template < typename _Tp1, typename _Seq1 >
    friend bool operator <(const ::std::queue<_Tp1, _Seq1> &, const ::std::queue<_Tp1, _Seq1> &);
  };
  template < typename _Tp, typename _Seq >
  inline bool operator ==(const ::std::queue<_Tp, _Seq> &__x, const ::std::queue<_Tp, _Seq> &__y);
  template < typename _Tp, typename _Seq >
  inline bool operator ==(const ::std::queue<_Tp, _Seq> &__x, const ::std::queue<_Tp, _Seq> &__y)
  {
    return __x.c == __y.c;
  }
  template < typename _Tp, typename _Seq >
  inline bool operator <(const ::std::queue<_Tp, _Seq> &__x, const ::std::queue<_Tp, _Seq> &__y);
  template < typename _Tp, typename _Seq >
  inline bool operator <(const ::std::queue<_Tp, _Seq> &__x, const ::std::queue<_Tp, _Seq> &__y)
  {
    return __x.c < __y.c;
  }
  template < typename _Tp, typename _Seq >
  inline bool operator !=(const ::std::queue<_Tp, _Seq> &__x, const ::std::queue<_Tp, _Seq> &__y);
  template < typename _Tp, typename _Seq >
  inline bool operator !=(const ::std::queue<_Tp, _Seq> &__x, const ::std::queue<_Tp, _Seq> &__y)
  {
    return !(__x == __y);
  }
  template < typename _Tp, typename _Seq >
  inline bool operator >(const ::std::queue<_Tp, _Seq> &__x, const ::std::queue<_Tp, _Seq> &__y);
  template < typename _Tp, typename _Seq >
  inline bool operator >(const ::std::queue<_Tp, _Seq> &__x, const ::std::queue<_Tp, _Seq> &__y)
  {
    return __y < __x;
  }
  template < typename _Tp, typename _Seq >
  inline bool operator <=(const ::std::queue<_Tp, _Seq> &__x, const ::std::queue<_Tp, _Seq> &__y);
  template < typename _Tp, typename _Seq >
  inline bool operator <=(const ::std::queue<_Tp, _Seq> &__x, const ::std::queue<_Tp, _Seq> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Tp, typename _Seq >
  inline bool operator >=(const ::std::queue<_Tp, _Seq> &__x, const ::std::queue<_Tp, _Seq> &__y);
  template < typename _Tp, typename _Seq >
  inline bool operator >=(const ::std::queue<_Tp, _Seq> &__x, const ::std::queue<_Tp, _Seq> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Tp, typename _Sequence = ::std::vector<_Tp>, typename _Compare = ::std::less<typename _Sequence::value_type> >
  class  priority_queue
  {
    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;
      typedef _Compare value_compare;
    protected:
      _Sequence c;
      _Compare comp;
    public:
      inline explicit priority_queue(const _Compare &__x  = (_Compare()), const _Sequence &__s  = (_Sequence()))
        : c(__s), comp(__x)
      {
        std::make_heap(::std::priority_queue<_Tp, _Sequence, _Compare>::c.begin(), ::std::priority_queue<_Tp, _Sequence, _Compare>::c.end(), ::std::priority_queue<_Tp, _Sequence, _Compare>::comp);
      }
      template < typename _InputIterator >
      inline priority_queue(_InputIterator __first, _InputIterator __last, const _Compare &__x  = (_Compare()), const _Sequence &__s  = (_Sequence()))
        : c(__s), comp(__x)
      {
        ;
        ::std::priority_queue<_Tp, _Sequence, _Compare>::c.insert(::std::priority_queue<_Tp, _Sequence, _Compare>::c.end(), __first, __last);
        std::make_heap(::std::priority_queue<_Tp, _Sequence, _Compare>::c.begin(), ::std::priority_queue<_Tp, _Sequence, _Compare>::c.end(), ::std::priority_queue<_Tp, _Sequence, _Compare>::comp);
      }
      inline bool empty() const 
      {
        return ::std::priority_queue<_Tp, _Sequence, _Compare>::c.empty();
      }
      inline typename ::std::priority_queue<_Tp, _Sequence, _Compare>::size_type size() const 
      {
        return ::std::priority_queue<_Tp, _Sequence, _Compare>::c.size();
      }
      inline typename ::std::priority_queue<_Tp, _Sequence, _Compare>::const_reference top() const 
      {
        ;
        return ::std::priority_queue<_Tp, _Sequence, _Compare>::c.front();
      }
      inline void push(const typename ::std::priority_queue<_Tp, _Sequence, _Compare>::value_type &__x)
      {
        ::std::priority_queue<_Tp, _Sequence, _Compare>::c.push_back(__x);
        std::push_heap(::std::priority_queue<_Tp, _Sequence, _Compare>::c.begin(), ::std::priority_queue<_Tp, _Sequence, _Compare>::c.end(), ::std::priority_queue<_Tp, _Sequence, _Compare>::comp);
      }
      inline void pop()
      {
        ;
        std::pop_heap(::std::priority_queue<_Tp, _Sequence, _Compare>::c.begin(), ::std::priority_queue<_Tp, _Sequence, _Compare>::c.end(), ::std::priority_queue<_Tp, _Sequence, _Compare>::comp);
        ::std::priority_queue<_Tp, _Sequence, _Compare>::c.pop_back();
      }
  };
}
using namespace ::std;
struct  dispatch_job_t
{
    enum dispatch_type_e
    {
      JOB_SCORE = 0
    };
    ::dispatch_job_t::dispatch_type_e type;
    union  dispatch_params_t
    {
        struct  params_score_t
        {
            ::score_t score;
            int bx;
            int by;
        };
        ::dispatch_job_t::dispatch_params_t::params_score_t params_score;
    };
    ::dispatch_job_t::dispatch_params_t dispatch_params;
};
 /* Instantiation of class template '::__gnu_cxx::new_allocator< ::dispatch_job_t>' */ 
 /* Instantiation of class template '::std::allocator< ::dispatch_job_t>' */ 
 /* Instantiation of class template '::__gnu_cxx::__alloc_traits< ::std::allocator< ::dispatch_job_t> >' */ 
 /* Instantiation of class template '::std::allocator< ::dispatch_job_t>::rebind< ::dispatch_job_t>' */ 
 /* Instantiation of class template '::__gnu_cxx::__alloc_traits< ::std::allocator< ::dispatch_job_t> >::rebind< ::dispatch_job_t>' */ 
 /* Instantiation of class template '::std::allocator< ::dispatch_job_t>::rebind< ::dispatch_job_t *>' */ 
 /* Instantiation of class template '::__gnu_cxx::__alloc_traits< ::std::allocator< ::dispatch_job_t> >::rebind< ::dispatch_job_t *>' */ 
 /* Instantiation of class template '::std::_Deque_iterator< ::dispatch_job_t, ::dispatch_job_t &, ::dispatch_job_t *>' */ 
 /* Instantiation of class template '::std::_Deque_base< ::dispatch_job_t, ::std::allocator< ::dispatch_job_t> >::_Deque_impl' */ 
 /* Instantiation of class template '::std::_Deque_base< ::dispatch_job_t, ::std::allocator< ::dispatch_job_t> >' */ 
 /* Instantiation of class template '::std::deque< ::dispatch_job_t, ::std::allocator< ::dispatch_job_t> >' */ 
 /* Instantiation of class template '::std::queue< ::dispatch_job_t>' */ 
class  AbstractAlignerSafe : public ::AbstractAligner
{
  public:
    AbstractAlignerSafe();
    virtual ~AbstractAlignerSafe();
    virtual void dispatchColumn(int j, const ::cell_t *buffer, int len);
    virtual void dispatchRow(int i, const ::cell_t *buffer, int len);
    virtual void dispatchScore(::score_t score, int bx  = ( -1), int by  = ( -1));
  protected:
    void createDispatcherQueue();
    void destroyDispatcherQueue();
  private:
    ::pthread_t thread;
    ::pthread_mutex_t mutex;
    ::pthread_cond_t condition;
    bool dispatcherQueueActive;
    ::std::queue< ::dispatch_job_t> dispatcherQueue;
    static void *staticFunctionThread(void *arg);
    void executeLoop();
  public:
};
class  CPUBlockProcessor : public ::AbstractBlockProcessor
{
  public:
    CPUBlockProcessor();
    virtual ~CPUBlockProcessor();
    virtual void setSequences(const char *seq0, const char *seq1, int seq0_len, int seq1_len);
    virtual void unsetSequences();
    virtual ::score_t processBlock(::cell_t *row, ::cell_t *col, const int i0, const int j0, const int i1, const int j1, const int recurrenceType);
  private:
    const char *seq0;
    const char *seq1;
  public:
};
class  AlignerUtils
{
  public:
    static void splitBlocksEvenly(int *pos, int j0, int j1, int count);
    static ::match_result_t matchColumn(const ::cell_t *buffer, const ::cell_t *base, int len, int goalScore, int gap_open_penalty);
};
int libmasa_entry_point(int argc, char **argv, ::IAligner *aligner, char *aligner_header  = (0L));
class  StarPuAlignerParameters : public ::BlockAlignerParameters
{
  public:
    StarPuAlignerParameters();
    virtual ~StarPuAlignerParameters();
};
enum idtype_t
{
  P_ALL = 0,
  P_PID = 1,
  P_PGID = 2
};
struct  div_t
{
    int quot;
    int rem;
};
struct  ldiv_t
{
    long int quot;
    long int rem;
};
__extension__ struct  lldiv_t
{
    __extension__ long long int quot;
    __extension__ long long int rem;
};
extern "C"
{
  extern ::size_t __ctype_get_mb_cur_max() throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern inline double atof(const char *__nptr) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int atoi(const char *__nptr) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline long int atol(const char *__nptr) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline long long int atoll(const char *__nptr) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern double strtod(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern float strtof(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long double strtold(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern ::_Float32 strtof32(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern ::_Float64 strtof64(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern ::_Float128 strtof128(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern ::_Float32x strtof32x(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern ::_Float64x strtof64x(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long int strtol(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern unsigned long int strtoul(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long long int strtoq(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern unsigned long long int strtouq(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long long int strtoll(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern unsigned long long int strtoull(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int strfromd(char *__dest, ::size_t __size, const char *__format, double __f) throw() __attribute__((__nonnull__(3)));
}
extern "C"
{
  extern int strfromf(char *__dest, ::size_t __size, const char *__format, float __f) throw() __attribute__((__nonnull__(3)));
}
extern "C"
{
  extern int strfroml(char *__dest, ::size_t __size, const char *__format, long double __f) throw() __attribute__((__nonnull__(3)));
}
extern "C"
{
  extern int strfromf32(char *__dest, ::size_t __size, const char *__format, ::_Float32 __f) throw() __attribute__((__nonnull__(3)));
}
extern "C"
{
  extern int strfromf64(char *__dest, ::size_t __size, const char *__format, ::_Float64 __f) throw() __attribute__((__nonnull__(3)));
}
extern "C"
{
  extern int strfromf128(char *__dest, ::size_t __size, const char *__format, ::_Float128 __f) throw() __attribute__((__nonnull__(3)));
}
extern "C"
{
  extern int strfromf32x(char *__dest, ::size_t __size, const char *__format, ::_Float32x __f) throw() __attribute__((__nonnull__(3)));
}
extern "C"
{
  extern int strfromf64x(char *__dest, ::size_t __size, const char *__format, ::_Float64x __f) throw() __attribute__((__nonnull__(3)));
}
extern "C"
{
  extern long int strtol_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, ::locale_t __loc) throw() __attribute__((__nonnull__(1, 4)));
}
extern "C"
{
  extern unsigned long int strtoul_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, ::locale_t __loc) throw() __attribute__((__nonnull__(1, 4)));
}
extern "C"
{
  extern long long int strtoll_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, ::locale_t __loc) throw() __attribute__((__nonnull__(1, 4)));
}
extern "C"
{
  extern unsigned long long int strtoull_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, ::locale_t __loc) throw() __attribute__((__nonnull__(1, 4)));
}
extern "C"
{
  extern double strtod_l(const char *__restrict __nptr, char **__restrict __endptr, ::locale_t __loc) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern float strtof_l(const char *__restrict __nptr, char **__restrict __endptr, ::locale_t __loc) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern long double strtold_l(const char *__restrict __nptr, char **__restrict __endptr, ::locale_t __loc) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern ::_Float32 strtof32_l(const char *__restrict __nptr, char **__restrict __endptr, ::locale_t __loc) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern ::_Float64 strtof64_l(const char *__restrict __nptr, char **__restrict __endptr, ::locale_t __loc) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern ::_Float128 strtof128_l(const char *__restrict __nptr, char **__restrict __endptr, ::locale_t __loc) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern ::_Float32x strtof32x_l(const char *__restrict __nptr, char **__restrict __endptr, ::locale_t __loc) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern ::_Float64x strtof64x_l(const char *__restrict __nptr, char **__restrict __endptr, ::locale_t __loc) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) int atoi(const char *__nptr) throw()
  {
    return (int)::strtol(__nptr, (char **)0L, 10);
  }
}
extern "C"
{
  extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) long int atol(const char *__nptr) throw()
  {
    return ::strtol(__nptr, (char **)0L, 10);
  }
}
extern "C"
{
  __extension__ extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) long long int atoll(const char *__nptr) throw()
  {
    return ::strtoll(__nptr, (char **)0L, 10);
  }
}
extern "C"
{
  extern char *l64a(long int __n) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern long int a64l(const char *__s) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
typedef ::__u_char u_char;
typedef ::__u_short u_short;
typedef ::__u_int u_int;
typedef ::__u_long u_long;
typedef ::__quad_t quad_t;
typedef ::__u_quad_t u_quad_t;
typedef ::__fsid_t fsid_t;
typedef ::__loff_t loff_t;
typedef ::__ino_t ino_t;
typedef ::__ino64_t ino64_t;
typedef ::__dev_t dev_t;
typedef ::__gid_t gid_t;
typedef ::__mode_t mode_t;
typedef ::__nlink_t nlink_t;
typedef ::__uid_t uid_t;
typedef ::__id_t id_t;
typedef ::__daddr_t daddr_t;
typedef ::__caddr_t caddr_t;
typedef ::__key_t key_t;
typedef ::__useconds_t useconds_t;
typedef ::__suseconds_t suseconds_t;
typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
typedef ::__int8_t int8_t;
typedef ::__int16_t int16_t;
typedef ::__int32_t int32_t;
typedef ::__int64_t int64_t;
typedef unsigned char u_int8_t;
typedef unsigned short int u_int16_t;
typedef unsigned int u_int32_t;
typedef unsigned long int u_int64_t;
typedef long int register_t;
struct  __sigset_t
{
    unsigned long int __val[16L];
};
typedef ::__sigset_t sigset_t;
typedef long int __fd_mask;
struct  fd_set
{
    ::__fd_mask fds_bits[16L];
};
typedef ::__fd_mask fd_mask;
extern "C"
{
  extern int select(int __nfds, ::fd_set *__restrict __readfds, ::fd_set *__restrict __writefds, ::fd_set *__restrict __exceptfds, ::timeval *__restrict __timeout);
}
extern "C"
{
  extern int pselect(int __nfds, ::fd_set *__restrict __readfds, ::fd_set *__restrict __writefds, ::fd_set *__restrict __exceptfds, const ::timespec *__restrict __timeout, const ::__sigset_t *__restrict __sigmask);
}
extern "C"
{
  extern long int __fdelt_chk(long int __d);
}
extern "C"
{
  extern long int __fdelt_warn(long int __d) __attribute__((__warning__("bit outside of fd_set selected")));
}
extern "C"
{
  extern inline unsigned int gnu_dev_major(::__dev_t __dev) throw() __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline unsigned int gnu_dev_minor(::__dev_t __dev) throw() __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline ::__dev_t gnu_dev_makedev(unsigned int __major, unsigned int __minor) throw() __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  __extension__ extern inline __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) unsigned int gnu_dev_major(::__dev_t __dev) throw()
  {
    __extension__ unsigned int __major;
    __major = (__dev & (::__dev_t)1048320U) >> 8;
    __major |= (__dev & (::__dev_t)18446726481523507200LU) >> 32;
    return __major;
  }
}
extern "C"
{
  __extension__ extern inline __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) unsigned int gnu_dev_minor(::__dev_t __dev) throw()
  {
    __extension__ unsigned int __minor;
    __minor = (__dev & (::__dev_t)255U) >> 0;
    __minor |= (__dev & (::__dev_t)17592184995840LU) >> 12;
    return __minor;
  }
}
extern "C"
{
  __extension__ extern inline __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) ::__dev_t gnu_dev_makedev(unsigned int __major, unsigned int __minor) throw()
  {
    __extension__ ::__dev_t __dev;
    __dev = (::__dev_t)(__major & 4095U) << 8;
    __dev |= (::__dev_t)(__major & 4294963200U) << 32;
    __dev |= (::__dev_t)(__minor & 255U) << 0;
    __dev |= (::__dev_t)(__minor & 4294967040U) << 12;
    return __dev;
  }
}
typedef ::__blksize_t blksize_t;
typedef ::__blkcnt_t blkcnt_t;
typedef ::__fsblkcnt_t fsblkcnt_t;
typedef ::__fsfilcnt_t fsfilcnt_t;
typedef ::__blkcnt64_t blkcnt64_t;
typedef ::__fsblkcnt64_t fsblkcnt64_t;
typedef ::__fsfilcnt64_t fsfilcnt64_t;
extern "C"
{
  extern long int random() throw();
}
extern "C"
{
  extern void srandom(unsigned int __seed) throw();
}
extern "C"
{
  extern char *initstate(unsigned int __seed, char *__statebuf, ::size_t __statelen) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern char *setstate(char *__statebuf) throw() __attribute__((__nonnull__(1)));
}
struct  random_data
{
    ::int32_t *fptr;
    ::int32_t *rptr;
    ::int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    ::int32_t *end_ptr;
};
extern "C"
{
  extern int random_r(::random_data *__restrict __buf, ::int32_t *__restrict __result) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int srandom_r(unsigned int __seed, ::random_data *__buf) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int initstate_r(unsigned int __seed, char *__restrict __statebuf, ::size_t __statelen, ::random_data *__restrict __buf) throw() __attribute__((__nonnull__(2, 4)));
}
extern "C"
{
  extern int setstate_r(char *__restrict __statebuf, ::random_data *__restrict __buf) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int rand() throw();
}
extern "C"
{
  extern void srand(unsigned int __seed) throw();
}
extern "C"
{
  extern int rand_r(unsigned int *__seed) throw();
}
extern "C"
{
  extern double drand48() throw();
}
extern "C"
{
  extern double erand48(unsigned short int __xsubi[3L]) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long int lrand48() throw();
}
extern "C"
{
  extern long int nrand48(unsigned short int __xsubi[3L]) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long int mrand48() throw();
}
extern "C"
{
  extern long int jrand48(unsigned short int __xsubi[3L]) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern void srand48(long int __seedval) throw();
}
extern "C"
{
  extern unsigned short int *seed48(unsigned short int __seed16v[3L]) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern void lcong48(unsigned short int __param[7L]) throw() __attribute__((__nonnull__(1)));
}
struct  drand48_data
{
    unsigned short int __x[3L];
    unsigned short int __old_x[3L];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;
};
extern "C"
{
  extern int drand48_r(::drand48_data *__restrict __buffer, double *__restrict __result) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int erand48_r(unsigned short int __xsubi[3L], ::drand48_data *__restrict __buffer, double *__restrict __result) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int lrand48_r(::drand48_data *__restrict __buffer, long int *__restrict __result) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int nrand48_r(unsigned short int __xsubi[3L], ::drand48_data *__restrict __buffer, long int *__restrict __result) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int mrand48_r(::drand48_data *__restrict __buffer, long int *__restrict __result) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int jrand48_r(unsigned short int __xsubi[3L], ::drand48_data *__restrict __buffer, long int *__restrict __result) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int srand48_r(long int __seedval, ::drand48_data *__buffer) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int seed48_r(unsigned short int __seed16v[3L], ::drand48_data *__buffer) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int lcong48_r(unsigned short int __param[7L], ::drand48_data *__buffer) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern void *malloc(::size_t __size) throw() __attribute__((__malloc__)) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern void *calloc(::size_t __nmemb, ::size_t __size) throw() __attribute__((__malloc__)) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern void *realloc(void *__ptr, ::size_t __size) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern void *reallocarray(void *__ptr, ::size_t __nmemb, ::size_t __size) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern void free(void *__ptr) throw();
}
extern "C"
{
  extern void *alloca(::size_t __size) throw();
}
extern "C"
{
  extern void *valloc(::size_t __size) throw() __attribute__((__malloc__)) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int posix_memalign(void **__memptr, ::size_t __alignment, ::size_t __size) throw() __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern void *aligned_alloc(::size_t __alignment, ::size_t __size) throw() __attribute__((__malloc__)) __attribute__((__alloc_size__(2))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern void abort() throw() __attribute__((__noreturn__));
}
extern "C"
{
  extern int atexit(void (*__func)()) throw() __attribute__((__nonnull__(1)));
}
int at_quick_exit(void (*__func)()) throw() __asm("at_quick_exit") __attribute__((__nonnull__(1)));
extern "C"
{
  extern int on_exit(void (*__func)(int, void *), void *__arg) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern void exit(int __status) throw() __attribute__((__noreturn__));
}
extern "C"
{
  extern void quick_exit(int __status) throw() __attribute__((__noreturn__));
}
extern "C"
{
  extern void _Exit(int __status) throw() __attribute__((__noreturn__));
}
extern "C"
{
  extern char *getenv(const char *__name) throw() __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern char *secure_getenv(const char *__name) throw() __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int putenv(char *__string) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int setenv(const char *__name, const char *__value, int __replace) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int unsetenv(const char *__name) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int clearenv() throw();
}
extern "C"
{
  extern char *mktemp(char *__template) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int mkstemp(char *__template) __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int mkstemp64(char *__template) __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int mkstemps(char *__template, int __suffixlen) __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int mkstemps64(char *__template, int __suffixlen) __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern char *mkdtemp(char *__template) throw() __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int mkostemp(char *__template, int __flags) __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int mkostemp64(char *__template, int __flags) __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int mkostemps(char *__template, int __suffixlen, int __flags) __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int mkostemps64(char *__template, int __suffixlen, int __flags) __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int system(const char *__command) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern char *canonicalize_file_name(const char *__name) throw() __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern inline char *realpath(const char *__restrict __name, char *__restrict __resolved) throw() __attribute__((__warn_unused_result__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
typedef int (*__compar_fn_t)(const void *, const void *);
typedef ::__compar_fn_t comparison_fn_t;
typedef int (*__compar_d_fn_t)(const void *, const void *, void *);
extern "C"
{
  extern inline void *bsearch(const void *__key, const void *__base, ::size_t __nmemb, ::size_t __size, ::__compar_fn_t __compar) __attribute__((__nonnull__(1, 2, 5))) __attribute__((__warn_unused_result__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline __attribute__((__nonnull__(1, 2, 5))) __attribute__((__warn_unused_result__)) __attribute__((__gnu_inline__)) void *bsearch(const void *__key, const void *__base, ::size_t __nmemb, ::size_t __size, ::__compar_fn_t __compar)
  {
    ::size_t __l;
    ::size_t __u;
    ::size_t __idx;
    const void *__p;
    int __comparison;
    __l = 0;
    __u = __nmemb;
    while (__l < __u)
      {
        __idx = (__l + __u) / 2;
        __p = (void *)((const char *)__base + __idx * __size);
        __comparison = (*__compar)(__key, __p);
        if (__comparison < 0)
          {
            __u = __idx;
          }
        else
          {
            if (__comparison > 0)
              {
                __l = __idx + 1;
              }
            else
              {
                return (void *)__p;
              }
          }
      }
    return 0L;
  }
}
extern "C"
{
  extern void qsort(void *__base, ::size_t __nmemb, ::size_t __size, ::__compar_fn_t __compar) __attribute__((__nonnull__(1, 4)));
}
extern "C"
{
  extern void qsort_r(void *__base, ::size_t __nmemb, ::size_t __size, ::__compar_d_fn_t __compar, void *__arg) __attribute__((__nonnull__(1, 4)));
}
extern "C"
{
  extern int abs(int __x) throw() __attribute__((__const__)) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern long int labs(long int __x) throw() __attribute__((__const__)) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern long long int llabs(long long int __x) throw() __attribute__((__const__)) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::div_t div(int __numer, int __denom) throw() __attribute__((__const__)) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::ldiv_t ldiv(long int __numer, long int __denom) throw() __attribute__((__const__)) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::lldiv_t lldiv(long long int __numer, long long int __denom) throw() __attribute__((__const__)) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern char *ecvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((__nonnull__(3, 4))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern char *fcvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((__nonnull__(3, 4))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern char *gcvt(double __value, int __ndigit, char *__buf) throw() __attribute__((__nonnull__(3))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern char *qecvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((__nonnull__(3, 4))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern char *qfcvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((__nonnull__(3, 4))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern char *qgcvt(long double __value, int __ndigit, char *__buf) throw() __attribute__((__nonnull__(3))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int ecvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, ::size_t __len) throw() __attribute__((__nonnull__(3, 4, 5)));
}
extern "C"
{
  extern int fcvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, ::size_t __len) throw() __attribute__((__nonnull__(3, 4, 5)));
}
extern "C"
{
  extern int qecvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, ::size_t __len) throw() __attribute__((__nonnull__(3, 4, 5)));
}
extern "C"
{
  extern int qfcvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, ::size_t __len) throw() __attribute__((__nonnull__(3, 4, 5)));
}
extern "C"
{
  extern int mblen(const char *__s, ::size_t __n) throw();
}
extern "C"
{
  extern int mbtowc(wchar_t *__restrict __pwc, const char *__restrict __s, ::size_t __n) throw();
}
extern "C"
{
  extern inline int wctomb(char *__s, wchar_t __wchar) throw() __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern inline ::size_t mbstowcs(wchar_t *__restrict __dst, const char *__restrict __src, ::size_t __len) throw() __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern inline ::size_t wcstombs(char *__restrict __dst, const wchar_t *__restrict __src, ::size_t __len) throw() __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern int rpmatch(const char *__response) throw() __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int getsubopt(char **__restrict __optionp, char *const *__restrict __tokens, char **__restrict __valuep) throw() __attribute__((__nonnull__(1, 2, 3))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern void setkey(const char *__key) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int posix_openpt(int __oflag) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int grantpt(int __fd) throw();
}
extern "C"
{
  extern int unlockpt(int __fd) throw();
}
extern "C"
{
  extern char *ptsname(int __fd) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern inline int ptsname_r(int __fd, char *__buf, ::size_t __buflen) throw() __attribute__((__nonnull__(2))) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern int getpt();
}
extern "C"
{
  extern int getloadavg(double __loadavg[], int __nelem) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) double atof(const char *__nptr) throw()
  {
    return ::strtod(__nptr, (char **)0L);
  }
}
extern "C"
{
  extern char *__realpath_chk(const char *__restrict __name, char *__restrict __resolved, ::size_t __resolvedlen) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern char *__realpath_alias(const char *__restrict __name, char *__restrict __resolved) throw() __asm("""realpath") __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern char *__realpath_chk_warn(const char *__restrict __name, char *__restrict __resolved, ::size_t __resolvedlen) throw() __asm("""__realpath_chk") __attribute__((__warn_unused_result__)) __attribute__((__warning__("second argument of realpath must be either NULL or at ""least PATH_MAX bytes long buffer")));
}
extern "C"
{
  extern inline __attribute__((__warn_unused_result__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) char *realpath(const char *__restrict __name, char *__restrict __resolved) throw()
  {
    if (__builtin_object_size(__resolved, 2 > 1) != (::size_t) -1)
      {
        return ::__realpath_chk(__name, __resolved, __builtin_object_size(__resolved, 2 > 1));
      }
    return ::__realpath_alias(__name, __resolved);
  }
}
extern "C"
{
  extern int __ptsname_r_chk(int __fd, char *__buf, ::size_t __buflen, ::size_t __nreal) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int __ptsname_r_alias(int __fd, char *__buf, ::size_t __buflen) throw() __asm("""ptsname_r") __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int __ptsname_r_chk_warn(int __fd, char *__buf, ::size_t __buflen, ::size_t __nreal) throw() __asm("""__ptsname_r_chk") __attribute__((__nonnull__(2))) __attribute__((__warning__("ptsname_r called with buflen bigger than ""size of buf")));
}
extern "C"
{
  extern inline __attribute__((__nonnull__(2))) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int ptsname_r(int __fd, char *__buf, ::size_t __buflen) throw()
  {
    if (__builtin_object_size(__buf, 2 > 1) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__buflen))
          {
            return ::__ptsname_r_chk(__fd, __buf, __buflen, __builtin_object_size(__buf, 2 > 1));
          }
        if (__buflen > __builtin_object_size(__buf, 2 > 1))
          {
            return ::__ptsname_r_chk_warn(__fd, __buf, __buflen, __builtin_object_size(__buf, 2 > 1));
          }
      }
    return ::__ptsname_r_alias(__fd, __buf, __buflen);
  }
}
extern "C"
{
  extern int __wctomb_chk(char *__s, wchar_t __wchar, ::size_t __buflen) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int __wctomb_alias(char *__s, wchar_t __wchar) throw() __asm("""wctomb") __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) __attribute__((__warn_unused_result__)) int wctomb(char *__s, wchar_t __wchar) throw()
  {
    if (__builtin_object_size(__s, 2 > 1) != (::size_t) -1 && 16 > __builtin_object_size(__s, 2 > 1))
      {
        return ::__wctomb_chk(__s, __wchar, __builtin_object_size(__s, 2 > 1));
      }
    return ::__wctomb_alias(__s, __wchar);
  }
}
extern "C"
{
  extern ::size_t __mbstowcs_chk(wchar_t *__restrict __dst, const char *__restrict __src, ::size_t __len, ::size_t __dstlen) throw();
}
extern "C"
{
  extern ::size_t __mbstowcs_alias(wchar_t *__restrict __dst, const char *__restrict __src, ::size_t __len) throw() __asm("""mbstowcs");
}
extern "C"
{
  extern ::size_t __mbstowcs_chk_warn(wchar_t *__restrict __dst, const char *__restrict __src, ::size_t __len, ::size_t __dstlen) throw() __asm("""__mbstowcs_chk") __attribute__((__warning__("mbstowcs called with dst buffer smaller than len ""* sizeof (wchar_t)")));
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) ::size_t mbstowcs(wchar_t *__restrict __dst, const char *__restrict __src, ::size_t __len) throw()
  {
    if (__builtin_object_size(__dst, 2 > 1) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__len))
          {
            return ::__mbstowcs_chk(__dst, __src, __len, __builtin_object_size(__dst, 2 > 1) / sizeof(wchar_t));
          }
        if (__len > __builtin_object_size(__dst, 2 > 1) / sizeof(wchar_t))
          {
            return ::__mbstowcs_chk_warn(__dst, __src, __len, __builtin_object_size(__dst, 2 > 1) / sizeof(wchar_t));
          }
      }
    return ::__mbstowcs_alias(__dst, __src, __len);
  }
}
extern "C"
{
  extern ::size_t __wcstombs_chk(char *__restrict __dst, const wchar_t *__restrict __src, ::size_t __len, ::size_t __dstlen) throw();
}
extern "C"
{
  extern ::size_t __wcstombs_alias(char *__restrict __dst, const wchar_t *__restrict __src, ::size_t __len) throw() __asm("""wcstombs");
}
extern "C"
{
  extern ::size_t __wcstombs_chk_warn(char *__restrict __dst, const wchar_t *__restrict __src, ::size_t __len, ::size_t __dstlen) throw() __asm("""__wcstombs_chk") __attribute__((__warning__("wcstombs called with dst buffer smaller than len")));
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) ::size_t wcstombs(char *__restrict __dst, const wchar_t *__restrict __src, ::size_t __len) throw()
  {
    if (__builtin_object_size(__dst, 2 > 1) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__len))
          {
            return ::__wcstombs_chk(__dst, __src, __len, __builtin_object_size(__dst, 2 > 1));
          }
        if (__len > __builtin_object_size(__dst, 2 > 1))
          {
            return ::__wcstombs_chk_warn(__dst, __src, __len, __builtin_object_size(__dst, 2 > 1));
          }
      }
    return ::__wcstombs_alias(__dst, __src, __len);
  }
}
namespace std __attribute__((__visibility__("default"))) {
  using ::abs;
  inline long int abs(long int __i)
  {
    return __builtin_labs(__i);
  }
  inline long long int abs(long long int __x)
  {
    return __builtin_llabs(__x);
  }
  inline double abs(double __x)
  {
    return __builtin_fabs(__x);
  }
  inline float abs(float __x)
  {
    return __builtin_fabsf(__x);
  }
  inline long double abs(long double __x)
  {
    return __builtin_fabsl(__x);
  }
  inline __int128 abs(__int128 __x)
  {
    return __x >= 0 ? __x :  -__x;
  }
  inline __float128 abs(__float128 __x)
  {
    return __x < 0 ?  -__x : __x;
  }
  using ::div_t;
  using ::ldiv_t;
  using ::abort;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;
  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;
  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;
  using ::wcstombs;
  using ::wctomb;
  inline ::ldiv_t div(long int __i, long int __j)
  {
    return ::std::ldiv(__i, __j);
  }
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  using ::lldiv_t;
  using ::_Exit;
  using ::llabs;
  inline ::lldiv_t div(long long int __n, long long int __d)
  {
    ::lldiv_t __q /* () */ ;
    __q.quot = __n / __d;
    __q.rem = __n % __d;
    return __q;
  }
  using ::lldiv;
  using ::atoll;
  using ::strtoll;
  using ::strtoull;
  using ::strtof;
  using ::strtold;
}
namespace std __attribute__((__visibility__("default"))) {
  using ::__gnu_cxx::lldiv_t;
  using ::__gnu_cxx::_Exit;
  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;
  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}
using ::std::abort;
using ::std::atexit;
using ::std::exit;
using ::std::div_t;
using ::std::ldiv_t;
using ::std::abs;
using ::std::atof;
using ::std::atoi;
using ::std::atol;
using ::std::bsearch;
using ::std::calloc;
using ::std::div;
using ::std::free;
using ::std::getenv;
using ::std::labs;
using ::std::ldiv;
using ::std::malloc;
using ::std::mblen;
using ::std::mbstowcs;
using ::std::mbtowc;
using ::std::qsort;
using ::std::rand;
using ::std::realloc;
using ::std::srand;
using ::std::strtod;
using ::std::strtol;
using ::std::strtoul;
using ::std::system;
using ::std::wcstombs;
using ::std::wctomb;
typedef ::__uint8_t uint8_t;
typedef ::__uint16_t uint16_t;
typedef ::__uint32_t uint32_t;
typedef ::__uint64_t uint64_t;
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;
typedef long int int_least64_t;
typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;
typedef unsigned long int uint_least64_t;
typedef signed char int_fast8_t;
typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
typedef long int intptr_t;
typedef unsigned long int uintptr_t;
typedef ::__intmax_t intmax_t;
typedef ::__uintmax_t uintmax_t;
typedef ::ssize_t starpu_ssize_t;
typedef ::int8_t cl_char;
typedef ::uint8_t cl_uchar;
typedef __attribute__((aligned(2))) ::int16_t cl_short;
typedef __attribute__((aligned(2))) ::uint16_t cl_ushort;
typedef __attribute__((aligned(4))) ::int32_t cl_int;
typedef __attribute__((aligned(4))) ::uint32_t cl_uint;
typedef __attribute__((aligned(8))) ::int64_t cl_long;
typedef __attribute__((aligned(8))) ::uint64_t cl_ulong;
typedef __attribute__((aligned(2))) ::uint16_t cl_half;
typedef __attribute__((aligned(4))) float cl_float;
typedef __attribute__((aligned(8))) double cl_double;
typedef long int ptrdiff_t;
typedef unsigned int cl_GLuint;
typedef int cl_GLint;
typedef unsigned int cl_GLenum;
typedef __attribute__((vector_size(8))) __attribute__((__may_alias__)) int __m64;
typedef __attribute__((aligned(1))) __attribute__((vector_size(8))) __attribute__((__may_alias__)) int __m64_u;
typedef __attribute__((vector_size(8))) __attribute__((__may_alias__)) int __v2si;
typedef __attribute__((vector_size(8))) __attribute__((__may_alias__)) short int __v4hi;
typedef __attribute__((vector_size(8))) __attribute__((__may_alias__)) char __v8qi;
typedef __attribute__((vector_size(8))) __attribute__((__may_alias__)) long long int __v1di;
typedef __attribute__((vector_size(8))) __attribute__((__may_alias__)) float __v2sf;
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_empty()
  {
    __builtin_ia32_emms();
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _m_empty()
  {
    ::_mm_empty();
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cvtsi32_si64(int __i)
  {
    return (::__m64)__builtin_ia32_vec_init_v2si(__i, 0);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_from_int(int __i)
  {
    return ::_mm_cvtsi32_si64(__i);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_from_int64(long long int __i)
  {
    return (::__m64)__i;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cvtsi64_m64(long long int __i)
  {
    return (::__m64)__i;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cvtsi64x_si64(long long int __i)
  {
    return (::__m64)__i;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_set_pi64x(long long int __i)
  {
    return (::__m64)__i;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_cvtsi64_si32(::__m64 __i)
  {
    return __builtin_ia32_vec_ext_v2si((::__v2si)__i, 0);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _m_to_int(::__m64 __i)
  {
    return ::_mm_cvtsi64_si32(__i);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _m_to_int64(::__m64 __i)
  {
    return (long long int)__i;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _mm_cvtm64_si64(::__m64 __i)
  {
    return (long long int)__i;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _mm_cvtsi64_si64x(::__m64 __i)
  {
    return (long long int)__i;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_packs_pi16(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_packsswb((::__v4hi)__m1, (::__v4hi)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_packsswb(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_packs_pi16(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_packs_pi32(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_packssdw((::__v2si)__m1, (::__v2si)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_packssdw(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_packs_pi32(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_packs_pu16(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_packuswb((::__v4hi)__m1, (::__v4hi)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_packuswb(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_packs_pu16(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_unpackhi_pi8(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_punpckhbw((::__v8qi)__m1, (::__v8qi)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_punpckhbw(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_unpackhi_pi8(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_unpackhi_pi16(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_punpckhwd((::__v4hi)__m1, (::__v4hi)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_punpckhwd(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_unpackhi_pi16(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_unpackhi_pi32(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_punpckhdq((::__v2si)__m1, (::__v2si)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_punpckhdq(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_unpackhi_pi32(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_unpacklo_pi8(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_punpcklbw((::__v8qi)__m1, (::__v8qi)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_punpcklbw(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_unpacklo_pi8(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_unpacklo_pi16(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_punpcklwd((::__v4hi)__m1, (::__v4hi)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_punpcklwd(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_unpacklo_pi16(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_unpacklo_pi32(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_punpckldq((::__v2si)__m1, (::__v2si)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_punpckldq(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_unpacklo_pi32(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_add_pi8(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_paddb((::__v8qi)__m1, (::__v8qi)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_paddb(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_add_pi8(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_add_pi16(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_paddw((::__v4hi)__m1, (::__v4hi)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_paddw(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_add_pi16(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_add_pi32(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_paddd((::__v2si)__m1, (::__v2si)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_paddd(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_add_pi32(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_add_si64(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_paddq((::__v1di)__m1, (::__v1di)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_adds_pi8(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_paddsb((::__v8qi)__m1, (::__v8qi)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_paddsb(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_adds_pi8(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_adds_pi16(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_paddsw((::__v4hi)__m1, (::__v4hi)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_paddsw(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_adds_pi16(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_adds_pu8(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_paddusb((::__v8qi)__m1, (::__v8qi)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_paddusb(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_adds_pu8(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_adds_pu16(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_paddusw((::__v4hi)__m1, (::__v4hi)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_paddusw(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_adds_pu16(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_sub_pi8(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_psubb((::__v8qi)__m1, (::__v8qi)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psubb(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_sub_pi8(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_sub_pi16(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_psubw((::__v4hi)__m1, (::__v4hi)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psubw(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_sub_pi16(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_sub_pi32(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_psubd((::__v2si)__m1, (::__v2si)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psubd(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_sub_pi32(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_sub_si64(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_psubq((::__v1di)__m1, (::__v1di)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_subs_pi8(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_psubsb((::__v8qi)__m1, (::__v8qi)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psubsb(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_subs_pi8(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_subs_pi16(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_psubsw((::__v4hi)__m1, (::__v4hi)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psubsw(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_subs_pi16(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_subs_pu8(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_psubusb((::__v8qi)__m1, (::__v8qi)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psubusb(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_subs_pu8(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_subs_pu16(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_psubusw((::__v4hi)__m1, (::__v4hi)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psubusw(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_subs_pu16(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_madd_pi16(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_pmaddwd((::__v4hi)__m1, (::__v4hi)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pmaddwd(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_madd_pi16(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_mulhi_pi16(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_pmulhw((::__v4hi)__m1, (::__v4hi)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pmulhw(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_mulhi_pi16(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_mullo_pi16(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_pmullw((::__v4hi)__m1, (::__v4hi)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pmullw(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_mullo_pi16(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_sll_pi16(::__m64 __m, ::__m64 __count)
  {
    return (::__m64)__builtin_ia32_psllw((::__v4hi)__m, (::__v4hi)__count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psllw(::__m64 __m, ::__m64 __count)
  {
    return ::_mm_sll_pi16(__m, __count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_slli_pi16(::__m64 __m, int __count)
  {
    return (::__m64)__builtin_ia32_psllwi((::__v4hi)__m, __count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psllwi(::__m64 __m, int __count)
  {
    return ::_mm_slli_pi16(__m, __count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_sll_pi32(::__m64 __m, ::__m64 __count)
  {
    return (::__m64)__builtin_ia32_pslld((::__v2si)__m, (::__v2si)__count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pslld(::__m64 __m, ::__m64 __count)
  {
    return ::_mm_sll_pi32(__m, __count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_slli_pi32(::__m64 __m, int __count)
  {
    return (::__m64)__builtin_ia32_pslldi((::__v2si)__m, __count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pslldi(::__m64 __m, int __count)
  {
    return ::_mm_slli_pi32(__m, __count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_sll_si64(::__m64 __m, ::__m64 __count)
  {
    return (::__m64)__builtin_ia32_psllq((::__v1di)__m, (::__v1di)__count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psllq(::__m64 __m, ::__m64 __count)
  {
    return ::_mm_sll_si64(__m, __count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_slli_si64(::__m64 __m, int __count)
  {
    return (::__m64)__builtin_ia32_psllqi((::__v1di)__m, __count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psllqi(::__m64 __m, int __count)
  {
    return ::_mm_slli_si64(__m, __count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_sra_pi16(::__m64 __m, ::__m64 __count)
  {
    return (::__m64)__builtin_ia32_psraw((::__v4hi)__m, (::__v4hi)__count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psraw(::__m64 __m, ::__m64 __count)
  {
    return ::_mm_sra_pi16(__m, __count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_srai_pi16(::__m64 __m, int __count)
  {
    return (::__m64)__builtin_ia32_psrawi((::__v4hi)__m, __count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psrawi(::__m64 __m, int __count)
  {
    return ::_mm_srai_pi16(__m, __count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_sra_pi32(::__m64 __m, ::__m64 __count)
  {
    return (::__m64)__builtin_ia32_psrad((::__v2si)__m, (::__v2si)__count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psrad(::__m64 __m, ::__m64 __count)
  {
    return ::_mm_sra_pi32(__m, __count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_srai_pi32(::__m64 __m, int __count)
  {
    return (::__m64)__builtin_ia32_psradi((::__v2si)__m, __count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psradi(::__m64 __m, int __count)
  {
    return ::_mm_srai_pi32(__m, __count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_srl_pi16(::__m64 __m, ::__m64 __count)
  {
    return (::__m64)__builtin_ia32_psrlw((::__v4hi)__m, (::__v4hi)__count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psrlw(::__m64 __m, ::__m64 __count)
  {
    return ::_mm_srl_pi16(__m, __count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_srli_pi16(::__m64 __m, int __count)
  {
    return (::__m64)__builtin_ia32_psrlwi((::__v4hi)__m, __count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psrlwi(::__m64 __m, int __count)
  {
    return ::_mm_srli_pi16(__m, __count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_srl_pi32(::__m64 __m, ::__m64 __count)
  {
    return (::__m64)__builtin_ia32_psrld((::__v2si)__m, (::__v2si)__count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psrld(::__m64 __m, ::__m64 __count)
  {
    return ::_mm_srl_pi32(__m, __count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_srli_pi32(::__m64 __m, int __count)
  {
    return (::__m64)__builtin_ia32_psrldi((::__v2si)__m, __count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psrldi(::__m64 __m, int __count)
  {
    return ::_mm_srli_pi32(__m, __count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_srl_si64(::__m64 __m, ::__m64 __count)
  {
    return (::__m64)__builtin_ia32_psrlq((::__v1di)__m, (::__v1di)__count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psrlq(::__m64 __m, ::__m64 __count)
  {
    return ::_mm_srl_si64(__m, __count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_srli_si64(::__m64 __m, int __count)
  {
    return (::__m64)__builtin_ia32_psrlqi((::__v1di)__m, __count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psrlqi(::__m64 __m, int __count)
  {
    return ::_mm_srli_si64(__m, __count);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_and_si64(::__m64 __m1, ::__m64 __m2)
  {
    return __builtin_ia32_pand(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pand(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_and_si64(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_andnot_si64(::__m64 __m1, ::__m64 __m2)
  {
    return __builtin_ia32_pandn(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pandn(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_andnot_si64(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_or_si64(::__m64 __m1, ::__m64 __m2)
  {
    return __builtin_ia32_por(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_por(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_or_si64(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_xor_si64(::__m64 __m1, ::__m64 __m2)
  {
    return __builtin_ia32_pxor(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pxor(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_xor_si64(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cmpeq_pi8(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_pcmpeqb((::__v8qi)__m1, (::__v8qi)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pcmpeqb(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_cmpeq_pi8(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cmpgt_pi8(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_pcmpgtb((::__v8qi)__m1, (::__v8qi)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pcmpgtb(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_cmpgt_pi8(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cmpeq_pi16(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_pcmpeqw((::__v4hi)__m1, (::__v4hi)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pcmpeqw(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_cmpeq_pi16(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cmpgt_pi16(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_pcmpgtw((::__v4hi)__m1, (::__v4hi)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pcmpgtw(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_cmpgt_pi16(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cmpeq_pi32(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_pcmpeqd((::__v2si)__m1, (::__v2si)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pcmpeqd(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_cmpeq_pi32(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cmpgt_pi32(::__m64 __m1, ::__m64 __m2)
  {
    return (::__m64)__builtin_ia32_pcmpgtd((::__v2si)__m1, (::__v2si)__m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pcmpgtd(::__m64 __m1, ::__m64 __m2)
  {
    return ::_mm_cmpgt_pi32(__m1, __m2);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_setzero_si64()
  {
    return (::__m64)0LL;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_set_pi32(int __i1, int __i0)
  {
    return (::__m64)__builtin_ia32_vec_init_v2si(__i0, __i1);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_set_pi16(short int __w3, short int __w2, short int __w1, short int __w0)
  {
    return (::__m64)__builtin_ia32_vec_init_v4hi(__w0, __w1, __w2, __w3);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_set_pi8(char __b7, char __b6, char __b5, char __b4, char __b3, char __b2, char __b1, char __b0)
  {
    return (::__m64)__builtin_ia32_vec_init_v8qi(__b0, __b1, __b2, __b3, __b4, __b5, __b6, __b7);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_setr_pi32(int __i0, int __i1)
  {
    return ::_mm_set_pi32(__i1, __i0);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_setr_pi16(short int __w0, short int __w1, short int __w2, short int __w3)
  {
    return ::_mm_set_pi16(__w3, __w2, __w1, __w0);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_setr_pi8(char __b0, char __b1, char __b2, char __b3, char __b4, char __b5, char __b6, char __b7)
  {
    return ::_mm_set_pi8(__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_set1_pi32(int __i)
  {
    return ::_mm_set_pi32(__i, __i);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_set1_pi16(short int __w)
  {
    return ::_mm_set_pi16(__w, __w, __w, __w);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_set1_pi8(char __b)
  {
    return ::_mm_set_pi8(__b, __b, __b, __b, __b, __b, __b, __b);
  }
}
extern "C"
{
  static inline void *_mm_malloc(::size_t __size, ::size_t __alignment)
  {
    void *__ptr;
    if (__alignment == 1)
      {
        return ::malloc(__size);
      }
    if (__alignment == 2 || (sizeof(void *) == 8 && __alignment == 4))
      {
        __alignment = sizeof(void *);
      }
    if (::posix_memalign(&__ptr, __alignment, __size) == 0)
      {
        return __ptr;
      }
    else
      {
        return 0L;
      }
  }
}
extern "C"
{
  static inline void _mm_free(void *__ptr)
  {
    ::free(__ptr);
  }
}
enum _mm_hint
{
  _MM_HINT_ET0 = 7,
  _MM_HINT_ET1 = 6,
  _MM_HINT_T0 = 3,
  _MM_HINT_T1 = 2,
  _MM_HINT_T2 = 1,
  _MM_HINT_NTA = 0
};
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_prefetch(const void *__P, ::_mm_hint __I)
  {
    __builtin_prefetch(__P, (__I & 4) >> 2, __I & 3);
  }
}
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) float __m128;
typedef __attribute__((aligned(1))) __attribute__((vector_size(16))) __attribute__((__may_alias__)) float __m128_u;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) float __v4sf;
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_undefined_ps()
  {
    ::__m128 __Y(__Y);
    return __Y;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_setzero_ps()
  {
    return (::__m128){0.000000000000000000000000e+00f, 0.000000000000000000000000e+00f, 0.000000000000000000000000e+00f, 0.000000000000000000000000e+00f};
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_add_ss(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_addss((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_sub_ss(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_subss((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_mul_ss(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_mulss((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_div_ss(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_divss((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_sqrt_ss(::__m128 __A)
  {
    return (::__m128)__builtin_ia32_sqrtss((::__v4sf)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_rcp_ss(::__m128 __A)
  {
    return (::__m128)__builtin_ia32_rcpss((::__v4sf)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_rsqrt_ss(::__m128 __A)
  {
    return (::__m128)__builtin_ia32_rsqrtss((::__v4sf)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_min_ss(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_minss((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_max_ss(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_maxss((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_add_ps(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)((::__v4sf)__A + (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_sub_ps(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)((::__v4sf)__A - (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_mul_ps(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)((::__v4sf)__A * (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_div_ps(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)((::__v4sf)__A / (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_sqrt_ps(::__m128 __A)
  {
    return (::__m128)__builtin_ia32_sqrtps((::__v4sf)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_rcp_ps(::__m128 __A)
  {
    return (::__m128)__builtin_ia32_rcpps((::__v4sf)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_rsqrt_ps(::__m128 __A)
  {
    return (::__m128)__builtin_ia32_rsqrtps((::__v4sf)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_min_ps(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_minps((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_max_ps(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_maxps((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_and_ps(::__m128 __A, ::__m128 __B)
  {
    return __builtin_ia32_andps(__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_andnot_ps(::__m128 __A, ::__m128 __B)
  {
    return __builtin_ia32_andnps(__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_or_ps(::__m128 __A, ::__m128 __B)
  {
    return __builtin_ia32_orps(__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_xor_ps(::__m128 __A, ::__m128 __B)
  {
    return __builtin_ia32_xorps(__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpeq_ss(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_cmpeqss((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmplt_ss(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_cmpltss((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmple_ss(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_cmpless((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpgt_ss(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_movss((::__v4sf)__A, (::__v4sf)__builtin_ia32_cmpltss((::__v4sf)__B, (::__v4sf)__A));
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpge_ss(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_movss((::__v4sf)__A, (::__v4sf)__builtin_ia32_cmpless((::__v4sf)__B, (::__v4sf)__A));
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpneq_ss(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_cmpneqss((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpnlt_ss(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_cmpnltss((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpnle_ss(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_cmpnless((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpngt_ss(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_movss((::__v4sf)__A, (::__v4sf)__builtin_ia32_cmpnltss((::__v4sf)__B, (::__v4sf)__A));
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpnge_ss(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_movss((::__v4sf)__A, (::__v4sf)__builtin_ia32_cmpnless((::__v4sf)__B, (::__v4sf)__A));
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpord_ss(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_cmpordss((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpunord_ss(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_cmpunordss((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpeq_ps(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_cmpeqps((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmplt_ps(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_cmpltps((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmple_ps(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_cmpleps((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpgt_ps(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_cmpgtps((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpge_ps(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_cmpgeps((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpneq_ps(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_cmpneqps((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpnlt_ps(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_cmpnltps((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpnle_ps(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_cmpnleps((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpngt_ps(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_cmpngtps((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpnge_ps(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_cmpngeps((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpord_ps(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_cmpordps((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpunord_ps(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_cmpunordps((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_comieq_ss(::__m128 __A, ::__m128 __B)
  {
    return __builtin_ia32_comieq((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_comilt_ss(::__m128 __A, ::__m128 __B)
  {
    return __builtin_ia32_comilt((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_comile_ss(::__m128 __A, ::__m128 __B)
  {
    return __builtin_ia32_comile((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_comigt_ss(::__m128 __A, ::__m128 __B)
  {
    return __builtin_ia32_comigt((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_comige_ss(::__m128 __A, ::__m128 __B)
  {
    return __builtin_ia32_comige((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_comineq_ss(::__m128 __A, ::__m128 __B)
  {
    return __builtin_ia32_comineq((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_ucomieq_ss(::__m128 __A, ::__m128 __B)
  {
    return __builtin_ia32_ucomieq((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_ucomilt_ss(::__m128 __A, ::__m128 __B)
  {
    return __builtin_ia32_ucomilt((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_ucomile_ss(::__m128 __A, ::__m128 __B)
  {
    return __builtin_ia32_ucomile((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_ucomigt_ss(::__m128 __A, ::__m128 __B)
  {
    return __builtin_ia32_ucomigt((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_ucomige_ss(::__m128 __A, ::__m128 __B)
  {
    return __builtin_ia32_ucomige((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_ucomineq_ss(::__m128 __A, ::__m128 __B)
  {
    return __builtin_ia32_ucomineq((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_cvtss_si32(::__m128 __A)
  {
    return __builtin_ia32_cvtss2si((::__v4sf)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_cvt_ss2si(::__m128 __A)
  {
    return ::_mm_cvtss_si32(__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _mm_cvtss_si64(::__m128 __A)
  {
    return __builtin_ia32_cvtss2si64((::__v4sf)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _mm_cvtss_si64x(::__m128 __A)
  {
    return __builtin_ia32_cvtss2si64((::__v4sf)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cvtps_pi32(::__m128 __A)
  {
    return (::__m64)__builtin_ia32_cvtps2pi((::__v4sf)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cvt_ps2pi(::__m128 __A)
  {
    return ::_mm_cvtps_pi32(__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_cvttss_si32(::__m128 __A)
  {
    return __builtin_ia32_cvttss2si((::__v4sf)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_cvtt_ss2si(::__m128 __A)
  {
    return ::_mm_cvttss_si32(__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _mm_cvttss_si64(::__m128 __A)
  {
    return __builtin_ia32_cvttss2si64((::__v4sf)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _mm_cvttss_si64x(::__m128 __A)
  {
    return __builtin_ia32_cvttss2si64((::__v4sf)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cvttps_pi32(::__m128 __A)
  {
    return (::__m64)__builtin_ia32_cvttps2pi((::__v4sf)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cvtt_ps2pi(::__m128 __A)
  {
    return ::_mm_cvttps_pi32(__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvtsi32_ss(::__m128 __A, int __B)
  {
    return (::__m128)__builtin_ia32_cvtsi2ss((::__v4sf)__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvt_si2ss(::__m128 __A, int __B)
  {
    return ::_mm_cvtsi32_ss(__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvtsi64_ss(::__m128 __A, long long int __B)
  {
    return (::__m128)__builtin_ia32_cvtsi642ss((::__v4sf)__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvtsi64x_ss(::__m128 __A, long long int __B)
  {
    return (::__m128)__builtin_ia32_cvtsi642ss((::__v4sf)__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvtpi32_ps(::__m128 __A, ::__m64 __B)
  {
    return (::__m128)__builtin_ia32_cvtpi2ps((::__v4sf)__A, (::__v2si)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvt_pi2ps(::__m128 __A, ::__m64 __B)
  {
    return ::_mm_cvtpi32_ps(__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvtpi16_ps(::__m64 __A)
  {
    ::__v4hi __sign;
    ::__v2si __hisi;
    ::__v2si __losi;
    ::__v4sf __zero;
    ::__v4sf __ra;
    ::__v4sf __rb;
    __sign = __builtin_ia32_pcmpgtw((::__v4hi)0LL, (::__v4hi)__A);
    __losi = (::__v2si)__builtin_ia32_punpcklwd((::__v4hi)__A, __sign);
    __hisi = (::__v2si)__builtin_ia32_punpckhwd((::__v4hi)__A, __sign);
    __zero = (::__v4sf)::_mm_setzero_ps();
    __ra = __builtin_ia32_cvtpi2ps(__zero, __losi);
    __rb = __builtin_ia32_cvtpi2ps(__ra, __hisi);
    return (::__m128)__builtin_ia32_movlhps(__ra, __rb);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvtpu16_ps(::__m64 __A)
  {
    ::__v2si __hisi;
    ::__v2si __losi;
    ::__v4sf __zero;
    ::__v4sf __ra;
    ::__v4sf __rb;
    __losi = (::__v2si)__builtin_ia32_punpcklwd((::__v4hi)__A, (::__v4hi)0LL);
    __hisi = (::__v2si)__builtin_ia32_punpckhwd((::__v4hi)__A, (::__v4hi)0LL);
    __zero = (::__v4sf)::_mm_setzero_ps();
    __ra = __builtin_ia32_cvtpi2ps(__zero, __losi);
    __rb = __builtin_ia32_cvtpi2ps(__ra, __hisi);
    return (::__m128)__builtin_ia32_movlhps(__ra, __rb);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvtpi8_ps(::__m64 __A)
  {
    ::__v8qi __sign;
    __sign = __builtin_ia32_pcmpgtb((::__v8qi)0LL, (::__v8qi)__A);
    __A = (::__m64)__builtin_ia32_punpcklbw((::__v8qi)__A, __sign);
    return ::_mm_cvtpi16_ps(__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvtpu8_ps(::__m64 __A)
  {
    __A = (::__m64)__builtin_ia32_punpcklbw((::__v8qi)__A, (::__v8qi)0LL);
    return ::_mm_cvtpu16_ps(__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvtpi32x2_ps(::__m64 __A, ::__m64 __B)
  {
    ::__v4sf __zero((::__v4sf)::_mm_setzero_ps());
    ::__v4sf __sfa(__builtin_ia32_cvtpi2ps(__zero, (::__v2si)__A));
    ::__v4sf __sfb(__builtin_ia32_cvtpi2ps(__sfa, (::__v2si)__B));
    return (::__m128)__builtin_ia32_movlhps(__sfa, __sfb);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cvtps_pi16(::__m128 __A)
  {
    ::__v4sf __hisf((::__v4sf)__A);
    ::__v4sf __losf(__builtin_ia32_movhlps(__hisf, __hisf));
    ::__v2si __hisi(__builtin_ia32_cvtps2pi(__hisf));
    ::__v2si __losi(__builtin_ia32_cvtps2pi(__losf));
    return (::__m64)__builtin_ia32_packssdw(__hisi, __losi);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cvtps_pi8(::__m128 __A)
  {
    ::__v4hi __tmp((::__v4hi)::_mm_cvtps_pi16(__A));
    return (::__m64)__builtin_ia32_packsswb(__tmp, (::__v4hi)0LL);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_shuffle_ps(::__m128 __A, ::__m128 __B, const int __mask)
  {
    return (::__m128)__builtin_ia32_shufps((::__v4sf)__A, (::__v4sf)__B, __mask);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_unpackhi_ps(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_unpckhps((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_unpacklo_ps(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_unpcklps((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_loadh_pi(::__m128 __A, const ::__m64 *__P)
  {
    return (::__m128)__builtin_ia32_loadhps((::__v4sf)__A, (const ::__v2sf *)__P);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_storeh_pi(::__m64 *__P, ::__m128 __A)
  {
    __builtin_ia32_storehps((::__v2sf *)__P, (::__v4sf)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_movehl_ps(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_movhlps((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_movelh_ps(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_movlhps((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_loadl_pi(::__m128 __A, const ::__m64 *__P)
  {
    return (::__m128)__builtin_ia32_loadlps((::__v4sf)__A, (const ::__v2sf *)__P);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_storel_pi(::__m64 *__P, ::__m128 __A)
  {
    __builtin_ia32_storelps((::__v2sf *)__P, (::__v4sf)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_movemask_ps(::__m128 __A)
  {
    return __builtin_ia32_movmskps((::__v4sf)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) unsigned int _mm_getcsr()
  {
    return __builtin_ia32_stmxcsr();
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) unsigned int _MM_GET_EXCEPTION_STATE()
  {
    return ::_mm_getcsr() & 63;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) unsigned int _MM_GET_EXCEPTION_MASK()
  {
    return ::_mm_getcsr() & 8064;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) unsigned int _MM_GET_ROUNDING_MODE()
  {
    return ::_mm_getcsr() & 24576;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) unsigned int _MM_GET_FLUSH_ZERO_MODE()
  {
    return ::_mm_getcsr() & 32768;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_setcsr(unsigned int __I)
  {
    __builtin_ia32_ldmxcsr(__I);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _MM_SET_EXCEPTION_STATE(unsigned int __mask)
  {
    ::_mm_setcsr((::_mm_getcsr() & ~63) | __mask);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _MM_SET_EXCEPTION_MASK(unsigned int __mask)
  {
    ::_mm_setcsr((::_mm_getcsr() & ~8064) | __mask);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _MM_SET_ROUNDING_MODE(unsigned int __mode)
  {
    ::_mm_setcsr((::_mm_getcsr() & ~24576) | __mode);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _MM_SET_FLUSH_ZERO_MODE(unsigned int __mode)
  {
    ::_mm_setcsr((::_mm_getcsr() & ~32768) | __mode);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_set_ss(float __F)
  {
    return (::__m128)(::__v4sf){__F, 0.000000000000000000000000e+00f, 0.000000000000000000000000e+00f, 0.000000000000000000000000e+00f};
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_set1_ps(float __F)
  {
    return (::__m128)(::__v4sf){__F, __F, __F, __F};
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_set_ps1(float __F)
  {
    return ::_mm_set1_ps(__F);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_load_ss(const float *__P)
  {
    return ::_mm_set_ss(*__P);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_load1_ps(const float *__P)
  {
    return ::_mm_set1_ps(*__P);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_load_ps1(const float *__P)
  {
    return ::_mm_load1_ps(__P);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_load_ps(const float *__P)
  {
    return *((::__m128 *)__P);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_loadu_ps(const float *__P)
  {
    return *((::__m128_u *)__P);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_loadr_ps(const float *__P)
  {
    ::__v4sf __tmp(*((::__v4sf *)__P));
    return (::__m128)__builtin_ia32_shufps(__tmp, __tmp, ((0 << 6 | 1 << 4) | 2 << 2) | 3);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_set_ps(const float __Z, const float __Y, const float __X, const float __W)
  {
    return (::__m128)(::__v4sf){__W, __X, __Y, __Z};
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_setr_ps(float __Z, float __Y, float __X, float __W)
  {
    return (::__m128)(::__v4sf){__Z, __Y, __X, __W};
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_store_ss(float *__P, ::__m128 __A)
  {
    *__P = ((::__v4sf)__A)[0];
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) float _mm_cvtss_f32(::__m128 __A)
  {
    return ((::__v4sf)__A)[0];
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_store_ps(float *__P, ::__m128 __A)
  {
    *((::__m128 *)__P) = __A;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_storeu_ps(float *__P, ::__m128 __A)
  {
    *((::__m128_u *)__P) = __A;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_store1_ps(float *__P, ::__m128 __A)
  {
    ::__v4sf __va((::__v4sf)__A);
    ::__v4sf __tmp(__builtin_ia32_shufps(__va, __va, ((0 << 6 | 0 << 4) | 0 << 2) | 0));
    ::_mm_storeu_ps(__P, __tmp);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_store_ps1(float *__P, ::__m128 __A)
  {
    ::_mm_store1_ps(__P, __A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_storer_ps(float *__P, ::__m128 __A)
  {
    ::__v4sf __va((::__v4sf)__A);
    ::__v4sf __tmp(__builtin_ia32_shufps(__va, __va, ((0 << 6 | 1 << 4) | 2 << 2) | 3));
    ::_mm_store_ps(__P, __tmp);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_move_ss(::__m128 __A, ::__m128 __B)
  {
    return (::__m128)__builtin_ia32_movss((::__v4sf)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_extract_pi16(const ::__m64 __A, const int __N)
  {
    return __builtin_ia32_vec_ext_v4hi((::__v4hi)__A, __N);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _m_pextrw(const ::__m64 __A, const int __N)
  {
    return ::_mm_extract_pi16(__A, __N);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_insert_pi16(const ::__m64 __A, const int __D, const int __N)
  {
    return (::__m64)__builtin_ia32_vec_set_v4hi((::__v4hi)__A, __D, __N);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pinsrw(const ::__m64 __A, const int __D, const int __N)
  {
    return ::_mm_insert_pi16(__A, __D, __N);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_max_pi16(::__m64 __A, ::__m64 __B)
  {
    return (::__m64)__builtin_ia32_pmaxsw((::__v4hi)__A, (::__v4hi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pmaxsw(::__m64 __A, ::__m64 __B)
  {
    return ::_mm_max_pi16(__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_max_pu8(::__m64 __A, ::__m64 __B)
  {
    return (::__m64)__builtin_ia32_pmaxub((::__v8qi)__A, (::__v8qi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pmaxub(::__m64 __A, ::__m64 __B)
  {
    return ::_mm_max_pu8(__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_min_pi16(::__m64 __A, ::__m64 __B)
  {
    return (::__m64)__builtin_ia32_pminsw((::__v4hi)__A, (::__v4hi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pminsw(::__m64 __A, ::__m64 __B)
  {
    return ::_mm_min_pi16(__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_min_pu8(::__m64 __A, ::__m64 __B)
  {
    return (::__m64)__builtin_ia32_pminub((::__v8qi)__A, (::__v8qi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pminub(::__m64 __A, ::__m64 __B)
  {
    return ::_mm_min_pu8(__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_movemask_pi8(::__m64 __A)
  {
    return __builtin_ia32_pmovmskb((::__v8qi)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _m_pmovmskb(::__m64 __A)
  {
    return ::_mm_movemask_pi8(__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_mulhi_pu16(::__m64 __A, ::__m64 __B)
  {
    return (::__m64)__builtin_ia32_pmulhuw((::__v4hi)__A, (::__v4hi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pmulhuw(::__m64 __A, ::__m64 __B)
  {
    return ::_mm_mulhi_pu16(__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_shuffle_pi16(::__m64 __A, const int __N)
  {
    return (::__m64)__builtin_ia32_pshufw((::__v4hi)__A, __N);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pshufw(::__m64 __A, const int __N)
  {
    return ::_mm_shuffle_pi16(__A, __N);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_maskmove_si64(::__m64 __A, ::__m64 __N, char *__P)
  {
    __builtin_ia32_maskmovq((::__v8qi)__A, (::__v8qi)__N, __P);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _m_maskmovq(::__m64 __A, ::__m64 __N, char *__P)
  {
    ::_mm_maskmove_si64(__A, __N, __P);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_avg_pu8(::__m64 __A, ::__m64 __B)
  {
    return (::__m64)__builtin_ia32_pavgb((::__v8qi)__A, (::__v8qi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pavgb(::__m64 __A, ::__m64 __B)
  {
    return ::_mm_avg_pu8(__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_avg_pu16(::__m64 __A, ::__m64 __B)
  {
    return (::__m64)__builtin_ia32_pavgw((::__v4hi)__A, (::__v4hi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pavgw(::__m64 __A, ::__m64 __B)
  {
    return ::_mm_avg_pu16(__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_sad_pu8(::__m64 __A, ::__m64 __B)
  {
    return (::__m64)__builtin_ia32_psadbw((::__v8qi)__A, (::__v8qi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psadbw(::__m64 __A, ::__m64 __B)
  {
    return ::_mm_sad_pu8(__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_stream_pi(::__m64 *__P, ::__m64 __A)
  {
    __builtin_ia32_movntq((unsigned long long int *)__P, (unsigned long long int)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_stream_ps(float *__P, ::__m128 __A)
  {
    __builtin_ia32_movntps(__P, (::__v4sf)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_sfence()
  {
    __builtin_ia32_sfence();
  }
}
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) double __v2df;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) long long int __v2di;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) unsigned long long int __v2du;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) int __v4si;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) unsigned int __v4su;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) short int __v8hi;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) unsigned short int __v8hu;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) char __v16qi;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) signed char __v16qs;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) unsigned char __v16qu;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) long long int __m128i;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) double __m128d;
typedef __attribute__((aligned(1))) __attribute__((vector_size(16))) __attribute__((__may_alias__)) long long int __m128i_u;
typedef __attribute__((aligned(1))) __attribute__((vector_size(16))) __attribute__((__may_alias__)) double __m128d_u;
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_set_sd(double __F)
  {
    return (::__m128d){__F, 0.00000000000000000000000000000000000000000000000000000e+00};
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_set1_pd(double __F)
  {
    return (::__m128d){__F, __F};
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_set_pd1(double __F)
  {
    return ::_mm_set1_pd(__F);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_set_pd(double __W, double __X)
  {
    return (::__m128d){__X, __W};
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_setr_pd(double __W, double __X)
  {
    return (::__m128d){__W, __X};
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_undefined_pd()
  {
    ::__m128d __Y(__Y);
    return __Y;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_setzero_pd()
  {
    return (::__m128d){0.00000000000000000000000000000000000000000000000000000e+00, 0.00000000000000000000000000000000000000000000000000000e+00};
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_move_sd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_movsd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_load_pd(const double *__P)
  {
    return *((::__m128d *)__P);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_loadu_pd(const double *__P)
  {
    return *((::__m128d_u *)__P);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_load1_pd(const double *__P)
  {
    return ::_mm_set1_pd(*__P);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_load_sd(const double *__P)
  {
    return ::_mm_set_sd(*__P);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_load_pd1(const double *__P)
  {
    return ::_mm_load1_pd(__P);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_loadr_pd(const double *__P)
  {
    ::__m128d __tmp(::_mm_load_pd(__P));
    return __builtin_ia32_shufpd(__tmp, __tmp, 0 << 1 | 1);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_store_pd(double *__P, ::__m128d __A)
  {
    *((::__m128d *)__P) = __A;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_storeu_pd(double *__P, ::__m128d __A)
  {
    *((::__m128d_u *)__P) = __A;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_store_sd(double *__P, ::__m128d __A)
  {
    *__P = ((::__v2df)__A)[0];
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) double _mm_cvtsd_f64(::__m128d __A)
  {
    return ((::__v2df)__A)[0];
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_storel_pd(double *__P, ::__m128d __A)
  {
    ::_mm_store_sd(__P, __A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_storeh_pd(double *__P, ::__m128d __A)
  {
    *__P = ((::__v2df)__A)[1];
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_store1_pd(double *__P, ::__m128d __A)
  {
    ::_mm_store_pd(__P, __builtin_ia32_shufpd(__A, __A, 0 << 1 | 0));
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_store_pd1(double *__P, ::__m128d __A)
  {
    ::_mm_store1_pd(__P, __A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_storer_pd(double *__P, ::__m128d __A)
  {
    ::_mm_store_pd(__P, __builtin_ia32_shufpd(__A, __A, 0 << 1 | 1));
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_cvtsi128_si32(::__m128i __A)
  {
    return __builtin_ia32_vec_ext_v4si((::__v4si)__A, 0);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _mm_cvtsi128_si64(::__m128i __A)
  {
    return ((::__v2di)__A)[0];
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _mm_cvtsi128_si64x(::__m128i __A)
  {
    return ((::__v2di)__A)[0];
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_add_pd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)((::__v2df)__A + (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_add_sd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_addsd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_sub_pd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)((::__v2df)__A - (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_sub_sd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_subsd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_mul_pd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)((::__v2df)__A * (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_mul_sd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_mulsd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_div_pd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)((::__v2df)__A / (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_div_sd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_divsd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_sqrt_pd(::__m128d __A)
  {
    return (::__m128d)__builtin_ia32_sqrtpd((::__v2df)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_sqrt_sd(::__m128d __A, ::__m128d __B)
  {
    ::__v2df __tmp(__builtin_ia32_movsd((::__v2df)__A, (::__v2df)__B));
    return (::__m128d)__builtin_ia32_sqrtsd((::__v2df)__tmp);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_min_pd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_minpd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_min_sd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_minsd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_max_pd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_maxpd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_max_sd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_maxsd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_and_pd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_andpd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_andnot_pd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_andnpd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_or_pd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_orpd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_xor_pd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_xorpd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpeq_pd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_cmpeqpd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmplt_pd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_cmpltpd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmple_pd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_cmplepd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpgt_pd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_cmpgtpd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpge_pd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_cmpgepd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpneq_pd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_cmpneqpd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpnlt_pd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_cmpnltpd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpnle_pd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_cmpnlepd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpngt_pd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_cmpngtpd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpnge_pd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_cmpngepd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpord_pd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_cmpordpd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpunord_pd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_cmpunordpd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpeq_sd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_cmpeqsd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmplt_sd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_cmpltsd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmple_sd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_cmplesd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpgt_sd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_movsd((::__v2df)__A, (::__v2df)__builtin_ia32_cmpltsd((::__v2df)__B, (::__v2df)__A));
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpge_sd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_movsd((::__v2df)__A, (::__v2df)__builtin_ia32_cmplesd((::__v2df)__B, (::__v2df)__A));
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpneq_sd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_cmpneqsd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpnlt_sd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_cmpnltsd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpnle_sd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_cmpnlesd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpngt_sd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_movsd((::__v2df)__A, (::__v2df)__builtin_ia32_cmpnltsd((::__v2df)__B, (::__v2df)__A));
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpnge_sd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_movsd((::__v2df)__A, (::__v2df)__builtin_ia32_cmpnlesd((::__v2df)__B, (::__v2df)__A));
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpord_sd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_cmpordsd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpunord_sd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_cmpunordsd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_comieq_sd(::__m128d __A, ::__m128d __B)
  {
    return __builtin_ia32_comisdeq((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_comilt_sd(::__m128d __A, ::__m128d __B)
  {
    return __builtin_ia32_comisdlt((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_comile_sd(::__m128d __A, ::__m128d __B)
  {
    return __builtin_ia32_comisdle((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_comigt_sd(::__m128d __A, ::__m128d __B)
  {
    return __builtin_ia32_comisdgt((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_comige_sd(::__m128d __A, ::__m128d __B)
  {
    return __builtin_ia32_comisdge((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_comineq_sd(::__m128d __A, ::__m128d __B)
  {
    return __builtin_ia32_comisdneq((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_ucomieq_sd(::__m128d __A, ::__m128d __B)
  {
    return __builtin_ia32_ucomisdeq((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_ucomilt_sd(::__m128d __A, ::__m128d __B)
  {
    return __builtin_ia32_ucomisdlt((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_ucomile_sd(::__m128d __A, ::__m128d __B)
  {
    return __builtin_ia32_ucomisdle((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_ucomigt_sd(::__m128d __A, ::__m128d __B)
  {
    return __builtin_ia32_ucomisdgt((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_ucomige_sd(::__m128d __A, ::__m128d __B)
  {
    return __builtin_ia32_ucomisdge((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_ucomineq_sd(::__m128d __A, ::__m128d __B)
  {
    return __builtin_ia32_ucomisdneq((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_set_epi64x(long long int __q1, long long int __q0)
  {
    return (::__m128i)(::__v2di){__q0, __q1};
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_set_epi64(::__m64 __q1, ::__m64 __q0)
  {
    return ::_mm_set_epi64x((long long int)__q1, (long long int)__q0);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_set_epi32(int __q3, int __q2, int __q1, int __q0)
  {
    return (::__m128i)(::__v4si){__q0, __q1, __q2, __q3};
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_set_epi16(short int __q7, short int __q6, short int __q5, short int __q4, short int __q3, short int __q2, short int __q1, short int __q0)
  {
    return (::__m128i)(::__v8hi){__q0, __q1, __q2, __q3, __q4, __q5, __q6, __q7};
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_set_epi8(char __q15, char __q14, char __q13, char __q12, char __q11, char __q10, char __q09, char __q08, char __q07, char __q06, char __q05, char __q04, char __q03, char __q02, char __q01, char __q00)
  {
    return (::__m128i)(::__v16qi){__q00, __q01, __q02, __q03, __q04, __q05, __q06, __q07, __q08, __q09, __q10, __q11, __q12, __q13, __q14, __q15};
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_set1_epi64x(long long int __A)
  {
    return ::_mm_set_epi64x(__A, __A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_set1_epi64(::__m64 __A)
  {
    return ::_mm_set_epi64(__A, __A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_set1_epi32(int __A)
  {
    return ::_mm_set_epi32(__A, __A, __A, __A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_set1_epi16(short int __A)
  {
    return ::_mm_set_epi16(__A, __A, __A, __A, __A, __A, __A, __A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_set1_epi8(char __A)
  {
    return ::_mm_set_epi8(__A, __A, __A, __A, __A, __A, __A, __A, __A, __A, __A, __A, __A, __A, __A, __A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_setr_epi64(::__m64 __q0, ::__m64 __q1)
  {
    return ::_mm_set_epi64(__q1, __q0);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_setr_epi32(int __q0, int __q1, int __q2, int __q3)
  {
    return ::_mm_set_epi32(__q3, __q2, __q1, __q0);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_setr_epi16(short int __q0, short int __q1, short int __q2, short int __q3, short int __q4, short int __q5, short int __q6, short int __q7)
  {
    return ::_mm_set_epi16(__q7, __q6, __q5, __q4, __q3, __q2, __q1, __q0);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_setr_epi8(char __q00, char __q01, char __q02, char __q03, char __q04, char __q05, char __q06, char __q07, char __q08, char __q09, char __q10, char __q11, char __q12, char __q13, char __q14, char __q15)
  {
    return ::_mm_set_epi8(__q15, __q14, __q13, __q12, __q11, __q10, __q09, __q08, __q07, __q06, __q05, __q04, __q03, __q02, __q01, __q00);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_load_si128(const ::__m128i *__P)
  {
    return *__P;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_loadu_si128(const ::__m128i_u *__P)
  {
    return *__P;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_loadl_epi64(const ::__m128i_u *__P)
  {
    return ::_mm_set_epi64((::__m64)0LL, *((::__m64_u *)__P));
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_store_si128(::__m128i *__P, ::__m128i __B)
  {
    *__P = __B;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_storeu_si128(::__m128i_u *__P, ::__m128i __B)
  {
    *__P = __B;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_storel_epi64(::__m128i_u *__P, ::__m128i __B)
  {
    *((::__m64_u *)__P) = (::__m64)((::__v2di)__B)[0];
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_movepi64_pi64(::__m128i __B)
  {
    return (::__m64)((::__v2di)__B)[0];
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_movpi64_epi64(::__m64 __A)
  {
    return ::_mm_set_epi64((::__m64)0LL, __A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_move_epi64(::__m128i __A)
  {
    return (::__m128i)__builtin_ia32_movq128((::__v2di)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_undefined_si128()
  {
    ::__m128i __Y(__Y);
    return __Y;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_setzero_si128()
  {
    return (::__m128i)(::__v4si){0, 0, 0, 0};
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cvtepi32_pd(::__m128i __A)
  {
    return (::__m128d)__builtin_ia32_cvtdq2pd((::__v4si)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvtepi32_ps(::__m128i __A)
  {
    return (::__m128)__builtin_ia32_cvtdq2ps((::__v4si)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cvtpd_epi32(::__m128d __A)
  {
    return (::__m128i)__builtin_ia32_cvtpd2dq((::__v2df)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cvtpd_pi32(::__m128d __A)
  {
    return (::__m64)__builtin_ia32_cvtpd2pi((::__v2df)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvtpd_ps(::__m128d __A)
  {
    return (::__m128)__builtin_ia32_cvtpd2ps((::__v2df)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cvttpd_epi32(::__m128d __A)
  {
    return (::__m128i)__builtin_ia32_cvttpd2dq((::__v2df)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cvttpd_pi32(::__m128d __A)
  {
    return (::__m64)__builtin_ia32_cvttpd2pi((::__v2df)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cvtpi32_pd(::__m64 __A)
  {
    return (::__m128d)__builtin_ia32_cvtpi2pd((::__v2si)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cvtps_epi32(::__m128 __A)
  {
    return (::__m128i)__builtin_ia32_cvtps2dq((::__v4sf)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cvttps_epi32(::__m128 __A)
  {
    return (::__m128i)__builtin_ia32_cvttps2dq((::__v4sf)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cvtps_pd(::__m128 __A)
  {
    return (::__m128d)__builtin_ia32_cvtps2pd((::__v4sf)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_cvtsd_si32(::__m128d __A)
  {
    return __builtin_ia32_cvtsd2si((::__v2df)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _mm_cvtsd_si64(::__m128d __A)
  {
    return __builtin_ia32_cvtsd2si64((::__v2df)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _mm_cvtsd_si64x(::__m128d __A)
  {
    return __builtin_ia32_cvtsd2si64((::__v2df)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_cvttsd_si32(::__m128d __A)
  {
    return __builtin_ia32_cvttsd2si((::__v2df)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _mm_cvttsd_si64(::__m128d __A)
  {
    return __builtin_ia32_cvttsd2si64((::__v2df)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _mm_cvttsd_si64x(::__m128d __A)
  {
    return __builtin_ia32_cvttsd2si64((::__v2df)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvtsd_ss(::__m128 __A, ::__m128d __B)
  {
    return (::__m128)__builtin_ia32_cvtsd2ss((::__v4sf)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cvtsi32_sd(::__m128d __A, int __B)
  {
    return (::__m128d)__builtin_ia32_cvtsi2sd((::__v2df)__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cvtsi64_sd(::__m128d __A, long long int __B)
  {
    return (::__m128d)__builtin_ia32_cvtsi642sd((::__v2df)__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cvtsi64x_sd(::__m128d __A, long long int __B)
  {
    return (::__m128d)__builtin_ia32_cvtsi642sd((::__v2df)__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cvtss_sd(::__m128d __A, ::__m128 __B)
  {
    return (::__m128d)__builtin_ia32_cvtss2sd((::__v2df)__A, (::__v4sf)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_shuffle_pd(::__m128d __A, ::__m128d __B, const int __mask)
  {
    return (::__m128d)__builtin_ia32_shufpd((::__v2df)__A, (::__v2df)__B, __mask);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_unpackhi_pd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_unpckhpd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_unpacklo_pd(::__m128d __A, ::__m128d __B)
  {
    return (::__m128d)__builtin_ia32_unpcklpd((::__v2df)__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_loadh_pd(::__m128d __A, const double *__B)
  {
    return (::__m128d)__builtin_ia32_loadhpd((::__v2df)__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_loadl_pd(::__m128d __A, const double *__B)
  {
    return (::__m128d)__builtin_ia32_loadlpd((::__v2df)__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_movemask_pd(::__m128d __A)
  {
    return __builtin_ia32_movmskpd((::__v2df)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_packs_epi16(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_packsswb128((::__v8hi)__A, (::__v8hi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_packs_epi32(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_packssdw128((::__v4si)__A, (::__v4si)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_packus_epi16(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_packuswb128((::__v8hi)__A, (::__v8hi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_unpackhi_epi8(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_punpckhbw128((::__v16qi)__A, (::__v16qi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_unpackhi_epi16(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_punpckhwd128((::__v8hi)__A, (::__v8hi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_unpackhi_epi32(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_punpckhdq128((::__v4si)__A, (::__v4si)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_unpackhi_epi64(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_punpckhqdq128((::__v2di)__A, (::__v2di)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_unpacklo_epi8(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_punpcklbw128((::__v16qi)__A, (::__v16qi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_unpacklo_epi16(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_punpcklwd128((::__v8hi)__A, (::__v8hi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_unpacklo_epi32(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_punpckldq128((::__v4si)__A, (::__v4si)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_unpacklo_epi64(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_punpcklqdq128((::__v2di)__A, (::__v2di)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_add_epi8(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)((::__v16qu)__A + (::__v16qu)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_add_epi16(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)((::__v8hu)__A + (::__v8hu)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_add_epi32(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)((::__v4su)__A + (::__v4su)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_add_epi64(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)((::__v2du)__A + (::__v2du)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_adds_epi8(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_paddsb128((::__v16qi)__A, (::__v16qi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_adds_epi16(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_paddsw128((::__v8hi)__A, (::__v8hi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_adds_epu8(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_paddusb128((::__v16qi)__A, (::__v16qi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_adds_epu16(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_paddusw128((::__v8hi)__A, (::__v8hi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_sub_epi8(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)((::__v16qu)__A - (::__v16qu)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_sub_epi16(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)((::__v8hu)__A - (::__v8hu)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_sub_epi32(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)((::__v4su)__A - (::__v4su)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_sub_epi64(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)((::__v2du)__A - (::__v2du)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_subs_epi8(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_psubsb128((::__v16qi)__A, (::__v16qi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_subs_epi16(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_psubsw128((::__v8hi)__A, (::__v8hi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_subs_epu8(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_psubusb128((::__v16qi)__A, (::__v16qi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_subs_epu16(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_psubusw128((::__v8hi)__A, (::__v8hi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_madd_epi16(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_pmaddwd128((::__v8hi)__A, (::__v8hi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_mulhi_epi16(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_pmulhw128((::__v8hi)__A, (::__v8hi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_mullo_epi16(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)((::__v8hu)__A * (::__v8hu)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_mul_su32(::__m64 __A, ::__m64 __B)
  {
    return (::__m64)__builtin_ia32_pmuludq((::__v2si)__A, (::__v2si)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_mul_epu32(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_pmuludq128((::__v4si)__A, (::__v4si)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_slli_epi16(::__m128i __A, int __B)
  {
    return (::__m128i)__builtin_ia32_psllwi128((::__v8hi)__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_slli_epi32(::__m128i __A, int __B)
  {
    return (::__m128i)__builtin_ia32_pslldi128((::__v4si)__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_slli_epi64(::__m128i __A, int __B)
  {
    return (::__m128i)__builtin_ia32_psllqi128((::__v2di)__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_srai_epi16(::__m128i __A, int __B)
  {
    return (::__m128i)__builtin_ia32_psrawi128((::__v8hi)__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_srai_epi32(::__m128i __A, int __B)
  {
    return (::__m128i)__builtin_ia32_psradi128((::__v4si)__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_bsrli_si128(::__m128i __A, const int __N)
  {
    return (::__m128i)__builtin_ia32_psrldqi128(__A, __N * 8);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_bslli_si128(::__m128i __A, const int __N)
  {
    return (::__m128i)__builtin_ia32_pslldqi128(__A, __N * 8);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_srli_si128(::__m128i __A, const int __N)
  {
    return (::__m128i)__builtin_ia32_psrldqi128(__A, __N * 8);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_slli_si128(::__m128i __A, const int __N)
  {
    return (::__m128i)__builtin_ia32_pslldqi128(__A, __N * 8);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_srli_epi16(::__m128i __A, int __B)
  {
    return (::__m128i)__builtin_ia32_psrlwi128((::__v8hi)__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_srli_epi32(::__m128i __A, int __B)
  {
    return (::__m128i)__builtin_ia32_psrldi128((::__v4si)__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_srli_epi64(::__m128i __A, int __B)
  {
    return (::__m128i)__builtin_ia32_psrlqi128((::__v2di)__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_sll_epi16(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_psllw128((::__v8hi)__A, (::__v8hi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_sll_epi32(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_pslld128((::__v4si)__A, (::__v4si)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_sll_epi64(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_psllq128((::__v2di)__A, (::__v2di)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_sra_epi16(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_psraw128((::__v8hi)__A, (::__v8hi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_sra_epi32(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_psrad128((::__v4si)__A, (::__v4si)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_srl_epi16(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_psrlw128((::__v8hi)__A, (::__v8hi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_srl_epi32(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_psrld128((::__v4si)__A, (::__v4si)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_srl_epi64(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_psrlq128((::__v2di)__A, (::__v2di)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_and_si128(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)((::__v2du)__A & (::__v2du)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_andnot_si128(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_pandn128((::__v2di)__A, (::__v2di)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_or_si128(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)((::__v2du)__A | (::__v2du)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_xor_si128(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)((::__v2du)__A ^ (::__v2du)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cmpeq_epi8(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)((::__v16qs)__A == (::__v16qs)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cmpeq_epi16(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)((::__v8hi)__A == (::__v8hi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cmpeq_epi32(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)((::__v4si)__A == (::__v4si)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cmplt_epi8(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)((::__v16qs)__A < (::__v16qs)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cmplt_epi16(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)((::__v8hi)__A < (::__v8hi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cmplt_epi32(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)((::__v4si)__A < (::__v4si)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cmpgt_epi8(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)((::__v16qs)__A > (::__v16qs)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cmpgt_epi16(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)((::__v8hi)__A > (::__v8hi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cmpgt_epi32(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)((::__v4si)__A > (::__v4si)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_extract_epi16(const ::__m128i __A, const int __N)
  {
    return (unsigned short int)__builtin_ia32_vec_ext_v8hi((::__v8hi)__A, __N);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_insert_epi16(const ::__m128i __A, const int __D, const int __N)
  {
    return (::__m128i)__builtin_ia32_vec_set_v8hi((::__v8hi)__A, __D, __N);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_max_epi16(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_pmaxsw128((::__v8hi)__A, (::__v8hi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_max_epu8(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_pmaxub128((::__v16qi)__A, (::__v16qi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_min_epi16(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_pminsw128((::__v8hi)__A, (::__v8hi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_min_epu8(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_pminub128((::__v16qi)__A, (::__v16qi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_movemask_epi8(::__m128i __A)
  {
    return __builtin_ia32_pmovmskb128((::__v16qi)__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_mulhi_epu16(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_pmulhuw128((::__v8hi)__A, (::__v8hi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_shufflehi_epi16(::__m128i __A, const int __mask)
  {
    return (::__m128i)__builtin_ia32_pshufhw((::__v8hi)__A, __mask);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_shufflelo_epi16(::__m128i __A, const int __mask)
  {
    return (::__m128i)__builtin_ia32_pshuflw((::__v8hi)__A, __mask);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_shuffle_epi32(::__m128i __A, const int __mask)
  {
    return (::__m128i)__builtin_ia32_pshufd((::__v4si)__A, __mask);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_maskmoveu_si128(::__m128i __A, ::__m128i __B, char *__C)
  {
    __builtin_ia32_maskmovdqu((::__v16qi)__A, (::__v16qi)__B, __C);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_avg_epu8(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_pavgb128((::__v16qi)__A, (::__v16qi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_avg_epu16(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_pavgw128((::__v8hi)__A, (::__v8hi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_sad_epu8(::__m128i __A, ::__m128i __B)
  {
    return (::__m128i)__builtin_ia32_psadbw128((::__v16qi)__A, (::__v16qi)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_stream_si32(int *__A, int __B)
  {
    __builtin_ia32_movnti(__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_stream_si64(long long int *__A, long long int __B)
  {
    __builtin_ia32_movnti64(__A, __B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_stream_si128(::__m128i *__A, ::__m128i __B)
  {
    __builtin_ia32_movntdq((::__m128i *)__A, (::__v2di)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_stream_pd(double *__A, ::__m128d __B)
  {
    __builtin_ia32_movntpd(__A, (::__v2df)__B);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_clflush(const void *__A)
  {
    __builtin_ia32_clflush(__A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_lfence()
  {
    __builtin_ia32_lfence();
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_mfence()
  {
    __builtin_ia32_mfence();
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cvtsi32_si128(int __A)
  {
    return ::_mm_set_epi32(0, 0, 0, __A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cvtsi64_si128(long long int __A)
  {
    return ::_mm_set_epi64x(0, __A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cvtsi64x_si128(long long int __A)
  {
    return ::_mm_set_epi64x(0, __A);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_castpd_ps(::__m128d __A)
  {
    return (::__m128)__A;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_castpd_si128(::__m128d __A)
  {
    return (::__m128i)__A;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_castps_pd(::__m128 __A)
  {
    return (::__m128d)__A;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_castps_si128(::__m128 __A)
  {
    return (::__m128i)__A;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_castsi128_ps(::__m128i __A)
  {
    return (::__m128)__A;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_castsi128_pd(::__m128i __A)
  {
    return (::__m128d)__A;
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_pause()
  {
    __builtin_ia32_pause();
  }
}
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) float __cl_float4;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) ::cl_uchar __cl_uchar16;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) ::cl_char __cl_char16;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) ::cl_ushort __cl_ushort8;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) ::cl_short __cl_short8;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) ::cl_uint __cl_uint4;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) ::cl_int __cl_int4;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) ::cl_ulong __cl_ulong2;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) ::cl_long __cl_long2;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) ::cl_double __cl_double2;
typedef __attribute__((vector_size(8))) __attribute__((__may_alias__)) ::cl_uchar __cl_uchar8;
typedef __attribute__((vector_size(8))) __attribute__((__may_alias__)) ::cl_char __cl_char8;
typedef __attribute__((vector_size(8))) __attribute__((__may_alias__)) ::cl_ushort __cl_ushort4;
typedef __attribute__((vector_size(8))) __attribute__((__may_alias__)) ::cl_short __cl_short4;
typedef __attribute__((vector_size(8))) __attribute__((__may_alias__)) ::cl_uint __cl_uint2;
typedef __attribute__((vector_size(8))) __attribute__((__may_alias__)) ::cl_int __cl_int2;
typedef __attribute__((vector_size(8))) __attribute__((__may_alias__)) ::cl_ulong __cl_ulong1;
typedef __attribute__((vector_size(8))) __attribute__((__may_alias__)) ::cl_long __cl_long1;
typedef __attribute__((vector_size(8))) __attribute__((__may_alias__)) ::cl_float __cl_float2;
union  cl_char2
{
    __attribute__((aligned(2))) ::cl_char s[2L];
    __extension__ struct 
    {
        __extension__ ::cl_char x;
        __extension__ ::cl_char y;
    };
    __extension__ struct 
    {
        __extension__ ::cl_char s0;
        __extension__ ::cl_char s1;
    };
    __extension__ struct 
    {
        __extension__ ::cl_char lo;
        __extension__ ::cl_char hi;
    };
};
union  cl_char4
{
    __attribute__((aligned(4))) ::cl_char s[4L];
    __extension__ struct 
    {
        __extension__ ::cl_char x;
        __extension__ ::cl_char y;
        __extension__ ::cl_char z;
        __extension__ ::cl_char w;
    };
    __extension__ struct 
    {
        __extension__ ::cl_char s0;
        __extension__ ::cl_char s1;
        __extension__ ::cl_char s2;
        __extension__ ::cl_char s3;
    };
    __extension__ struct 
    {
        __extension__ ::cl_char2 lo;
        __extension__ ::cl_char2 hi;
    };
};
typedef ::cl_char4 cl_char3;
union  cl_char8
{
    __attribute__((aligned(8))) ::cl_char s[8L];
    __extension__ struct 
    {
        __extension__ ::cl_char x;
        __extension__ ::cl_char y;
        __extension__ ::cl_char z;
        __extension__ ::cl_char w;
    };
    __extension__ struct 
    {
        __extension__ ::cl_char s0;
        __extension__ ::cl_char s1;
        __extension__ ::cl_char s2;
        __extension__ ::cl_char s3;
        __extension__ ::cl_char s4;
        __extension__ ::cl_char s5;
        __extension__ ::cl_char s6;
        __extension__ ::cl_char s7;
    };
    __extension__ struct 
    {
        __extension__ ::cl_char4 lo;
        __extension__ ::cl_char4 hi;
    };
    ::__cl_char8 v8;
};
union  cl_char16
{
    __attribute__((aligned(16))) ::cl_char s[16L];
    __extension__ struct 
    {
        __extension__ ::cl_char x;
        __extension__ ::cl_char y;
        __extension__ ::cl_char z;
        __extension__ ::cl_char w;
        __extension__ ::cl_char __spacer4;
        __extension__ ::cl_char __spacer5;
        __extension__ ::cl_char __spacer6;
        __extension__ ::cl_char __spacer7;
        __extension__ ::cl_char __spacer8;
        __extension__ ::cl_char __spacer9;
        __extension__ ::cl_char sa;
        __extension__ ::cl_char sb;
        __extension__ ::cl_char sc;
        __extension__ ::cl_char sd;
        __extension__ ::cl_char se;
        __extension__ ::cl_char sf;
    };
    __extension__ struct 
    {
        __extension__ ::cl_char s0;
        __extension__ ::cl_char s1;
        __extension__ ::cl_char s2;
        __extension__ ::cl_char s3;
        __extension__ ::cl_char s4;
        __extension__ ::cl_char s5;
        __extension__ ::cl_char s6;
        __extension__ ::cl_char s7;
        __extension__ ::cl_char s8;
        __extension__ ::cl_char s9;
        __extension__ ::cl_char sA;
        __extension__ ::cl_char sB;
        __extension__ ::cl_char sC;
        __extension__ ::cl_char sD;
        __extension__ ::cl_char sE;
        __extension__ ::cl_char sF;
    };
    __extension__ struct 
    {
        __extension__ ::cl_char8 lo;
        __extension__ ::cl_char8 hi;
    };
    ::__cl_char8 v8[2L];
    ::__cl_char16 v16;
};
union  cl_uchar2
{
    __attribute__((aligned(2))) ::cl_uchar s[2L];
    __extension__ struct 
    {
        __extension__ ::cl_uchar x;
        __extension__ ::cl_uchar y;
    };
    __extension__ struct 
    {
        __extension__ ::cl_uchar s0;
        __extension__ ::cl_uchar s1;
    };
    __extension__ struct 
    {
        __extension__ ::cl_uchar lo;
        __extension__ ::cl_uchar hi;
    };
};
union  cl_uchar4
{
    __attribute__((aligned(4))) ::cl_uchar s[4L];
    __extension__ struct 
    {
        __extension__ ::cl_uchar x;
        __extension__ ::cl_uchar y;
        __extension__ ::cl_uchar z;
        __extension__ ::cl_uchar w;
    };
    __extension__ struct 
    {
        __extension__ ::cl_uchar s0;
        __extension__ ::cl_uchar s1;
        __extension__ ::cl_uchar s2;
        __extension__ ::cl_uchar s3;
    };
    __extension__ struct 
    {
        __extension__ ::cl_uchar2 lo;
        __extension__ ::cl_uchar2 hi;
    };
};
typedef ::cl_uchar4 cl_uchar3;
union  cl_uchar8
{
    __attribute__((aligned(8))) ::cl_uchar s[8L];
    __extension__ struct 
    {
        __extension__ ::cl_uchar x;
        __extension__ ::cl_uchar y;
        __extension__ ::cl_uchar z;
        __extension__ ::cl_uchar w;
    };
    __extension__ struct 
    {
        __extension__ ::cl_uchar s0;
        __extension__ ::cl_uchar s1;
        __extension__ ::cl_uchar s2;
        __extension__ ::cl_uchar s3;
        __extension__ ::cl_uchar s4;
        __extension__ ::cl_uchar s5;
        __extension__ ::cl_uchar s6;
        __extension__ ::cl_uchar s7;
    };
    __extension__ struct 
    {
        __extension__ ::cl_uchar4 lo;
        __extension__ ::cl_uchar4 hi;
    };
    ::__cl_uchar8 v8;
};
union  cl_uchar16
{
    __attribute__((aligned(16))) ::cl_uchar s[16L];
    __extension__ struct 
    {
        __extension__ ::cl_uchar x;
        __extension__ ::cl_uchar y;
        __extension__ ::cl_uchar z;
        __extension__ ::cl_uchar w;
        __extension__ ::cl_uchar __spacer4;
        __extension__ ::cl_uchar __spacer5;
        __extension__ ::cl_uchar __spacer6;
        __extension__ ::cl_uchar __spacer7;
        __extension__ ::cl_uchar __spacer8;
        __extension__ ::cl_uchar __spacer9;
        __extension__ ::cl_uchar sa;
        __extension__ ::cl_uchar sb;
        __extension__ ::cl_uchar sc;
        __extension__ ::cl_uchar sd;
        __extension__ ::cl_uchar se;
        __extension__ ::cl_uchar sf;
    };
    __extension__ struct 
    {
        __extension__ ::cl_uchar s0;
        __extension__ ::cl_uchar s1;
        __extension__ ::cl_uchar s2;
        __extension__ ::cl_uchar s3;
        __extension__ ::cl_uchar s4;
        __extension__ ::cl_uchar s5;
        __extension__ ::cl_uchar s6;
        __extension__ ::cl_uchar s7;
        __extension__ ::cl_uchar s8;
        __extension__ ::cl_uchar s9;
        __extension__ ::cl_uchar sA;
        __extension__ ::cl_uchar sB;
        __extension__ ::cl_uchar sC;
        __extension__ ::cl_uchar sD;
        __extension__ ::cl_uchar sE;
        __extension__ ::cl_uchar sF;
    };
    __extension__ struct 
    {
        __extension__ ::cl_uchar8 lo;
        __extension__ ::cl_uchar8 hi;
    };
    ::__cl_uchar8 v8[2L];
    ::__cl_uchar16 v16;
};
union  cl_short2
{
    __attribute__((aligned(4))) ::cl_short s[2L];
    __extension__ struct 
    {
        __extension__ ::cl_short x;
        __extension__ ::cl_short y;
    };
    __extension__ struct 
    {
        __extension__ ::cl_short s0;
        __extension__ ::cl_short s1;
    };
    __extension__ struct 
    {
        __extension__ ::cl_short lo;
        __extension__ ::cl_short hi;
    };
};
union  cl_short4
{
    __attribute__((aligned(8))) ::cl_short s[4L];
    __extension__ struct 
    {
        __extension__ ::cl_short x;
        __extension__ ::cl_short y;
        __extension__ ::cl_short z;
        __extension__ ::cl_short w;
    };
    __extension__ struct 
    {
        __extension__ ::cl_short s0;
        __extension__ ::cl_short s1;
        __extension__ ::cl_short s2;
        __extension__ ::cl_short s3;
    };
    __extension__ struct 
    {
        __extension__ ::cl_short2 lo;
        __extension__ ::cl_short2 hi;
    };
    ::__cl_short4 v4;
};
typedef ::cl_short4 cl_short3;
union  cl_short8
{
    __attribute__((aligned(16))) ::cl_short s[8L];
    __extension__ struct 
    {
        __extension__ ::cl_short x;
        __extension__ ::cl_short y;
        __extension__ ::cl_short z;
        __extension__ ::cl_short w;
    };
    __extension__ struct 
    {
        __extension__ ::cl_short s0;
        __extension__ ::cl_short s1;
        __extension__ ::cl_short s2;
        __extension__ ::cl_short s3;
        __extension__ ::cl_short s4;
        __extension__ ::cl_short s5;
        __extension__ ::cl_short s6;
        __extension__ ::cl_short s7;
    };
    __extension__ struct 
    {
        __extension__ ::cl_short4 lo;
        __extension__ ::cl_short4 hi;
    };
    ::__cl_short4 v4[2L];
    ::__cl_short8 v8;
};
union  cl_short16
{
    __attribute__((aligned(32))) ::cl_short s[16L];
    __extension__ struct 
    {
        __extension__ ::cl_short x;
        __extension__ ::cl_short y;
        __extension__ ::cl_short z;
        __extension__ ::cl_short w;
        __extension__ ::cl_short __spacer4;
        __extension__ ::cl_short __spacer5;
        __extension__ ::cl_short __spacer6;
        __extension__ ::cl_short __spacer7;
        __extension__ ::cl_short __spacer8;
        __extension__ ::cl_short __spacer9;
        __extension__ ::cl_short sa;
        __extension__ ::cl_short sb;
        __extension__ ::cl_short sc;
        __extension__ ::cl_short sd;
        __extension__ ::cl_short se;
        __extension__ ::cl_short sf;
    };
    __extension__ struct 
    {
        __extension__ ::cl_short s0;
        __extension__ ::cl_short s1;
        __extension__ ::cl_short s2;
        __extension__ ::cl_short s3;
        __extension__ ::cl_short s4;
        __extension__ ::cl_short s5;
        __extension__ ::cl_short s6;
        __extension__ ::cl_short s7;
        __extension__ ::cl_short s8;
        __extension__ ::cl_short s9;
        __extension__ ::cl_short sA;
        __extension__ ::cl_short sB;
        __extension__ ::cl_short sC;
        __extension__ ::cl_short sD;
        __extension__ ::cl_short sE;
        __extension__ ::cl_short sF;
    };
    __extension__ struct 
    {
        __extension__ ::cl_short8 lo;
        __extension__ ::cl_short8 hi;
    };
    ::__cl_short4 v4[4L];
    ::__cl_short8 v8[2L];
};
union  cl_ushort2
{
    __attribute__((aligned(4))) ::cl_ushort s[2L];
    __extension__ struct 
    {
        __extension__ ::cl_ushort x;
        __extension__ ::cl_ushort y;
    };
    __extension__ struct 
    {
        __extension__ ::cl_ushort s0;
        __extension__ ::cl_ushort s1;
    };
    __extension__ struct 
    {
        __extension__ ::cl_ushort lo;
        __extension__ ::cl_ushort hi;
    };
};
union  cl_ushort4
{
    __attribute__((aligned(8))) ::cl_ushort s[4L];
    __extension__ struct 
    {
        __extension__ ::cl_ushort x;
        __extension__ ::cl_ushort y;
        __extension__ ::cl_ushort z;
        __extension__ ::cl_ushort w;
    };
    __extension__ struct 
    {
        __extension__ ::cl_ushort s0;
        __extension__ ::cl_ushort s1;
        __extension__ ::cl_ushort s2;
        __extension__ ::cl_ushort s3;
    };
    __extension__ struct 
    {
        __extension__ ::cl_ushort2 lo;
        __extension__ ::cl_ushort2 hi;
    };
    ::__cl_ushort4 v4;
};
typedef ::cl_ushort4 cl_ushort3;
union  cl_ushort8
{
    __attribute__((aligned(16))) ::cl_ushort s[8L];
    __extension__ struct 
    {
        __extension__ ::cl_ushort x;
        __extension__ ::cl_ushort y;
        __extension__ ::cl_ushort z;
        __extension__ ::cl_ushort w;
    };
    __extension__ struct 
    {
        __extension__ ::cl_ushort s0;
        __extension__ ::cl_ushort s1;
        __extension__ ::cl_ushort s2;
        __extension__ ::cl_ushort s3;
        __extension__ ::cl_ushort s4;
        __extension__ ::cl_ushort s5;
        __extension__ ::cl_ushort s6;
        __extension__ ::cl_ushort s7;
    };
    __extension__ struct 
    {
        __extension__ ::cl_ushort4 lo;
        __extension__ ::cl_ushort4 hi;
    };
    ::__cl_ushort4 v4[2L];
    ::__cl_ushort8 v8;
};
union  cl_ushort16
{
    __attribute__((aligned(32))) ::cl_ushort s[16L];
    __extension__ struct 
    {
        __extension__ ::cl_ushort x;
        __extension__ ::cl_ushort y;
        __extension__ ::cl_ushort z;
        __extension__ ::cl_ushort w;
        __extension__ ::cl_ushort __spacer4;
        __extension__ ::cl_ushort __spacer5;
        __extension__ ::cl_ushort __spacer6;
        __extension__ ::cl_ushort __spacer7;
        __extension__ ::cl_ushort __spacer8;
        __extension__ ::cl_ushort __spacer9;
        __extension__ ::cl_ushort sa;
        __extension__ ::cl_ushort sb;
        __extension__ ::cl_ushort sc;
        __extension__ ::cl_ushort sd;
        __extension__ ::cl_ushort se;
        __extension__ ::cl_ushort sf;
    };
    __extension__ struct 
    {
        __extension__ ::cl_ushort s0;
        __extension__ ::cl_ushort s1;
        __extension__ ::cl_ushort s2;
        __extension__ ::cl_ushort s3;
        __extension__ ::cl_ushort s4;
        __extension__ ::cl_ushort s5;
        __extension__ ::cl_ushort s6;
        __extension__ ::cl_ushort s7;
        __extension__ ::cl_ushort s8;
        __extension__ ::cl_ushort s9;
        __extension__ ::cl_ushort sA;
        __extension__ ::cl_ushort sB;
        __extension__ ::cl_ushort sC;
        __extension__ ::cl_ushort sD;
        __extension__ ::cl_ushort sE;
        __extension__ ::cl_ushort sF;
    };
    __extension__ struct 
    {
        __extension__ ::cl_ushort8 lo;
        __extension__ ::cl_ushort8 hi;
    };
    ::__cl_ushort4 v4[4L];
    ::__cl_ushort8 v8[2L];
};
union  cl_half2
{
    __attribute__((aligned(4))) ::cl_half s[2L];
    __extension__ struct 
    {
        __extension__ ::cl_half x;
        __extension__ ::cl_half y;
    };
    __extension__ struct 
    {
        __extension__ ::cl_half s0;
        __extension__ ::cl_half s1;
    };
    __extension__ struct 
    {
        __extension__ ::cl_half lo;
        __extension__ ::cl_half hi;
    };
};
union  cl_half4
{
    __attribute__((aligned(8))) ::cl_half s[4L];
    __extension__ struct 
    {
        __extension__ ::cl_half x;
        __extension__ ::cl_half y;
        __extension__ ::cl_half z;
        __extension__ ::cl_half w;
    };
    __extension__ struct 
    {
        __extension__ ::cl_half s0;
        __extension__ ::cl_half s1;
        __extension__ ::cl_half s2;
        __extension__ ::cl_half s3;
    };
    __extension__ struct 
    {
        __extension__ ::cl_half2 lo;
        __extension__ ::cl_half2 hi;
    };
};
typedef ::cl_half4 cl_half3;
union  cl_half8
{
    __attribute__((aligned(16))) ::cl_half s[8L];
    __extension__ struct 
    {
        __extension__ ::cl_half x;
        __extension__ ::cl_half y;
        __extension__ ::cl_half z;
        __extension__ ::cl_half w;
    };
    __extension__ struct 
    {
        __extension__ ::cl_half s0;
        __extension__ ::cl_half s1;
        __extension__ ::cl_half s2;
        __extension__ ::cl_half s3;
        __extension__ ::cl_half s4;
        __extension__ ::cl_half s5;
        __extension__ ::cl_half s6;
        __extension__ ::cl_half s7;
    };
    __extension__ struct 
    {
        __extension__ ::cl_half4 lo;
        __extension__ ::cl_half4 hi;
    };
};
union  cl_half16
{
    __attribute__((aligned(32))) ::cl_half s[16L];
    __extension__ struct 
    {
        __extension__ ::cl_half x;
        __extension__ ::cl_half y;
        __extension__ ::cl_half z;
        __extension__ ::cl_half w;
        __extension__ ::cl_half __spacer4;
        __extension__ ::cl_half __spacer5;
        __extension__ ::cl_half __spacer6;
        __extension__ ::cl_half __spacer7;
        __extension__ ::cl_half __spacer8;
        __extension__ ::cl_half __spacer9;
        __extension__ ::cl_half sa;
        __extension__ ::cl_half sb;
        __extension__ ::cl_half sc;
        __extension__ ::cl_half sd;
        __extension__ ::cl_half se;
        __extension__ ::cl_half sf;
    };
    __extension__ struct 
    {
        __extension__ ::cl_half s0;
        __extension__ ::cl_half s1;
        __extension__ ::cl_half s2;
        __extension__ ::cl_half s3;
        __extension__ ::cl_half s4;
        __extension__ ::cl_half s5;
        __extension__ ::cl_half s6;
        __extension__ ::cl_half s7;
        __extension__ ::cl_half s8;
        __extension__ ::cl_half s9;
        __extension__ ::cl_half sA;
        __extension__ ::cl_half sB;
        __extension__ ::cl_half sC;
        __extension__ ::cl_half sD;
        __extension__ ::cl_half sE;
        __extension__ ::cl_half sF;
    };
    __extension__ struct 
    {
        __extension__ ::cl_half8 lo;
        __extension__ ::cl_half8 hi;
    };
};
union  cl_int2
{
    __attribute__((aligned(8))) ::cl_int s[2L];
    __extension__ struct 
    {
        __extension__ ::cl_int x;
        __extension__ ::cl_int y;
    };
    __extension__ struct 
    {
        __extension__ ::cl_int s0;
        __extension__ ::cl_int s1;
    };
    __extension__ struct 
    {
        __extension__ ::cl_int lo;
        __extension__ ::cl_int hi;
    };
    ::__cl_int2 v2;
};
union  cl_int4
{
    __attribute__((aligned(16))) ::cl_int s[4L];
    __extension__ struct 
    {
        __extension__ ::cl_int x;
        __extension__ ::cl_int y;
        __extension__ ::cl_int z;
        __extension__ ::cl_int w;
    };
    __extension__ struct 
    {
        __extension__ ::cl_int s0;
        __extension__ ::cl_int s1;
        __extension__ ::cl_int s2;
        __extension__ ::cl_int s3;
    };
    __extension__ struct 
    {
        __extension__ ::cl_int2 lo;
        __extension__ ::cl_int2 hi;
    };
    ::__cl_int2 v2[2L];
    ::__cl_int4 v4;
};
typedef ::cl_int4 cl_int3;
union  cl_int8
{
    __attribute__((aligned(32))) ::cl_int s[8L];
    __extension__ struct 
    {
        __extension__ ::cl_int x;
        __extension__ ::cl_int y;
        __extension__ ::cl_int z;
        __extension__ ::cl_int w;
    };
    __extension__ struct 
    {
        __extension__ ::cl_int s0;
        __extension__ ::cl_int s1;
        __extension__ ::cl_int s2;
        __extension__ ::cl_int s3;
        __extension__ ::cl_int s4;
        __extension__ ::cl_int s5;
        __extension__ ::cl_int s6;
        __extension__ ::cl_int s7;
    };
    __extension__ struct 
    {
        __extension__ ::cl_int4 lo;
        __extension__ ::cl_int4 hi;
    };
    ::__cl_int2 v2[4L];
    ::__cl_int4 v4[2L];
};
union  cl_int16
{
    __attribute__((aligned(64))) ::cl_int s[16L];
    __extension__ struct 
    {
        __extension__ ::cl_int x;
        __extension__ ::cl_int y;
        __extension__ ::cl_int z;
        __extension__ ::cl_int w;
        __extension__ ::cl_int __spacer4;
        __extension__ ::cl_int __spacer5;
        __extension__ ::cl_int __spacer6;
        __extension__ ::cl_int __spacer7;
        __extension__ ::cl_int __spacer8;
        __extension__ ::cl_int __spacer9;
        __extension__ ::cl_int sa;
        __extension__ ::cl_int sb;
        __extension__ ::cl_int sc;
        __extension__ ::cl_int sd;
        __extension__ ::cl_int se;
        __extension__ ::cl_int sf;
    };
    __extension__ struct 
    {
        __extension__ ::cl_int s0;
        __extension__ ::cl_int s1;
        __extension__ ::cl_int s2;
        __extension__ ::cl_int s3;
        __extension__ ::cl_int s4;
        __extension__ ::cl_int s5;
        __extension__ ::cl_int s6;
        __extension__ ::cl_int s7;
        __extension__ ::cl_int s8;
        __extension__ ::cl_int s9;
        __extension__ ::cl_int sA;
        __extension__ ::cl_int sB;
        __extension__ ::cl_int sC;
        __extension__ ::cl_int sD;
        __extension__ ::cl_int sE;
        __extension__ ::cl_int sF;
    };
    __extension__ struct 
    {
        __extension__ ::cl_int8 lo;
        __extension__ ::cl_int8 hi;
    };
    ::__cl_int2 v2[8L];
    ::__cl_int4 v4[4L];
};
union  cl_uint2
{
    __attribute__((aligned(8))) ::cl_uint s[2L];
    __extension__ struct 
    {
        __extension__ ::cl_uint x;
        __extension__ ::cl_uint y;
    };
    __extension__ struct 
    {
        __extension__ ::cl_uint s0;
        __extension__ ::cl_uint s1;
    };
    __extension__ struct 
    {
        __extension__ ::cl_uint lo;
        __extension__ ::cl_uint hi;
    };
    ::__cl_uint2 v2;
};
union  cl_uint4
{
    __attribute__((aligned(16))) ::cl_uint s[4L];
    __extension__ struct 
    {
        __extension__ ::cl_uint x;
        __extension__ ::cl_uint y;
        __extension__ ::cl_uint z;
        __extension__ ::cl_uint w;
    };
    __extension__ struct 
    {
        __extension__ ::cl_uint s0;
        __extension__ ::cl_uint s1;
        __extension__ ::cl_uint s2;
        __extension__ ::cl_uint s3;
    };
    __extension__ struct 
    {
        __extension__ ::cl_uint2 lo;
        __extension__ ::cl_uint2 hi;
    };
    ::__cl_uint2 v2[2L];
    ::__cl_uint4 v4;
};
typedef ::cl_uint4 cl_uint3;
union  cl_uint8
{
    __attribute__((aligned(32))) ::cl_uint s[8L];
    __extension__ struct 
    {
        __extension__ ::cl_uint x;
        __extension__ ::cl_uint y;
        __extension__ ::cl_uint z;
        __extension__ ::cl_uint w;
    };
    __extension__ struct 
    {
        __extension__ ::cl_uint s0;
        __extension__ ::cl_uint s1;
        __extension__ ::cl_uint s2;
        __extension__ ::cl_uint s3;
        __extension__ ::cl_uint s4;
        __extension__ ::cl_uint s5;
        __extension__ ::cl_uint s6;
        __extension__ ::cl_uint s7;
    };
    __extension__ struct 
    {
        __extension__ ::cl_uint4 lo;
        __extension__ ::cl_uint4 hi;
    };
    ::__cl_uint2 v2[4L];
    ::__cl_uint4 v4[2L];
};
union  cl_uint16
{
    __attribute__((aligned(64))) ::cl_uint s[16L];
    __extension__ struct 
    {
        __extension__ ::cl_uint x;
        __extension__ ::cl_uint y;
        __extension__ ::cl_uint z;
        __extension__ ::cl_uint w;
        __extension__ ::cl_uint __spacer4;
        __extension__ ::cl_uint __spacer5;
        __extension__ ::cl_uint __spacer6;
        __extension__ ::cl_uint __spacer7;
        __extension__ ::cl_uint __spacer8;
        __extension__ ::cl_uint __spacer9;
        __extension__ ::cl_uint sa;
        __extension__ ::cl_uint sb;
        __extension__ ::cl_uint sc;
        __extension__ ::cl_uint sd;
        __extension__ ::cl_uint se;
        __extension__ ::cl_uint sf;
    };
    __extension__ struct 
    {
        __extension__ ::cl_uint s0;
        __extension__ ::cl_uint s1;
        __extension__ ::cl_uint s2;
        __extension__ ::cl_uint s3;
        __extension__ ::cl_uint s4;
        __extension__ ::cl_uint s5;
        __extension__ ::cl_uint s6;
        __extension__ ::cl_uint s7;
        __extension__ ::cl_uint s8;
        __extension__ ::cl_uint s9;
        __extension__ ::cl_uint sA;
        __extension__ ::cl_uint sB;
        __extension__ ::cl_uint sC;
        __extension__ ::cl_uint sD;
        __extension__ ::cl_uint sE;
        __extension__ ::cl_uint sF;
    };
    __extension__ struct 
    {
        __extension__ ::cl_uint8 lo;
        __extension__ ::cl_uint8 hi;
    };
    ::__cl_uint2 v2[8L];
    ::__cl_uint4 v4[4L];
};
union  cl_long2
{
    __attribute__((aligned(16))) ::cl_long s[2L];
    __extension__ struct 
    {
        __extension__ ::cl_long x;
        __extension__ ::cl_long y;
    };
    __extension__ struct 
    {
        __extension__ ::cl_long s0;
        __extension__ ::cl_long s1;
    };
    __extension__ struct 
    {
        __extension__ ::cl_long lo;
        __extension__ ::cl_long hi;
    };
    ::__cl_long2 v2;
};
union  cl_long4
{
    __attribute__((aligned(32))) ::cl_long s[4L];
    __extension__ struct 
    {
        __extension__ ::cl_long x;
        __extension__ ::cl_long y;
        __extension__ ::cl_long z;
        __extension__ ::cl_long w;
    };
    __extension__ struct 
    {
        __extension__ ::cl_long s0;
        __extension__ ::cl_long s1;
        __extension__ ::cl_long s2;
        __extension__ ::cl_long s3;
    };
    __extension__ struct 
    {
        __extension__ ::cl_long2 lo;
        __extension__ ::cl_long2 hi;
    };
    ::__cl_long2 v2[2L];
};
typedef ::cl_long4 cl_long3;
union  cl_long8
{
    __attribute__((aligned(64))) ::cl_long s[8L];
    __extension__ struct 
    {
        __extension__ ::cl_long x;
        __extension__ ::cl_long y;
        __extension__ ::cl_long z;
        __extension__ ::cl_long w;
    };
    __extension__ struct 
    {
        __extension__ ::cl_long s0;
        __extension__ ::cl_long s1;
        __extension__ ::cl_long s2;
        __extension__ ::cl_long s3;
        __extension__ ::cl_long s4;
        __extension__ ::cl_long s5;
        __extension__ ::cl_long s6;
        __extension__ ::cl_long s7;
    };
    __extension__ struct 
    {
        __extension__ ::cl_long4 lo;
        __extension__ ::cl_long4 hi;
    };
    ::__cl_long2 v2[4L];
};
union  cl_long16
{
    __attribute__((aligned(128))) ::cl_long s[16L];
    __extension__ struct 
    {
        __extension__ ::cl_long x;
        __extension__ ::cl_long y;
        __extension__ ::cl_long z;
        __extension__ ::cl_long w;
        __extension__ ::cl_long __spacer4;
        __extension__ ::cl_long __spacer5;
        __extension__ ::cl_long __spacer6;
        __extension__ ::cl_long __spacer7;
        __extension__ ::cl_long __spacer8;
        __extension__ ::cl_long __spacer9;
        __extension__ ::cl_long sa;
        __extension__ ::cl_long sb;
        __extension__ ::cl_long sc;
        __extension__ ::cl_long sd;
        __extension__ ::cl_long se;
        __extension__ ::cl_long sf;
    };
    __extension__ struct 
    {
        __extension__ ::cl_long s0;
        __extension__ ::cl_long s1;
        __extension__ ::cl_long s2;
        __extension__ ::cl_long s3;
        __extension__ ::cl_long s4;
        __extension__ ::cl_long s5;
        __extension__ ::cl_long s6;
        __extension__ ::cl_long s7;
        __extension__ ::cl_long s8;
        __extension__ ::cl_long s9;
        __extension__ ::cl_long sA;
        __extension__ ::cl_long sB;
        __extension__ ::cl_long sC;
        __extension__ ::cl_long sD;
        __extension__ ::cl_long sE;
        __extension__ ::cl_long sF;
    };
    __extension__ struct 
    {
        __extension__ ::cl_long8 lo;
        __extension__ ::cl_long8 hi;
    };
    ::__cl_long2 v2[8L];
};
union  cl_ulong2
{
    __attribute__((aligned(16))) ::cl_ulong s[2L];
    __extension__ struct 
    {
        __extension__ ::cl_ulong x;
        __extension__ ::cl_ulong y;
    };
    __extension__ struct 
    {
        __extension__ ::cl_ulong s0;
        __extension__ ::cl_ulong s1;
    };
    __extension__ struct 
    {
        __extension__ ::cl_ulong lo;
        __extension__ ::cl_ulong hi;
    };
    ::__cl_ulong2 v2;
};
union  cl_ulong4
{
    __attribute__((aligned(32))) ::cl_ulong s[4L];
    __extension__ struct 
    {
        __extension__ ::cl_ulong x;
        __extension__ ::cl_ulong y;
        __extension__ ::cl_ulong z;
        __extension__ ::cl_ulong w;
    };
    __extension__ struct 
    {
        __extension__ ::cl_ulong s0;
        __extension__ ::cl_ulong s1;
        __extension__ ::cl_ulong s2;
        __extension__ ::cl_ulong s3;
    };
    __extension__ struct 
    {
        __extension__ ::cl_ulong2 lo;
        __extension__ ::cl_ulong2 hi;
    };
    ::__cl_ulong2 v2[2L];
};
typedef ::cl_ulong4 cl_ulong3;
union  cl_ulong8
{
    __attribute__((aligned(64))) ::cl_ulong s[8L];
    __extension__ struct 
    {
        __extension__ ::cl_ulong x;
        __extension__ ::cl_ulong y;
        __extension__ ::cl_ulong z;
        __extension__ ::cl_ulong w;
    };
    __extension__ struct 
    {
        __extension__ ::cl_ulong s0;
        __extension__ ::cl_ulong s1;
        __extension__ ::cl_ulong s2;
        __extension__ ::cl_ulong s3;
        __extension__ ::cl_ulong s4;
        __extension__ ::cl_ulong s5;
        __extension__ ::cl_ulong s6;
        __extension__ ::cl_ulong s7;
    };
    __extension__ struct 
    {
        __extension__ ::cl_ulong4 lo;
        __extension__ ::cl_ulong4 hi;
    };
    ::__cl_ulong2 v2[4L];
};
union  cl_ulong16
{
    __attribute__((aligned(128))) ::cl_ulong s[16L];
    __extension__ struct 
    {
        __extension__ ::cl_ulong x;
        __extension__ ::cl_ulong y;
        __extension__ ::cl_ulong z;
        __extension__ ::cl_ulong w;
        __extension__ ::cl_ulong __spacer4;
        __extension__ ::cl_ulong __spacer5;
        __extension__ ::cl_ulong __spacer6;
        __extension__ ::cl_ulong __spacer7;
        __extension__ ::cl_ulong __spacer8;
        __extension__ ::cl_ulong __spacer9;
        __extension__ ::cl_ulong sa;
        __extension__ ::cl_ulong sb;
        __extension__ ::cl_ulong sc;
        __extension__ ::cl_ulong sd;
        __extension__ ::cl_ulong se;
        __extension__ ::cl_ulong sf;
    };
    __extension__ struct 
    {
        __extension__ ::cl_ulong s0;
        __extension__ ::cl_ulong s1;
        __extension__ ::cl_ulong s2;
        __extension__ ::cl_ulong s3;
        __extension__ ::cl_ulong s4;
        __extension__ ::cl_ulong s5;
        __extension__ ::cl_ulong s6;
        __extension__ ::cl_ulong s7;
        __extension__ ::cl_ulong s8;
        __extension__ ::cl_ulong s9;
        __extension__ ::cl_ulong sA;
        __extension__ ::cl_ulong sB;
        __extension__ ::cl_ulong sC;
        __extension__ ::cl_ulong sD;
        __extension__ ::cl_ulong sE;
        __extension__ ::cl_ulong sF;
    };
    __extension__ struct 
    {
        __extension__ ::cl_ulong8 lo;
        __extension__ ::cl_ulong8 hi;
    };
    ::__cl_ulong2 v2[8L];
};
union  cl_float2
{
    __attribute__((aligned(8))) ::cl_float s[2L];
    __extension__ struct 
    {
        __extension__ ::cl_float x;
        __extension__ ::cl_float y;
    };
    __extension__ struct 
    {
        __extension__ ::cl_float s0;
        __extension__ ::cl_float s1;
    };
    __extension__ struct 
    {
        __extension__ ::cl_float lo;
        __extension__ ::cl_float hi;
    };
    ::__cl_float2 v2;
};
union  cl_float4
{
    __attribute__((aligned(16))) ::cl_float s[4L];
    __extension__ struct 
    {
        __extension__ ::cl_float x;
        __extension__ ::cl_float y;
        __extension__ ::cl_float z;
        __extension__ ::cl_float w;
    };
    __extension__ struct 
    {
        __extension__ ::cl_float s0;
        __extension__ ::cl_float s1;
        __extension__ ::cl_float s2;
        __extension__ ::cl_float s3;
    };
    __extension__ struct 
    {
        __extension__ ::cl_float2 lo;
        __extension__ ::cl_float2 hi;
    };
    ::__cl_float2 v2[2L];
    ::__cl_float4 v4;
};
typedef ::cl_float4 cl_float3;
union  cl_float8
{
    __attribute__((aligned(32))) ::cl_float s[8L];
    __extension__ struct 
    {
        __extension__ ::cl_float x;
        __extension__ ::cl_float y;
        __extension__ ::cl_float z;
        __extension__ ::cl_float w;
    };
    __extension__ struct 
    {
        __extension__ ::cl_float s0;
        __extension__ ::cl_float s1;
        __extension__ ::cl_float s2;
        __extension__ ::cl_float s3;
        __extension__ ::cl_float s4;
        __extension__ ::cl_float s5;
        __extension__ ::cl_float s6;
        __extension__ ::cl_float s7;
    };
    __extension__ struct 
    {
        __extension__ ::cl_float4 lo;
        __extension__ ::cl_float4 hi;
    };
    ::__cl_float2 v2[4L];
    ::__cl_float4 v4[2L];
};
union  cl_float16
{
    __attribute__((aligned(64))) ::cl_float s[16L];
    __extension__ struct 
    {
        __extension__ ::cl_float x;
        __extension__ ::cl_float y;
        __extension__ ::cl_float z;
        __extension__ ::cl_float w;
        __extension__ ::cl_float __spacer4;
        __extension__ ::cl_float __spacer5;
        __extension__ ::cl_float __spacer6;
        __extension__ ::cl_float __spacer7;
        __extension__ ::cl_float __spacer8;
        __extension__ ::cl_float __spacer9;
        __extension__ ::cl_float sa;
        __extension__ ::cl_float sb;
        __extension__ ::cl_float sc;
        __extension__ ::cl_float sd;
        __extension__ ::cl_float se;
        __extension__ ::cl_float sf;
    };
    __extension__ struct 
    {
        __extension__ ::cl_float s0;
        __extension__ ::cl_float s1;
        __extension__ ::cl_float s2;
        __extension__ ::cl_float s3;
        __extension__ ::cl_float s4;
        __extension__ ::cl_float s5;
        __extension__ ::cl_float s6;
        __extension__ ::cl_float s7;
        __extension__ ::cl_float s8;
        __extension__ ::cl_float s9;
        __extension__ ::cl_float sA;
        __extension__ ::cl_float sB;
        __extension__ ::cl_float sC;
        __extension__ ::cl_float sD;
        __extension__ ::cl_float sE;
        __extension__ ::cl_float sF;
    };
    __extension__ struct 
    {
        __extension__ ::cl_float8 lo;
        __extension__ ::cl_float8 hi;
    };
    ::__cl_float2 v2[8L];
    ::__cl_float4 v4[4L];
};
union  cl_double2
{
    __attribute__((aligned(16))) ::cl_double s[2L];
    __extension__ struct 
    {
        __extension__ ::cl_double x;
        __extension__ ::cl_double y;
    };
    __extension__ struct 
    {
        __extension__ ::cl_double s0;
        __extension__ ::cl_double s1;
    };
    __extension__ struct 
    {
        __extension__ ::cl_double lo;
        __extension__ ::cl_double hi;
    };
    ::__cl_double2 v2;
};
union  cl_double4
{
    __attribute__((aligned(32))) ::cl_double s[4L];
    __extension__ struct 
    {
        __extension__ ::cl_double x;
        __extension__ ::cl_double y;
        __extension__ ::cl_double z;
        __extension__ ::cl_double w;
    };
    __extension__ struct 
    {
        __extension__ ::cl_double s0;
        __extension__ ::cl_double s1;
        __extension__ ::cl_double s2;
        __extension__ ::cl_double s3;
    };
    __extension__ struct 
    {
        __extension__ ::cl_double2 lo;
        __extension__ ::cl_double2 hi;
    };
    ::__cl_double2 v2[2L];
};
typedef ::cl_double4 cl_double3;
union  cl_double8
{
    __attribute__((aligned(64))) ::cl_double s[8L];
    __extension__ struct 
    {
        __extension__ ::cl_double x;
        __extension__ ::cl_double y;
        __extension__ ::cl_double z;
        __extension__ ::cl_double w;
    };
    __extension__ struct 
    {
        __extension__ ::cl_double s0;
        __extension__ ::cl_double s1;
        __extension__ ::cl_double s2;
        __extension__ ::cl_double s3;
        __extension__ ::cl_double s4;
        __extension__ ::cl_double s5;
        __extension__ ::cl_double s6;
        __extension__ ::cl_double s7;
    };
    __extension__ struct 
    {
        __extension__ ::cl_double4 lo;
        __extension__ ::cl_double4 hi;
    };
    ::__cl_double2 v2[4L];
};
union  cl_double16
{
    __attribute__((aligned(128))) ::cl_double s[16L];
    __extension__ struct 
    {
        __extension__ ::cl_double x;
        __extension__ ::cl_double y;
        __extension__ ::cl_double z;
        __extension__ ::cl_double w;
        __extension__ ::cl_double __spacer4;
        __extension__ ::cl_double __spacer5;
        __extension__ ::cl_double __spacer6;
        __extension__ ::cl_double __spacer7;
        __extension__ ::cl_double __spacer8;
        __extension__ ::cl_double __spacer9;
        __extension__ ::cl_double sa;
        __extension__ ::cl_double sb;
        __extension__ ::cl_double sc;
        __extension__ ::cl_double sd;
        __extension__ ::cl_double se;
        __extension__ ::cl_double sf;
    };
    __extension__ struct 
    {
        __extension__ ::cl_double s0;
        __extension__ ::cl_double s1;
        __extension__ ::cl_double s2;
        __extension__ ::cl_double s3;
        __extension__ ::cl_double s4;
        __extension__ ::cl_double s5;
        __extension__ ::cl_double s6;
        __extension__ ::cl_double s7;
        __extension__ ::cl_double s8;
        __extension__ ::cl_double s9;
        __extension__ ::cl_double sA;
        __extension__ ::cl_double sB;
        __extension__ ::cl_double sC;
        __extension__ ::cl_double sD;
        __extension__ ::cl_double sE;
        __extension__ ::cl_double sF;
    };
    __extension__ struct 
    {
        __extension__ ::cl_double8 lo;
        __extension__ ::cl_double8 hi;
    };
    ::__cl_double2 v2[8L];
};
struct _cl_platform_id;
typedef ::_cl_platform_id *cl_platform_id;
struct _cl_device_id;
typedef ::_cl_device_id *cl_device_id;
struct _cl_context;
typedef ::_cl_context *cl_context;
struct _cl_command_queue;
typedef ::_cl_command_queue *cl_command_queue;
struct _cl_mem;
typedef ::_cl_mem *cl_mem;
struct _cl_program;
typedef ::_cl_program *cl_program;
struct _cl_kernel;
typedef ::_cl_kernel *cl_kernel;
struct _cl_event;
typedef ::_cl_event *cl_event;
struct _cl_sampler;
typedef ::_cl_sampler *cl_sampler;
typedef ::cl_uint cl_bool;
typedef ::cl_ulong cl_bitfield;
typedef ::cl_bitfield cl_device_type;
typedef ::cl_uint cl_platform_info;
typedef ::cl_uint cl_device_info;
typedef ::cl_bitfield cl_device_fp_config;
typedef ::cl_uint cl_device_mem_cache_type;
typedef ::cl_uint cl_device_local_mem_type;
typedef ::cl_bitfield cl_device_exec_capabilities;
typedef ::cl_bitfield cl_device_svm_capabilities;
typedef ::cl_bitfield cl_command_queue_properties;
typedef ::intptr_t cl_device_partition_property;
typedef ::cl_bitfield cl_device_affinity_domain;
typedef ::intptr_t cl_context_properties;
typedef ::cl_uint cl_context_info;
typedef ::cl_bitfield cl_queue_properties;
typedef ::cl_uint cl_command_queue_info;
typedef ::cl_uint cl_channel_order;
typedef ::cl_uint cl_channel_type;
typedef ::cl_bitfield cl_mem_flags;
typedef ::cl_bitfield cl_svm_mem_flags;
typedef ::cl_uint cl_mem_object_type;
typedef ::cl_uint cl_mem_info;
typedef ::cl_bitfield cl_mem_migration_flags;
typedef ::cl_uint cl_image_info;
typedef ::cl_uint cl_buffer_create_type;
typedef ::cl_uint cl_addressing_mode;
typedef ::cl_uint cl_filter_mode;
typedef ::cl_uint cl_sampler_info;
typedef ::cl_bitfield cl_map_flags;
typedef ::intptr_t cl_pipe_properties;
typedef ::cl_uint cl_pipe_info;
typedef ::cl_uint cl_program_info;
typedef ::cl_uint cl_program_build_info;
typedef ::cl_uint cl_program_binary_type;
typedef ::cl_int cl_build_status;
typedef ::cl_uint cl_kernel_info;
typedef ::cl_uint cl_kernel_arg_info;
typedef ::cl_uint cl_kernel_arg_address_qualifier;
typedef ::cl_uint cl_kernel_arg_access_qualifier;
typedef ::cl_bitfield cl_kernel_arg_type_qualifier;
typedef ::cl_uint cl_kernel_work_group_info;
typedef ::cl_uint cl_kernel_sub_group_info;
typedef ::cl_uint cl_event_info;
typedef ::cl_uint cl_command_type;
typedef ::cl_uint cl_profiling_info;
typedef ::cl_bitfield cl_sampler_properties;
typedef ::cl_uint cl_kernel_exec_info;
struct  _cl_image_format
{
    ::cl_channel_order image_channel_order;
    ::cl_channel_type image_channel_data_type;
};
typedef ::_cl_image_format cl_image_format;
struct  _cl_image_desc
{
    ::cl_mem_object_type image_type;
    ::size_t image_width;
    ::size_t image_height;
    ::size_t image_depth;
    ::size_t image_array_size;
    ::size_t image_row_pitch;
    ::size_t image_slice_pitch;
    ::cl_uint num_mip_levels;
    ::cl_uint num_samples;
    __extension__ union 
    {
        __extension__ ::cl_mem buffer;
        __extension__ ::cl_mem mem_object;
    };
};
typedef ::_cl_image_desc cl_image_desc;
struct  _cl_buffer_region
{
    ::size_t origin;
    ::size_t size;
};
typedef ::_cl_buffer_region cl_buffer_region;
extern "C"
{
  extern ::cl_int clGetPlatformIDs(::cl_uint, ::cl_platform_id *, ::cl_uint *);
}
extern "C"
{
  extern ::cl_int clGetPlatformInfo(::cl_platform_id, ::cl_platform_info, ::size_t, void *, ::size_t *);
}
extern "C"
{
  extern ::cl_int clGetDeviceIDs(::cl_platform_id, ::cl_device_type, ::cl_uint, ::cl_device_id *, ::cl_uint *);
}
extern "C"
{
  extern ::cl_int clGetDeviceInfo(::cl_device_id, ::cl_device_info, ::size_t, void *, ::size_t *);
}
extern "C"
{
  extern ::cl_int clCreateSubDevices(::cl_device_id, const ::cl_device_partition_property *, ::cl_uint, ::cl_device_id *, ::cl_uint *);
}
extern "C"
{
  extern ::cl_int clRetainDevice(::cl_device_id);
}
extern "C"
{
  extern ::cl_int clReleaseDevice(::cl_device_id);
}
extern "C"
{
  extern ::cl_int clSetDefaultDeviceCommandQueue(::cl_context, ::cl_device_id, ::cl_command_queue);
}
extern "C"
{
  extern ::cl_int clGetDeviceAndHostTimer(::cl_device_id, ::cl_ulong *, ::cl_ulong *);
}
extern "C"
{
  extern ::cl_int clGetHostTimer(::cl_device_id, ::cl_ulong *);
}
extern "C"
{
  extern ::cl_context clCreateContext(const ::cl_context_properties *, ::cl_uint, const ::cl_device_id *, void (*)(const char *, const void *, ::size_t, void *), void *, ::cl_int *);
}
extern "C"
{
  extern ::cl_context clCreateContextFromType(const ::cl_context_properties *, ::cl_device_type, void (*)(const char *, const void *, ::size_t, void *), void *, ::cl_int *);
}
extern "C"
{
  extern ::cl_int clRetainContext(::cl_context);
}
extern "C"
{
  extern ::cl_int clReleaseContext(::cl_context);
}
extern "C"
{
  extern ::cl_int clGetContextInfo(::cl_context, ::cl_context_info, ::size_t, void *, ::size_t *);
}
extern "C"
{
  extern ::cl_command_queue clCreateCommandQueueWithProperties(::cl_context, ::cl_device_id, const ::cl_queue_properties *, ::cl_int *);
}
extern "C"
{
  extern ::cl_int clRetainCommandQueue(::cl_command_queue);
}
extern "C"
{
  extern ::cl_int clReleaseCommandQueue(::cl_command_queue);
}
extern "C"
{
  extern ::cl_int clGetCommandQueueInfo(::cl_command_queue, ::cl_command_queue_info, ::size_t, void *, ::size_t *);
}
extern "C"
{
  extern ::cl_mem clCreateBuffer(::cl_context, ::cl_mem_flags, ::size_t, void *, ::cl_int *);
}
extern "C"
{
  extern ::cl_mem clCreateSubBuffer(::cl_mem, ::cl_mem_flags, ::cl_buffer_create_type, const void *, ::cl_int *);
}
extern "C"
{
  extern ::cl_mem clCreateImage(::cl_context, ::cl_mem_flags, const ::cl_image_format *, const ::cl_image_desc *, void *, ::cl_int *);
}
extern "C"
{
  extern ::cl_mem clCreatePipe(::cl_context, ::cl_mem_flags, ::cl_uint, ::cl_uint, const ::cl_pipe_properties *, ::cl_int *);
}
extern "C"
{
  extern ::cl_int clRetainMemObject(::cl_mem);
}
extern "C"
{
  extern ::cl_int clReleaseMemObject(::cl_mem);
}
extern "C"
{
  extern ::cl_int clGetSupportedImageFormats(::cl_context, ::cl_mem_flags, ::cl_mem_object_type, ::cl_uint, ::cl_image_format *, ::cl_uint *);
}
extern "C"
{
  extern ::cl_int clGetMemObjectInfo(::cl_mem, ::cl_mem_info, ::size_t, void *, ::size_t *);
}
extern "C"
{
  extern ::cl_int clGetImageInfo(::cl_mem, ::cl_image_info, ::size_t, void *, ::size_t *);
}
extern "C"
{
  extern ::cl_int clGetPipeInfo(::cl_mem, ::cl_pipe_info, ::size_t, void *, ::size_t *);
}
extern "C"
{
  extern ::cl_int clSetMemObjectDestructorCallback(::cl_mem, void (*)(::cl_mem, void *), void *);
}
extern "C"
{
  extern void *clSVMAlloc(::cl_context, ::cl_svm_mem_flags, ::size_t, ::cl_uint);
}
extern "C"
{
  extern void clSVMFree(::cl_context, void *);
}
extern "C"
{
  extern ::cl_sampler clCreateSamplerWithProperties(::cl_context, const ::cl_sampler_properties *, ::cl_int *);
}
extern "C"
{
  extern ::cl_int clRetainSampler(::cl_sampler);
}
extern "C"
{
  extern ::cl_int clReleaseSampler(::cl_sampler);
}
extern "C"
{
  extern ::cl_int clGetSamplerInfo(::cl_sampler, ::cl_sampler_info, ::size_t, void *, ::size_t *);
}
extern "C"
{
  extern ::cl_program clCreateProgramWithSource(::cl_context, ::cl_uint, const char **, const ::size_t *, ::cl_int *);
}
extern "C"
{
  extern ::cl_program clCreateProgramWithBinary(::cl_context, ::cl_uint, const ::cl_device_id *, const ::size_t *, const unsigned char **, ::cl_int *, ::cl_int *);
}
extern "C"
{
  extern ::cl_program clCreateProgramWithBuiltInKernels(::cl_context, ::cl_uint, const ::cl_device_id *, const char *, ::cl_int *);
}
extern "C"
{
  extern ::cl_program clCreateProgramWithIL(::cl_context, const void *, ::size_t, ::cl_int *);
}
extern "C"
{
  extern ::cl_int clRetainProgram(::cl_program);
}
extern "C"
{
  extern ::cl_int clReleaseProgram(::cl_program);
}
extern "C"
{
  extern ::cl_int clBuildProgram(::cl_program, ::cl_uint, const ::cl_device_id *, const char *, void (*)(::cl_program, void *), void *);
}
extern "C"
{
  extern ::cl_int clCompileProgram(::cl_program, ::cl_uint, const ::cl_device_id *, const char *, ::cl_uint, const ::cl_program *, const char **, void (*)(::cl_program, void *), void *);
}
extern "C"
{
  extern ::cl_program clLinkProgram(::cl_context, ::cl_uint, const ::cl_device_id *, const char *, ::cl_uint, const ::cl_program *, void (*)(::cl_program, void *), void *, ::cl_int *);
}
extern "C"
{
  extern ::cl_int clSetProgramReleaseCallback(::cl_program, void (*)(::cl_program, void *), void *);
}
extern "C"
{
  extern ::cl_int clSetProgramSpecializationConstant(::cl_program, ::cl_uint, ::size_t, const void *);
}
extern "C"
{
  extern ::cl_int clUnloadPlatformCompiler(::cl_platform_id);
}
extern "C"
{
  extern ::cl_int clGetProgramInfo(::cl_program, ::cl_program_info, ::size_t, void *, ::size_t *);
}
extern "C"
{
  extern ::cl_int clGetProgramBuildInfo(::cl_program, ::cl_device_id, ::cl_program_build_info, ::size_t, void *, ::size_t *);
}
extern "C"
{
  extern ::cl_kernel clCreateKernel(::cl_program, const char *, ::cl_int *);
}
extern "C"
{
  extern ::cl_int clCreateKernelsInProgram(::cl_program, ::cl_uint, ::cl_kernel *, ::cl_uint *);
}
extern "C"
{
  extern ::cl_kernel clCloneKernel(::cl_kernel, ::cl_int *);
}
extern "C"
{
  extern ::cl_int clRetainKernel(::cl_kernel);
}
extern "C"
{
  extern ::cl_int clReleaseKernel(::cl_kernel);
}
extern "C"
{
  extern ::cl_int clSetKernelArg(::cl_kernel, ::cl_uint, ::size_t, const void *);
}
extern "C"
{
  extern ::cl_int clSetKernelArgSVMPointer(::cl_kernel, ::cl_uint, const void *);
}
extern "C"
{
  extern ::cl_int clSetKernelExecInfo(::cl_kernel, ::cl_kernel_exec_info, ::size_t, const void *);
}
extern "C"
{
  extern ::cl_int clGetKernelInfo(::cl_kernel, ::cl_kernel_info, ::size_t, void *, ::size_t *);
}
extern "C"
{
  extern ::cl_int clGetKernelArgInfo(::cl_kernel, ::cl_uint, ::cl_kernel_arg_info, ::size_t, void *, ::size_t *);
}
extern "C"
{
  extern ::cl_int clGetKernelWorkGroupInfo(::cl_kernel, ::cl_device_id, ::cl_kernel_work_group_info, ::size_t, void *, ::size_t *);
}
extern "C"
{
  extern ::cl_int clGetKernelSubGroupInfo(::cl_kernel, ::cl_device_id, ::cl_kernel_sub_group_info, ::size_t, const void *, ::size_t, void *, ::size_t *);
}
extern "C"
{
  extern ::cl_int clWaitForEvents(::cl_uint, const ::cl_event *);
}
extern "C"
{
  extern ::cl_int clGetEventInfo(::cl_event, ::cl_event_info, ::size_t, void *, ::size_t *);
}
extern "C"
{
  extern ::cl_event clCreateUserEvent(::cl_context, ::cl_int *);
}
extern "C"
{
  extern ::cl_int clRetainEvent(::cl_event);
}
extern "C"
{
  extern ::cl_int clReleaseEvent(::cl_event);
}
extern "C"
{
  extern ::cl_int clSetUserEventStatus(::cl_event, ::cl_int);
}
extern "C"
{
  extern ::cl_int clSetEventCallback(::cl_event, ::cl_int, void (*)(::cl_event, ::cl_int, void *), void *);
}
extern "C"
{
  extern ::cl_int clGetEventProfilingInfo(::cl_event, ::cl_profiling_info, ::size_t, void *, ::size_t *);
}
extern "C"
{
  extern ::cl_int clFlush(::cl_command_queue);
}
extern "C"
{
  extern ::cl_int clFinish(::cl_command_queue);
}
extern "C"
{
  extern ::cl_int clEnqueueReadBuffer(::cl_command_queue, ::cl_mem, ::cl_bool, ::size_t, ::size_t, void *, ::cl_uint, const ::cl_event *, ::cl_event *);
}
extern "C"
{
  extern ::cl_int clEnqueueReadBufferRect(::cl_command_queue, ::cl_mem, ::cl_bool, const ::size_t *, const ::size_t *, const ::size_t *, ::size_t, ::size_t, ::size_t, ::size_t, void *, ::cl_uint, const ::cl_event *, ::cl_event *);
}
extern "C"
{
  extern ::cl_int clEnqueueWriteBuffer(::cl_command_queue, ::cl_mem, ::cl_bool, ::size_t, ::size_t, const void *, ::cl_uint, const ::cl_event *, ::cl_event *);
}
extern "C"
{
  extern ::cl_int clEnqueueWriteBufferRect(::cl_command_queue, ::cl_mem, ::cl_bool, const ::size_t *, const ::size_t *, const ::size_t *, ::size_t, ::size_t, ::size_t, ::size_t, const void *, ::cl_uint, const ::cl_event *, ::cl_event *);
}
extern "C"
{
  extern ::cl_int clEnqueueFillBuffer(::cl_command_queue, ::cl_mem, const void *, ::size_t, ::size_t, ::size_t, ::cl_uint, const ::cl_event *, ::cl_event *);
}
extern "C"
{
  extern ::cl_int clEnqueueCopyBuffer(::cl_command_queue, ::cl_mem, ::cl_mem, ::size_t, ::size_t, ::size_t, ::cl_uint, const ::cl_event *, ::cl_event *);
}
extern "C"
{
  extern ::cl_int clEnqueueCopyBufferRect(::cl_command_queue, ::cl_mem, ::cl_mem, const ::size_t *, const ::size_t *, const ::size_t *, ::size_t, ::size_t, ::size_t, ::size_t, ::cl_uint, const ::cl_event *, ::cl_event *);
}
extern "C"
{
  extern ::cl_int clEnqueueReadImage(::cl_command_queue, ::cl_mem, ::cl_bool, const ::size_t *, const ::size_t *, ::size_t, ::size_t, void *, ::cl_uint, const ::cl_event *, ::cl_event *);
}
extern "C"
{
  extern ::cl_int clEnqueueWriteImage(::cl_command_queue, ::cl_mem, ::cl_bool, const ::size_t *, const ::size_t *, ::size_t, ::size_t, const void *, ::cl_uint, const ::cl_event *, ::cl_event *);
}
extern "C"
{
  extern ::cl_int clEnqueueFillImage(::cl_command_queue, ::cl_mem, const void *, const ::size_t *, const ::size_t *, ::cl_uint, const ::cl_event *, ::cl_event *);
}
extern "C"
{
  extern ::cl_int clEnqueueCopyImage(::cl_command_queue, ::cl_mem, ::cl_mem, const ::size_t *, const ::size_t *, const ::size_t *, ::cl_uint, const ::cl_event *, ::cl_event *);
}
extern "C"
{
  extern ::cl_int clEnqueueCopyImageToBuffer(::cl_command_queue, ::cl_mem, ::cl_mem, const ::size_t *, const ::size_t *, ::size_t, ::cl_uint, const ::cl_event *, ::cl_event *);
}
extern "C"
{
  extern ::cl_int clEnqueueCopyBufferToImage(::cl_command_queue, ::cl_mem, ::cl_mem, ::size_t, const ::size_t *, const ::size_t *, ::cl_uint, const ::cl_event *, ::cl_event *);
}
extern "C"
{
  extern void *clEnqueueMapBuffer(::cl_command_queue, ::cl_mem, ::cl_bool, ::cl_map_flags, ::size_t, ::size_t, ::cl_uint, const ::cl_event *, ::cl_event *, ::cl_int *);
}
extern "C"
{
  extern void *clEnqueueMapImage(::cl_command_queue, ::cl_mem, ::cl_bool, ::cl_map_flags, const ::size_t *, const ::size_t *, ::size_t *, ::size_t *, ::cl_uint, const ::cl_event *, ::cl_event *, ::cl_int *);
}
extern "C"
{
  extern ::cl_int clEnqueueUnmapMemObject(::cl_command_queue, ::cl_mem, void *, ::cl_uint, const ::cl_event *, ::cl_event *);
}
extern "C"
{
  extern ::cl_int clEnqueueMigrateMemObjects(::cl_command_queue, ::cl_uint, const ::cl_mem *, ::cl_mem_migration_flags, ::cl_uint, const ::cl_event *, ::cl_event *);
}
extern "C"
{
  extern ::cl_int clEnqueueNDRangeKernel(::cl_command_queue, ::cl_kernel, ::cl_uint, const ::size_t *, const ::size_t *, const ::size_t *, ::cl_uint, const ::cl_event *, ::cl_event *);
}
extern "C"
{
  extern ::cl_int clEnqueueNativeKernel(::cl_command_queue, void (*)(void *), void *, ::size_t, ::cl_uint, const ::cl_mem *, const void **, ::cl_uint, const ::cl_event *, ::cl_event *);
}
extern "C"
{
  extern ::cl_int clEnqueueMarkerWithWaitList(::cl_command_queue, ::cl_uint, const ::cl_event *, ::cl_event *);
}
extern "C"
{
  extern ::cl_int clEnqueueBarrierWithWaitList(::cl_command_queue, ::cl_uint, const ::cl_event *, ::cl_event *);
}
extern "C"
{
  extern ::cl_int clEnqueueSVMFree(::cl_command_queue, ::cl_uint, void *[], void (*)(::cl_command_queue, ::cl_uint, void *[], void *), void *, ::cl_uint, const ::cl_event *, ::cl_event *);
}
extern "C"
{
  extern ::cl_int clEnqueueSVMMemcpy(::cl_command_queue, ::cl_bool, void *, const void *, ::size_t, ::cl_uint, const ::cl_event *, ::cl_event *);
}
extern "C"
{
  extern ::cl_int clEnqueueSVMMemFill(::cl_command_queue, void *, const void *, ::size_t, ::size_t, ::cl_uint, const ::cl_event *, ::cl_event *);
}
extern "C"
{
  extern ::cl_int clEnqueueSVMMap(::cl_command_queue, ::cl_bool, ::cl_map_flags, void *, ::size_t, ::cl_uint, const ::cl_event *, ::cl_event *);
}
extern "C"
{
  extern ::cl_int clEnqueueSVMUnmap(::cl_command_queue, void *, ::cl_uint, const ::cl_event *, ::cl_event *);
}
extern "C"
{
  extern ::cl_int clEnqueueSVMMigrateMem(::cl_command_queue, ::cl_uint, const void **, const ::size_t *, ::cl_mem_migration_flags, ::cl_uint, const ::cl_event *, ::cl_event *);
}
extern "C"
{
  extern void *clGetExtensionFunctionAddressForPlatform(::cl_platform_id, const char *);
}
extern "C"
{
  extern ::cl_mem clCreateImage2D(::cl_context, ::cl_mem_flags, const ::cl_image_format *, ::size_t, ::size_t, ::size_t, void *, ::cl_int *) __attribute__((deprecated));
}
extern "C"
{
  extern ::cl_mem clCreateImage3D(::cl_context, ::cl_mem_flags, const ::cl_image_format *, ::size_t, ::size_t, ::size_t, ::size_t, ::size_t, void *, ::cl_int *) __attribute__((deprecated));
}
extern "C"
{
  extern ::cl_int clEnqueueMarker(::cl_command_queue, ::cl_event *) __attribute__((deprecated));
}
extern "C"
{
  extern ::cl_int clEnqueueWaitForEvents(::cl_command_queue, ::cl_uint, const ::cl_event *) __attribute__((deprecated));
}
extern "C"
{
  extern ::cl_int clEnqueueBarrier(::cl_command_queue) __attribute__((deprecated));
}
extern "C"
{
  extern ::cl_int clUnloadCompiler() __attribute__((deprecated));
}
extern "C"
{
  extern void *clGetExtensionFunctionAddress(const char *) __attribute__((deprecated));
}
extern "C"
{
  extern ::cl_command_queue clCreateCommandQueue(::cl_context, ::cl_device_id, ::cl_command_queue_properties, ::cl_int *) __attribute__((deprecated));
}
extern "C"
{
  extern ::cl_sampler clCreateSampler(::cl_context, ::cl_bool, ::cl_addressing_mode, ::cl_filter_mode, ::cl_int *) __attribute__((deprecated));
}
extern "C"
{
  extern ::cl_int clEnqueueTask(::cl_command_queue, ::cl_kernel, ::cl_uint, const ::cl_event *, ::cl_event *) __attribute__((deprecated));
}
extern "C"
{
  extern void __assert_fail(const char *__assertion, const char *__file, unsigned int __line, const char *__function) throw() __attribute__((__noreturn__));
}
extern "C"
{
  extern void __assert_perror_fail(int __errnum, const char *__file, unsigned int __line, const char *__function) throw() __attribute__((__noreturn__));
}
extern "C"
{
  extern void __assert(const char *__assertion, const char *__file, int __line) throw() __attribute__((__noreturn__));
}
extern "C"
{
  const char *starpu_opencl_error_string(::cl_int status);
}
extern "C"
{
  void starpu_opencl_display_error(const char *func, const char *file, int line, const char *msg, ::cl_int status);
}
extern "C"
{
  static inline void starpu_opencl_report_error(const char *func, const char *file, int line, const char *msg, ::cl_int status)
  {
    static const char __MERCURIUM_PRETTY_FUNCTION__[91L] = "void ::starpu_opencl_report_error(const char *, const char *, int, const char *, ::cl_int)";
    ::starpu_opencl_display_error(func, file, line, msg, status);
    static_cast<bool>(0) ? (void)0 : ::__assert_fail("0", "/usr/include/starpu/1.2/starpu_opencl.h", 43, __MERCURIUM_PRETTY_FUNCTION__);
  }
}
struct  starpu_opencl_program
{
    ::cl_program programs[8L];
};
extern "C"
{
  void starpu_opencl_get_context(int devid, ::cl_context *context);
}
extern "C"
{
  void starpu_opencl_get_device(int devid, ::cl_device_id *device);
}
extern "C"
{
  void starpu_opencl_get_queue(int devid, ::cl_command_queue *queue);
}
extern "C"
{
  void starpu_opencl_get_current_context(::cl_context *context);
}
extern "C"
{
  void starpu_opencl_get_current_queue(::cl_command_queue *queue);
}
extern "C"
{
  void starpu_opencl_load_program_source(const char *source_file_name, char *located_file_name, char *located_dir_name, char *opencl_program_source);
}
extern "C"
{
  void starpu_opencl_load_program_source_malloc(const char *source_file_name, char **located_file_name, char **located_dir_name, char **opencl_program_source);
}
extern "C"
{
  int starpu_opencl_compile_opencl_from_file(const char *source_file_name, const char *build_options);
}
extern "C"
{
  int starpu_opencl_compile_opencl_from_string(const char *opencl_program_source, const char *file_name, const char *build_options);
}
extern "C"
{
  int starpu_opencl_load_binary_opencl(const char *kernel_id, ::starpu_opencl_program *opencl_programs);
}
extern "C"
{
  int starpu_opencl_load_opencl_from_file(const char *source_file_name, ::starpu_opencl_program *opencl_programs, const char *build_options);
}
extern "C"
{
  int starpu_opencl_load_opencl_from_string(const char *opencl_program_source, ::starpu_opencl_program *opencl_programs, const char *build_options);
}
extern "C"
{
  int starpu_opencl_unload_opencl(::starpu_opencl_program *opencl_programs);
}
extern "C"
{
  int starpu_opencl_load_kernel(::cl_kernel *kernel, ::cl_command_queue *queue, ::starpu_opencl_program *opencl_programs, const char *kernel_name, int devid);
}
extern "C"
{
  int starpu_opencl_release_kernel(::cl_kernel kernel);
}
extern "C"
{
  int starpu_opencl_collect_stats(::cl_event event);
}
extern "C"
{
  int starpu_opencl_set_kernel_args(::cl_int *err, ::cl_kernel *kernel, ...);
}
extern "C"
{
  ::cl_int starpu_opencl_allocate_memory(int devid, ::cl_mem *addr, ::size_t size, ::cl_mem_flags flags);
}
extern "C"
{
  ::cl_int starpu_opencl_copy_ram_to_opencl(void *ptr, unsigned int src_node, ::cl_mem buffer, unsigned int dst_node, ::size_t size, ::size_t offset, ::cl_event *event, int *ret);
}
extern "C"
{
  ::cl_int starpu_opencl_copy_opencl_to_ram(::cl_mem buffer, unsigned int src_node, void *ptr, unsigned int dst_node, ::size_t size, ::size_t offset, ::cl_event *event, int *ret);
}
extern "C"
{
  ::cl_int starpu_opencl_copy_opencl_to_opencl(::cl_mem src, unsigned int src_node, ::size_t src_offset, ::cl_mem dst, unsigned int dst_node, ::size_t dst_offset, ::size_t size, ::cl_event *event, int *ret);
}
extern "C"
{
  ::cl_int starpu_opencl_copy_async_sync(::uintptr_t src, ::size_t src_offset, unsigned int src_node, ::uintptr_t dst, ::size_t dst_offset, unsigned int dst_node, ::size_t size, ::cl_event *event);
}
extern "C"
{
  extern int backtrace(void **__array, int __size) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern char **backtrace_symbols(void *const *__array, int __size) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern void backtrace_symbols_fd(void *const *__array, int __size, int __fd) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  static inline unsigned int starpu_cmpxchg(unsigned int *ptr, unsigned int old, unsigned int next)
  {
    __asm__ __volatile__("lock cmpxchgl %2,%1" : "+a"(old), "+m"(*ptr) : "q"(next) : "memory");
    return old;
  }
}
extern "C"
{
  static inline unsigned int starpu_xchg(unsigned int *ptr, unsigned int next)
  {
    __asm__ __volatile__("xchgl %1,%0" : "+m"(*ptr), "+q"(next) :  : "memory");
    return next;
  }
}
extern "C"
{
  static inline unsigned long int starpu_cmpxchgl(unsigned long int *ptr, unsigned long int old, unsigned long int next)
  {
    __asm__ __volatile__("lock cmpxchgq %2,%1" : "+a"(old), "+m"(*ptr) : "q"(next) : "memory");
    return old;
  }
}
extern "C"
{
  static inline unsigned long int starpu_xchgl(unsigned long int *ptr, unsigned long int next)
  {
    __asm__ __volatile__("xchgq %1,%0" : "+m"(*ptr), "+q"(next) :  : "memory");
    return next;
  }
}
struct _starpu_data_state;
typedef ::_starpu_data_state *starpu_data_handle_t;
enum starpu_data_access_mode
{
  STARPU_NONE = 0,
  STARPU_R = 1 << 0,
  STARPU_W = 1 << 1,
  STARPU_RW = ::STARPU_R | ::STARPU_W,
  STARPU_SCRATCH = 1 << 2,
  STARPU_REDUX = 1 << 3,
  STARPU_COMMUTE = 1 << 4,
  STARPU_SSEND = 1 << 5,
  STARPU_LOCALITY = 1 << 6,
  STARPU_ACCESS_MODE_MAX = 1 << 7
};
struct  starpu_data_descr
{
    ::starpu_data_handle_t handle;
    ::starpu_data_access_mode mode;
};
struct starpu_data_interface_ops;
extern "C"
{
  void starpu_data_set_name(::starpu_data_handle_t handle, const char *name);
}
extern "C"
{
  void starpu_data_set_coordinates_array(::starpu_data_handle_t handle, int dimensions, int dims[]);
}
extern "C"
{
  void starpu_data_set_coordinates(::starpu_data_handle_t handle, unsigned int dimensions, ...);
}
extern "C"
{
  void starpu_data_unregister(::starpu_data_handle_t handle);
}
extern "C"
{
  void starpu_data_unregister_no_coherency(::starpu_data_handle_t handle);
}
extern "C"
{
  void starpu_data_unregister_submit(::starpu_data_handle_t handle);
}
extern "C"
{
  void starpu_data_invalidate(::starpu_data_handle_t handle);
}
extern "C"
{
  void starpu_data_invalidate_submit(::starpu_data_handle_t handle);
}
extern "C"
{
  void starpu_data_advise_as_important(::starpu_data_handle_t handle, unsigned int is_important);
}
extern "C"
{
  int starpu_data_acquire(::starpu_data_handle_t handle, ::starpu_data_access_mode mode);
}
extern "C"
{
  int starpu_data_acquire_on_node(::starpu_data_handle_t handle, int node, ::starpu_data_access_mode mode);
}
extern "C"
{
  int starpu_data_acquire_cb(::starpu_data_handle_t handle, ::starpu_data_access_mode mode, void (*callback)(void *), void *arg);
}
extern "C"
{
  int starpu_data_acquire_on_node_cb(::starpu_data_handle_t handle, int node, ::starpu_data_access_mode mode, void (*callback)(void *), void *arg);
}
extern "C"
{
  int starpu_data_acquire_cb_sequential_consistency(::starpu_data_handle_t handle, ::starpu_data_access_mode mode, void (*callback)(void *), void *arg, int sequential_consistency);
}
extern "C"
{
  int starpu_data_acquire_on_node_cb_sequential_consistency(::starpu_data_handle_t handle, int node, ::starpu_data_access_mode mode, void (*callback)(void *), void *arg, int sequential_consistency);
}
extern "C"
{
  int starpu_data_acquire_on_node_cb_sequential_consistency_sync_jobids(::starpu_data_handle_t handle, int node, ::starpu_data_access_mode mode, void (*callback)(void *), void *arg, int sequential_consistency, long int *pre_sync_jobid, long int *post_sync_jobid);
}
extern "C"
{
  int starpu_data_acquire_try(::starpu_data_handle_t handle, ::starpu_data_access_mode mode);
}
extern "C"
{
  int starpu_data_acquire_on_node_try(::starpu_data_handle_t handle, int node, ::starpu_data_access_mode mode);
}
extern "C"
{
  void starpu_data_release(::starpu_data_handle_t handle);
}
extern "C"
{
  void starpu_data_release_on_node(::starpu_data_handle_t handle, int node);
}
struct starpu_arbiter;
typedef ::starpu_arbiter *starpu_arbiter_t;
extern "C"
{
  ::starpu_arbiter_t starpu_arbiter_create() __attribute__((malloc));
}
extern "C"
{
  void starpu_data_assign_arbiter(::starpu_data_handle_t handle, ::starpu_arbiter_t arbiter);
}
extern "C"
{
  void starpu_arbiter_destroy(::starpu_arbiter_t arbiter);
}
extern "C"
{
  void starpu_data_display_memory_stats();
}
extern "C"
{
  int starpu_data_request_allocation(::starpu_data_handle_t handle, unsigned int node);
}
extern "C"
{
  int starpu_data_fetch_on_node(::starpu_data_handle_t handle, unsigned int node, unsigned int async);
}
extern "C"
{
  int starpu_data_prefetch_on_node(::starpu_data_handle_t handle, unsigned int node, unsigned int async);
}
extern "C"
{
  int starpu_data_idle_prefetch_on_node(::starpu_data_handle_t handle, unsigned int node, unsigned int async);
}
extern "C"
{
  void starpu_data_wont_use(::starpu_data_handle_t handle);
}
enum starpu_node_kind
{
  STARPU_UNUSED = 0,
  STARPU_CPU_RAM = 1,
  STARPU_CUDA_RAM = 2,
  STARPU_OPENCL_RAM = 3,
  STARPU_DISK_RAM = 4,
  STARPU_MIC_RAM = 5,
  STARPU_SCC_RAM = 6,
  STARPU_SCC_SHM = 7
};
extern "C"
{
  unsigned int starpu_worker_get_memory_node(unsigned int workerid);
}
extern "C"
{
  unsigned int starpu_memory_nodes_get_count();
}
extern "C"
{
  ::starpu_node_kind starpu_node_get_kind(unsigned int node);
}
extern "C"
{
  void starpu_data_set_wt_mask(::starpu_data_handle_t handle, ::uint32_t wt_mask);
}
extern "C"
{
  void starpu_data_set_sequential_consistency_flag(::starpu_data_handle_t handle, unsigned int flag);
}
extern "C"
{
  unsigned int starpu_data_get_sequential_consistency_flag(::starpu_data_handle_t handle);
}
extern "C"
{
  unsigned int starpu_data_get_default_sequential_consistency_flag();
}
extern "C"
{
  void starpu_data_set_default_sequential_consistency_flag(unsigned int flag);
}
extern "C"
{
  void starpu_data_query_status(::starpu_data_handle_t handle, int memory_node, int *is_allocated, int *is_valid, int *is_requested);
}
struct starpu_codelet;
extern "C"
{
  void starpu_data_set_reduction_methods(::starpu_data_handle_t handle, ::starpu_codelet *redux_cl, ::starpu_codelet *init_cl);
}
extern "C"
{
  ::starpu_data_interface_ops *starpu_data_get_interface_ops(::starpu_data_handle_t handle);
}
extern "C"
{
  unsigned int starpu_data_test_if_allocated_on_node(::starpu_data_handle_t handle, unsigned int memory_node);
}
extern "C"
{
  void starpu_memchunk_tidy(unsigned int memory_node);
}
extern "C"
{
  void starpu_data_set_user_data(::starpu_data_handle_t handle, void *user_data);
}
extern "C"
{
  void *starpu_data_get_user_data(::starpu_data_handle_t handle);
}
struct starpu_task;
struct _starpu_task_bundle;
typedef ::_starpu_task_bundle *starpu_task_bundle_t;
extern "C"
{
  void starpu_task_bundle_create(::starpu_task_bundle_t *bundle);
}
extern "C"
{
  int starpu_task_bundle_insert(::starpu_task_bundle_t bundle, ::starpu_task *task);
}
extern "C"
{
  int starpu_task_bundle_remove(::starpu_task_bundle_t bundle, ::starpu_task *task);
}
extern "C"
{
  void starpu_task_bundle_close(::starpu_task_bundle_t bundle);
}
extern "C"
{
  extern int *__errno_location() throw() __attribute__((__const__));
}
extern "C"
{
  extern char *program_invocation_name;
}
extern "C"
{
  extern char *program_invocation_short_name;
}
typedef int error_t;
enum starpu_codelet_type
{
  STARPU_SEQ = 0,
  STARPU_SPMD = 1,
  STARPU_FORKJOIN = 2
};
enum starpu_task_status
{
  STARPU_TASK_INVALID = 0,
  STARPU_TASK_BLOCKED = 1,
  STARPU_TASK_READY = 2,
  STARPU_TASK_RUNNING = 3,
  STARPU_TASK_FINISHED = 4,
  STARPU_TASK_BLOCKED_ON_TAG = 5,
  STARPU_TASK_BLOCKED_ON_TASK = 6,
  STARPU_TASK_BLOCKED_ON_DATA = 7,
  STARPU_TASK_STOPPED = 8
};
typedef ::uint64_t starpu_tag_t;
typedef void (*starpu_cpu_func_t)(void **, void *);
typedef void (*starpu_cuda_func_t)(void **, void *);
typedef void (*starpu_opencl_func_t)(void **, void *);
typedef void (*starpu_mic_kernel_t)(void **, void *);
typedef void (*starpu_scc_kernel_t)(void **, void *);
typedef ::starpu_mic_kernel_t (*starpu_mic_func_t)();
typedef ::starpu_scc_kernel_t (*starpu_scc_func_t)();
struct starpu_perfmodel;
struct  starpu_codelet
{
    ::uint32_t where;
    int (*can_execute)(unsigned int, ::starpu_task *, unsigned int);
    ::starpu_codelet_type type;
    int max_parallelism;
    __attribute__((__deprecated__)) ::starpu_cpu_func_t cpu_func;
    __attribute__((__deprecated__)) ::starpu_cuda_func_t cuda_func;
    __attribute__((__deprecated__)) ::starpu_opencl_func_t opencl_func;
    ::starpu_cpu_func_t cpu_funcs[4L];
    ::starpu_cuda_func_t cuda_funcs[4L];
    char cuda_flags[4L];
    ::starpu_opencl_func_t opencl_funcs[4L];
    char opencl_flags[4L];
    ::starpu_mic_func_t mic_funcs[4L];
    ::starpu_scc_func_t scc_funcs[4L];
    const char *cpu_funcs_name[4L];
    int nbuffers;
    ::starpu_data_access_mode modes[8L];
    ::starpu_data_access_mode *dyn_modes;
    unsigned int specific_nodes;
    int nodes[8L];
    int *dyn_nodes;
    ::starpu_perfmodel *model;
    ::starpu_perfmodel *energy_model;
    unsigned long int per_worker_stats[80L];
    const char *name;
    int flags;
};
struct starpu_profiling_task_info;
struct starpu_omp_task;
struct  starpu_task
{
    const char *name;
    ::starpu_codelet *cl;
    int nbuffers;
    ::starpu_data_handle_t handles[8L];
    void *interfaces[8L];
    ::starpu_data_access_mode modes[8L];
    ::starpu_data_handle_t *dyn_handles;
    void **dyn_interfaces;
    ::starpu_data_access_mode *dyn_modes;
    void *cl_arg;
    ::size_t cl_arg_size;
    void (*callback_func)(void *);
    void *callback_arg;
    void (*prologue_callback_func)(void *);
    void *prologue_callback_arg;
    void (*prologue_callback_pop_func)(void *);
    void *prologue_callback_pop_arg;
    ::starpu_tag_t tag_id;
    unsigned int cl_arg_free:1;
    unsigned int callback_arg_free:1;
    unsigned int prologue_callback_arg_free:1;
    unsigned int prologue_callback_pop_arg_free:1;
    unsigned int use_tag:1;
    unsigned int sequential_consistency:1;
    unsigned int synchronous:1;
    unsigned int execute_on_a_specific_worker:1;
    unsigned int detach:1;
    unsigned int destroy:1;
    unsigned int regenerate:1;
    unsigned int scheduled:1;
    unsigned int mf_skip:1;
    unsigned int workerid;
    unsigned int workerorder;
    int priority;
    ::starpu_task_status status;
    int magic;
    unsigned int sched_ctx;
    int hypervisor_tag;
    unsigned int possibly_parallel;
    ::starpu_task_bundle_t bundle;
    ::starpu_profiling_task_info *profiling_info;
    double flops;
    double predicted;
    double predicted_transfer;
    ::starpu_task *prev;
    ::starpu_task *next;
    void *starpu_private;
    unsigned int prefetched;
    ::starpu_omp_task *omp_task;
};
extern "C"
{
  void starpu_tag_declare_deps(::starpu_tag_t id, unsigned int ndeps, ...);
}
extern "C"
{
  void starpu_tag_declare_deps_array(::starpu_tag_t id, unsigned int ndeps, ::starpu_tag_t *array);
}
extern "C"
{
  void starpu_task_declare_deps_array(::starpu_task *task, unsigned int ndeps, ::starpu_task *task_array[]);
}
extern "C"
{
  int starpu_task_get_task_succs(::starpu_task *task, unsigned int ndeps, ::starpu_task *task_array[]);
}
extern "C"
{
  int starpu_task_get_task_scheduled_succs(::starpu_task *task, unsigned int ndeps, ::starpu_task *task_array[]);
}
extern "C"
{
  int starpu_tag_wait(::starpu_tag_t id);
}
extern "C"
{
  int starpu_tag_wait_array(unsigned int ntags, ::starpu_tag_t *id);
}
extern "C"
{
  void starpu_tag_notify_from_apps(::starpu_tag_t id);
}
extern "C"
{
  void starpu_tag_restart(::starpu_tag_t id);
}
extern "C"
{
  void starpu_tag_remove(::starpu_tag_t id);
}
extern "C"
{
  void starpu_task_init(::starpu_task *task);
}
extern "C"
{
  void starpu_task_clean(::starpu_task *task);
}
extern "C"
{
  ::starpu_task *starpu_task_create() __attribute__((malloc));
}
extern "C"
{
  void starpu_task_destroy(::starpu_task *task);
}
extern "C"
{
  int starpu_task_submit(::starpu_task *task) __attribute__((__warn_unused_result__));
}
extern "C"
{
  int starpu_task_submit_to_ctx(::starpu_task *task, unsigned int sched_ctx_id);
}
extern "C"
{
  int starpu_task_finished(::starpu_task *task) __attribute__((__warn_unused_result__));
}
extern "C"
{
  int starpu_task_wait(::starpu_task *task) __attribute__((__warn_unused_result__));
}
extern "C"
{
  int starpu_task_wait_for_all();
}
extern "C"
{
  int starpu_task_wait_for_n_submitted(unsigned int n);
}
extern "C"
{
  int starpu_task_wait_for_all_in_ctx(unsigned int sched_ctx_id);
}
extern "C"
{
  int starpu_task_wait_for_n_submitted_in_ctx(unsigned int sched_ctx_id, unsigned int n);
}
extern "C"
{
  int starpu_task_wait_for_no_ready();
}
extern "C"
{
  int starpu_task_nready();
}
extern "C"
{
  int starpu_task_nsubmitted();
}
extern "C"
{
  void starpu_iteration_push(unsigned long int iteration);
}
extern "C"
{
  void starpu_iteration_pop();
}
extern "C"
{
  void starpu_do_schedule();
}
extern "C"
{
  void starpu_codelet_init(::starpu_codelet *cl);
}
extern "C"
{
  void starpu_codelet_display_stats(::starpu_codelet *cl);
}
extern "C"
{
  ::starpu_task *starpu_task_get_current();
}
extern "C"
{
  const char *starpu_task_get_model_name(::starpu_task *task);
}
extern "C"
{
  const char *starpu_task_get_name(::starpu_task *task);
}
extern "C"
{
  void starpu_parallel_task_barrier_init(::starpu_task *task, int workerid);
}
extern "C"
{
  void starpu_parallel_task_barrier_init_n(::starpu_task *task, int worker_size);
}
extern "C"
{
  ::starpu_task *starpu_task_dup(::starpu_task *task);
}
extern "C"
{
  void starpu_task_set_implementation(::starpu_task *task, unsigned int impl);
}
extern "C"
{
  unsigned int starpu_task_get_implementation(::starpu_task *task);
}
extern "C"
{
  extern int _starpu_silent;
}
extern "C"
{
  char *starpu_getenv(const char *str);
}
extern "C"
{
  static inline int starpu_get_env_number(const char *str)
  {
    static const char __MERCURIUM_PRETTY_FUNCTION__[42L] = "int ::starpu_get_env_number(const char *)";
    char *strval;
    strval = ::starpu_getenv(str);
    if (strval)
      {
        long int val;
        char *check;
        val = ::strtol(strval, &check, 10);
        if (*check)
          {
            ::fprintf(::stderr, "The %s environment variable must contain an integer\n", str);
            do
              {
                do
                  {
                    void *__ptrs[32L];
                    int __n(::backtrace(__ptrs, 32));
                    ::backtrace_symbols_fd(__ptrs, __n, 2);
                  }
                while (0);
                ::fprintf(::stderr, "[starpu][abort][%s()@%s:%d]\n", __func__, "/usr/include/starpu/1.2/starpu_util.h", 382);
                ::abort();
              }
            while (0);
          }
        do
          {
            if (__builtin_expect(!!!(val >= 0), 0))
              {
                do
                  {
                    void *__ptrs[32L];
                    int __n(::backtrace(__ptrs, 32));
                    ::backtrace_symbols_fd(__ptrs, __n, 2);
                  }
                while (0);
                ::fprintf(::stderr, "\n[starpu][%s][assert failure] The value for the environment variable \'%s\' cannot be negative\n\n", __func__, str);
                static_cast<bool>(val >= 0) ? (void)0 : ::__assert_fail("val >= 0", "/usr/include/starpu/1.2/starpu_util.h", 386, __MERCURIUM_PRETTY_FUNCTION__);
              }
          }
        while (0);
        return (int)val;
      }
    else
      {
        return  -1;
      }
  }
}
extern "C"
{
  static inline int starpu_get_env_number_default(const char *str, int defval)
  {
    int ret(::starpu_get_env_number(str));
    if (ret ==  -1)
      {
        ret = defval;
      }
    return ret;
  }
}
extern "C"
{
  static inline float starpu_get_env_float_default(const char *str, float defval)
  {
    char *strval;
    strval = ::starpu_getenv(str);
    if (strval)
      {
        float val;
        char *check;
        val = ::strtof(strval, &check);
        if (*check)
          {
            ::fprintf(::stderr, "The %s environment variable must contain a float\n", str);
            do
              {
                do
                  {
                    void *__ptrs[32L];
                    int __n(::backtrace(__ptrs, 32));
                    ::backtrace_symbols_fd(__ptrs, __n, 2);
                  }
                while (0);
                ::fprintf(::stderr, "[starpu][abort][%s()@%s:%d]\n", __func__, "/usr/include/starpu/1.2/starpu_util.h", 419);
                ::abort();
              }
            while (0);
          }
        return val;
      }
    else
      {
        return defval;
      }
  }
}
extern "C"
{
  void starpu_execute_on_each_worker(void (*func)(void *), void *arg, ::uint32_t where);
}
extern "C"
{
  void starpu_execute_on_each_worker_ex(void (*func)(void *), void *arg, ::uint32_t where, const char *name);
}
extern "C"
{
  void starpu_execute_on_specific_workers(void (*func)(void *), void *arg, unsigned int num_workers, unsigned int *workers, const char *name);
}
extern "C"
{
  int starpu_data_cpy(::starpu_data_handle_t dst_handle, ::starpu_data_handle_t src_handle, int asynchronous, void (*callback_func)(void *), void *callback_arg);
}
extern "C"
{
  double starpu_timing_now();
}
struct  timezone
{
    int tz_minuteswest;
    int tz_dsttime;
};
typedef struct ::timezone *__restrict __timezone_ptr_t;
extern "C"
{
  extern int gettimeofday(::timeval *__restrict __tv, ::__timezone_ptr_t __tz) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int settimeofday(const ::timeval *__tv, const struct ::timezone *__tz) throw();
}
extern "C"
{
  extern int adjtime(const ::timeval *__delta, ::timeval *__olddelta) throw();
}
enum __itimer_which
{
  ITIMER_REAL = 0,
  ITIMER_VIRTUAL = 1,
  ITIMER_PROF = 2
};
struct  itimerval
{
    ::timeval it_interval;
    ::timeval it_value;
};
typedef int __itimer_which_t;
extern "C"
{
  extern int getitimer(::__itimer_which_t __which, ::itimerval *__value) throw();
}
extern "C"
{
  extern int setitimer(::__itimer_which_t __which, const ::itimerval *__restrict __new, ::itimerval *__restrict __old) throw();
}
extern "C"
{
  extern int utimes(const char *__file, const ::timeval __tvp[2L]) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int lutimes(const char *__file, const ::timeval __tvp[2L]) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int futimes(int __fd, const ::timeval __tvp[2L]) throw();
}
extern "C"
{
  extern int futimesat(int __fd, const char *__file, const ::timeval __tvp[2L]) throw();
}
typedef ::pthread_t starpu_pthread_t;
typedef ::pthread_attr_t starpu_pthread_attr_t;
typedef ::pthread_mutex_t starpu_pthread_mutex_t;
typedef ::pthread_mutexattr_t starpu_pthread_mutexattr_t;
extern "C"
{
  int starpu_pthread_mutex_lock_sched(::starpu_pthread_mutex_t *mutex);
}
extern "C"
{
  int starpu_pthread_mutex_unlock_sched(::starpu_pthread_mutex_t *mutex);
}
extern "C"
{
  int starpu_pthread_mutex_trylock_sched(::starpu_pthread_mutex_t *mutex);
}
extern "C"
{
  void starpu_pthread_mutex_check_sched(::starpu_pthread_mutex_t *mutex, char *file, int line);
}
typedef ::pthread_key_t starpu_pthread_key_t;
typedef ::pthread_cond_t starpu_pthread_cond_t;
typedef ::pthread_condattr_t starpu_pthread_condattr_t;
typedef ::pthread_rwlock_t starpu_pthread_rwlock_t;
typedef ::pthread_rwlockattr_t starpu_pthread_rwlockattr_t;
typedef ::pthread_barrier_t starpu_pthread_barrier_t;
typedef ::pthread_barrierattr_t starpu_pthread_barrierattr_t;
struct  starpu_pthread_spinlock_t
{
    __attribute__((aligned(16))) unsigned int taken;
};
extern "C"
{
  int starpu_pthread_spin_init(::starpu_pthread_spinlock_t *lock, int pshared);
}
extern "C"
{
  int starpu_pthread_spin_destroy(::starpu_pthread_spinlock_t *lock);
}
extern "C"
{
  int starpu_pthread_spin_lock(::starpu_pthread_spinlock_t *lock);
}
extern "C"
{
  int starpu_pthread_spin_trylock(::starpu_pthread_spinlock_t *lock);
}
extern "C"
{
  int starpu_pthread_spin_unlock(::starpu_pthread_spinlock_t *lock);
}
static inline int _starpu_pthread_mutex_trylock(::starpu_pthread_mutex_t *mutex, char *file, int line)
{
  int p_ret(::pthread_mutex_trylock(mutex));
  if (__builtin_expect(!!(p_ret != 0 && p_ret != 16), 0))
    {
      ::fprintf(::stderr, "%s:%d starpu_pthread_mutex_trylock: %s\n", file, line, ::strerror(p_ret));
      do
        {
          do
            {
              void *__ptrs[32L];
              int __n(::backtrace(__ptrs, 32));
              ::backtrace_symbols_fd(__ptrs, __n, 2);
            }
          while (0);
          ::fprintf(::stderr, "[starpu][abort][%s()@%s:%d]\n", __func__, "/usr/include/starpu/1.2/starpu_thread_util.h", 111);
          ::abort();
        }
      while (0);
    }
  ;
  return p_ret;
}
static inline int _starpu_pthread_mutex_trylock_sched(::starpu_pthread_mutex_t *mutex, char *file, int line)
{
  int p_ret(::starpu_pthread_mutex_trylock_sched(mutex));
  if (__builtin_expect(!!(p_ret != 0 && p_ret != 16), 0))
    {
      ::fprintf(::stderr, "%s:%d starpu_pthread_mutex_trylock: %s\n", file, line, ::strerror(p_ret));
      do
        {
          do
            {
              void *__ptrs[32L];
              int __n(::backtrace(__ptrs, 32));
              ::backtrace_symbols_fd(__ptrs, __n, 2);
            }
          while (0);
          ::fprintf(::stderr, "[starpu][abort][%s()@%s:%d]\n", __func__, "/usr/include/starpu/1.2/starpu_thread_util.h", 127);
          ::abort();
        }
      while (0);
    }
  return p_ret;
}
static inline int _starpu_pthread_rwlock_tryrdlock(::starpu_pthread_rwlock_t *rwlock, char *file, int line)
{
  int p_ret(::pthread_rwlock_tryrdlock(rwlock));
  if (__builtin_expect(!!(p_ret != 0 && p_ret != 16), 0))
    {
      ::fprintf(::stderr, "%s:%d starpu_pthread_rwlock_tryrdlock: %s\n", file, line, ::strerror(p_ret));
      do
        {
          do
            {
              void *__ptrs[32L];
              int __n(::backtrace(__ptrs, 32));
              ::backtrace_symbols_fd(__ptrs, __n, 2);
            }
          while (0);
          ::fprintf(::stderr, "[starpu][abort][%s()@%s:%d]\n", __func__, "/usr/include/starpu/1.2/starpu_thread_util.h", 218);
          ::abort();
        }
      while (0);
    }
  return p_ret;
}
static inline int _starpu_pthread_rwlock_trywrlock(::starpu_pthread_rwlock_t *rwlock, char *file, int line)
{
  int p_ret(::pthread_rwlock_trywrlock(rwlock));
  if (__builtin_expect(!!(p_ret != 0 && p_ret != 16), 0))
    {
      ::fprintf(::stderr, "%s:%d starpu_pthread_rwlock_trywrlock: %s\n", file, line, ::strerror(p_ret));
      do
        {
          do
            {
              void *__ptrs[32L];
              int __n(::backtrace(__ptrs, 32));
              ::backtrace_symbols_fd(__ptrs, __n, 2);
            }
          while (0);
          ::fprintf(::stderr, "[starpu][abort][%s()@%s:%d]\n", __func__, "/usr/include/starpu/1.2/starpu_thread_util.h", 243);
          ::abort();
        }
      while (0);
    }
  return p_ret;
}
struct  starpu_disk_ops
{
    void *(*plug)(void *, ::starpu_ssize_t);
    void (*unplug)(void *);
    int (*bandwidth)(unsigned int, void *);
    void *(*alloc)(void *, ::size_t);
    void (*free)(void *, void *, ::size_t);
    void *(*open)(void *, void *, ::size_t);
    void (*close)(void *, void *, ::size_t);
    int (*read)(void *, void *, void *, ::off_t, ::size_t);
    int (*write)(void *, void *, const void *, ::off_t, ::size_t);
    int (*full_read)(void *, void *, void **, ::size_t *);
    int (*full_write)(void *, void *, void *, ::size_t);
    void *(*async_write)(void *, void *, void *, ::off_t, ::size_t);
    void *(*async_read)(void *, void *, void *, ::off_t, ::size_t);
    void *(*async_full_read)(void *, void *, void **, ::size_t *);
    void *(*async_full_write)(void *, void *, void *, ::size_t);
    void *(*copy)(void *, void *, ::off_t, void *, void *, ::off_t, ::size_t);
    void (*wait_request)(void *);
    int (*test_request)(void *);
    void (*free_request)(void *);
};
extern ::starpu_disk_ops starpu_disk_stdio_ops;
extern ::starpu_disk_ops starpu_disk_unistd_ops;
extern ::starpu_disk_ops starpu_disk_unistd_o_direct_ops;
extern ::starpu_disk_ops starpu_disk_leveldb_ops;
void starpu_disk_close(unsigned int node, void *obj, ::size_t size);
void *starpu_disk_open(unsigned int node, void *pos, ::size_t size);
int starpu_disk_register(::starpu_disk_ops *func, void *parameter, ::starpu_ssize_t size);
extern int starpu_disk_swap_node;
struct  starpu_data_copy_methods
{
    int (*can_copy)(void *, unsigned int, void *, unsigned int, unsigned int);
    int (*ram_to_ram)(void *, unsigned int, void *, unsigned int);
    int (*ram_to_cuda)(void *, unsigned int, void *, unsigned int);
    int (*ram_to_opencl)(void *, unsigned int, void *, unsigned int);
    int (*ram_to_mic)(void *, unsigned int, void *, unsigned int);
    int (*cuda_to_ram)(void *, unsigned int, void *, unsigned int);
    int (*cuda_to_cuda)(void *, unsigned int, void *, unsigned int);
    int (*cuda_to_opencl)(void *, unsigned int, void *, unsigned int);
    int (*opencl_to_ram)(void *, unsigned int, void *, unsigned int);
    int (*opencl_to_cuda)(void *, unsigned int, void *, unsigned int);
    int (*opencl_to_opencl)(void *, unsigned int, void *, unsigned int);
    int (*mic_to_ram)(void *, unsigned int, void *, unsigned int);
    int (*scc_src_to_sink)(void *, unsigned int, void *, unsigned int);
    int (*scc_sink_to_src)(void *, unsigned int, void *, unsigned int);
    int (*scc_sink_to_sink)(void *, unsigned int, void *, unsigned int);
    int (*ram_to_cuda_async)();
    int (*cuda_to_ram_async)();
    int (*cuda_to_cuda_async)();
    int (*ram_to_opencl_async)(void *, unsigned int, void *, unsigned int, ::cl_event *);
    int (*opencl_to_ram_async)(void *, unsigned int, void *, unsigned int, ::cl_event *);
    int (*opencl_to_opencl_async)(void *, unsigned int, void *, unsigned int, ::cl_event *);
    int (*ram_to_mic_async)(void *, unsigned int, void *, unsigned int);
    int (*mic_to_ram_async)(void *, unsigned int, void *, unsigned int);
    int (*any_to_any)(void *, unsigned int, void *, unsigned int, void *);
};
extern "C"
{
  int starpu_interface_copy(::uintptr_t src, ::size_t src_offset, unsigned int src_node, ::uintptr_t dst, ::size_t dst_offset, unsigned int dst_node, ::size_t size, void *async_data);
}
extern "C"
{
  ::uintptr_t starpu_malloc_on_node_flags(unsigned int dst_node, ::size_t size, int flags);
}
extern "C"
{
  ::uintptr_t starpu_malloc_on_node(unsigned int dst_node, ::size_t size);
}
extern "C"
{
  void starpu_free_on_node_flags(unsigned int dst_node, ::uintptr_t addr, ::size_t size, int flags);
}
extern "C"
{
  void starpu_free_on_node(unsigned int dst_node, ::uintptr_t addr, ::size_t size);
}
extern "C"
{
  void starpu_malloc_on_node_set_default_flags(unsigned int node, int flags);
}
enum starpu_data_interface_id
{
  STARPU_UNKNOWN_INTERFACE_ID =  -1,
  STARPU_MATRIX_INTERFACE_ID = 0,
  STARPU_BLOCK_INTERFACE_ID = 1,
  STARPU_VECTOR_INTERFACE_ID = 2,
  STARPU_CSR_INTERFACE_ID = 3,
  STARPU_BCSR_INTERFACE_ID = 4,
  STARPU_VARIABLE_INTERFACE_ID = 5,
  STARPU_VOID_INTERFACE_ID = 6,
  STARPU_MULTIFORMAT_INTERFACE_ID = 7,
  STARPU_COO_INTERFACE_ID = 8,
  STARPU_MAX_INTERFACE_ID = 9
};
struct starpu_multiformat_data_interface_ops;
struct  starpu_data_interface_ops
{
    void (*register_data_handle)(::starpu_data_handle_t, unsigned int, void *);
    ::starpu_ssize_t (*allocate_data_on_node)(void *, unsigned int);
    void (*free_data_on_node)(void *, unsigned int);
    const ::starpu_data_copy_methods *copy_methods;
    void *(*handle_to_pointer)(::starpu_data_handle_t, unsigned int);
    ::size_t (*get_size)(::starpu_data_handle_t);
    ::uint32_t (*footprint)(::starpu_data_handle_t);
    int (*compare)(void *, void *);
    void (*display)(::starpu_data_handle_t, ::FILE *);
    ::starpu_ssize_t (*describe)(void *, char *, ::size_t);
    ::starpu_data_interface_id interfaceid;
    ::size_t interface_size;
    char is_multiformat;
    char dontcache;
    ::starpu_multiformat_data_interface_ops *(*get_mf_ops)(void *);
    int (*pack_data)(::starpu_data_handle_t, unsigned int, void **, ::starpu_ssize_t *);
    int (*unpack_data)(::starpu_data_handle_t, unsigned int, void *, ::size_t);
    char *name;
};
extern "C"
{
  int starpu_data_interface_get_next_id();
}
extern "C"
{
  void starpu_data_register(::starpu_data_handle_t *handleptr, int home_node, void *data_interface, ::starpu_data_interface_ops *ops);
}
extern "C"
{
  void starpu_data_ptr_register(::starpu_data_handle_t handle, unsigned int node);
}
extern "C"
{
  void starpu_data_register_same(::starpu_data_handle_t *handledst, ::starpu_data_handle_t handlesrc);
}
extern "C"
{
  void *starpu_data_handle_to_pointer(::starpu_data_handle_t handle, unsigned int node);
}
extern "C"
{
  void *starpu_data_get_local_ptr(::starpu_data_handle_t handle);
}
extern "C"
{
  void *starpu_data_get_interface_on_node(::starpu_data_handle_t handle, unsigned int memory_node);
}
extern "C"
{
  extern ::starpu_data_interface_ops starpu_interface_matrix_ops;
}
struct  starpu_matrix_interface
{
    ::starpu_data_interface_id id;
    ::uintptr_t ptr;
    ::uintptr_t dev_handle;
    ::size_t offset;
    ::uint32_t nx;
    ::uint32_t ny;
    ::uint32_t ld;
    ::size_t elemsize;
};
extern "C"
{
  void starpu_matrix_data_register(::starpu_data_handle_t *handle, int home_node, ::uintptr_t ptr, ::uint32_t ld, ::uint32_t nx, ::uint32_t ny, ::size_t elemsize);
}
extern "C"
{
  void starpu_matrix_ptr_register(::starpu_data_handle_t handle, unsigned int node, ::uintptr_t ptr, ::uintptr_t dev_handle, ::size_t offset, ::uint32_t ld);
}
extern "C"
{
  ::uint32_t starpu_matrix_get_nx(::starpu_data_handle_t handle);
}
extern "C"
{
  ::uint32_t starpu_matrix_get_ny(::starpu_data_handle_t handle);
}
extern "C"
{
  ::uint32_t starpu_matrix_get_local_ld(::starpu_data_handle_t handle);
}
extern "C"
{
  ::uintptr_t starpu_matrix_get_local_ptr(::starpu_data_handle_t handle);
}
extern "C"
{
  ::size_t starpu_matrix_get_elemsize(::starpu_data_handle_t handle);
}
extern "C"
{
  extern ::starpu_data_interface_ops starpu_interface_coo_ops;
}
struct  starpu_coo_interface
{
    ::starpu_data_interface_id id;
    ::uint32_t *columns;
    ::uint32_t *rows;
    ::uintptr_t values;
    ::uint32_t nx;
    ::uint32_t ny;
    ::uint32_t n_values;
    ::size_t elemsize;
};
extern "C"
{
  void starpu_coo_data_register(::starpu_data_handle_t *handleptr, int home_node, ::uint32_t nx, ::uint32_t ny, ::uint32_t n_values, ::uint32_t *columns, ::uint32_t *rows, ::uintptr_t values, ::size_t elemsize);
}
extern "C"
{
  extern ::starpu_data_interface_ops starpu_interface_block_ops;
}
struct  starpu_block_interface
{
    ::starpu_data_interface_id id;
    ::uintptr_t ptr;
    ::uintptr_t dev_handle;
    ::size_t offset;
    ::uint32_t nx;
    ::uint32_t ny;
    ::uint32_t nz;
    ::uint32_t ldy;
    ::uint32_t ldz;
    ::size_t elemsize;
};
extern "C"
{
  void starpu_block_data_register(::starpu_data_handle_t *handle, int home_node, ::uintptr_t ptr, ::uint32_t ldy, ::uint32_t ldz, ::uint32_t nx, ::uint32_t ny, ::uint32_t nz, ::size_t elemsize);
}
extern "C"
{
  void starpu_block_ptr_register(::starpu_data_handle_t handle, unsigned int node, ::uintptr_t ptr, ::uintptr_t dev_handle, ::size_t offset, ::uint32_t ldy, ::uint32_t ldz);
}
extern "C"
{
  ::uint32_t starpu_block_get_nx(::starpu_data_handle_t handle);
}
extern "C"
{
  ::uint32_t starpu_block_get_ny(::starpu_data_handle_t handle);
}
extern "C"
{
  ::uint32_t starpu_block_get_nz(::starpu_data_handle_t handle);
}
extern "C"
{
  ::uint32_t starpu_block_get_local_ldy(::starpu_data_handle_t handle);
}
extern "C"
{
  ::uint32_t starpu_block_get_local_ldz(::starpu_data_handle_t handle);
}
extern "C"
{
  ::uintptr_t starpu_block_get_local_ptr(::starpu_data_handle_t handle);
}
extern "C"
{
  ::size_t starpu_block_get_elemsize(::starpu_data_handle_t handle);
}
extern "C"
{
  extern ::starpu_data_interface_ops starpu_interface_vector_ops;
}
struct  starpu_vector_interface
{
    ::starpu_data_interface_id id;
    ::uintptr_t ptr;
    ::uintptr_t dev_handle;
    ::size_t offset;
    ::uint32_t nx;
    ::size_t elemsize;
    ::uint32_t slice_base;
};
extern "C"
{
  void starpu_vector_data_register(::starpu_data_handle_t *handle, int home_node, ::uintptr_t ptr, ::uint32_t nx, ::size_t elemsize);
}
extern "C"
{
  void starpu_vector_ptr_register(::starpu_data_handle_t handle, unsigned int node, ::uintptr_t ptr, ::uintptr_t dev_handle, ::size_t offset);
}
extern "C"
{
  ::uint32_t starpu_vector_get_nx(::starpu_data_handle_t handle);
}
extern "C"
{
  ::size_t starpu_vector_get_elemsize(::starpu_data_handle_t handle);
}
extern "C"
{
  ::uintptr_t starpu_vector_get_local_ptr(::starpu_data_handle_t handle);
}
extern "C"
{
  extern ::starpu_data_interface_ops starpu_interface_variable_ops;
}
struct  starpu_variable_interface
{
    ::starpu_data_interface_id id;
    ::uintptr_t ptr;
    ::uintptr_t dev_handle;
    ::size_t offset;
    ::size_t elemsize;
};
extern "C"
{
  void starpu_variable_data_register(::starpu_data_handle_t *handle, int home_node, ::uintptr_t ptr, ::size_t size);
}
extern "C"
{
  void starpu_variable_ptr_register(::starpu_data_handle_t handle, unsigned int node, ::uintptr_t ptr, ::uintptr_t dev_handle, ::size_t offset);
}
extern "C"
{
  ::size_t starpu_variable_get_elemsize(::starpu_data_handle_t handle);
}
extern "C"
{
  ::uintptr_t starpu_variable_get_local_ptr(::starpu_data_handle_t handle);
}
extern "C"
{
  extern ::starpu_data_interface_ops starpu_interface_void_ops;
}
extern "C"
{
  void starpu_void_data_register(::starpu_data_handle_t *handle);
}
extern "C"
{
  extern ::starpu_data_interface_ops starpu_interface_csr_ops;
}
struct  starpu_csr_interface
{
    ::starpu_data_interface_id id;
    ::uint32_t nnz;
    ::uint32_t nrow;
    ::uintptr_t nzval;
    ::uint32_t *colind;
    ::uint32_t *rowptr;
    ::uint32_t firstentry;
    ::size_t elemsize;
};
extern "C"
{
  void starpu_csr_data_register(::starpu_data_handle_t *handle, int home_node, ::uint32_t nnz, ::uint32_t nrow, ::uintptr_t nzval, ::uint32_t *colind, ::uint32_t *rowptr, ::uint32_t firstentry, ::size_t elemsize);
}
extern "C"
{
  ::uint32_t starpu_csr_get_nnz(::starpu_data_handle_t handle);
}
extern "C"
{
  ::uint32_t starpu_csr_get_nrow(::starpu_data_handle_t handle);
}
extern "C"
{
  ::uint32_t starpu_csr_get_firstentry(::starpu_data_handle_t handle);
}
extern "C"
{
  ::uintptr_t starpu_csr_get_local_nzval(::starpu_data_handle_t handle);
}
extern "C"
{
  ::uint32_t *starpu_csr_get_local_colind(::starpu_data_handle_t handle);
}
extern "C"
{
  ::uint32_t *starpu_csr_get_local_rowptr(::starpu_data_handle_t handle);
}
extern "C"
{
  ::size_t starpu_csr_get_elemsize(::starpu_data_handle_t handle);
}
extern "C"
{
  extern ::starpu_data_interface_ops starpu_interface_bcsr_ops;
}
struct  starpu_bcsr_interface
{
    ::starpu_data_interface_id id;
    ::uint32_t nnz;
    ::uint32_t nrow;
    ::uintptr_t nzval;
    ::uint32_t *colind;
    ::uint32_t *rowptr;
    ::uint32_t firstentry;
    ::uint32_t r;
    ::uint32_t c;
    ::size_t elemsize;
};
extern "C"
{
  void starpu_bcsr_data_register(::starpu_data_handle_t *handle, int home_node, ::uint32_t nnz, ::uint32_t nrow, ::uintptr_t nzval, ::uint32_t *colind, ::uint32_t *rowptr, ::uint32_t firstentry, ::uint32_t r, ::uint32_t c, ::size_t elemsize);
}
extern "C"
{
  ::uint32_t starpu_bcsr_get_nnz(::starpu_data_handle_t handle);
}
extern "C"
{
  ::uint32_t starpu_bcsr_get_nrow(::starpu_data_handle_t handle);
}
extern "C"
{
  ::uint32_t starpu_bcsr_get_firstentry(::starpu_data_handle_t handle);
}
extern "C"
{
  ::uintptr_t starpu_bcsr_get_local_nzval(::starpu_data_handle_t handle);
}
extern "C"
{
  ::uint32_t *starpu_bcsr_get_local_colind(::starpu_data_handle_t handle);
}
extern "C"
{
  ::uint32_t *starpu_bcsr_get_local_rowptr(::starpu_data_handle_t handle);
}
extern "C"
{
  ::uint32_t starpu_bcsr_get_r(::starpu_data_handle_t handle);
}
extern "C"
{
  ::uint32_t starpu_bcsr_get_c(::starpu_data_handle_t handle);
}
extern "C"
{
  ::size_t starpu_bcsr_get_elemsize(::starpu_data_handle_t handle);
}
struct  starpu_multiformat_data_interface_ops
{
    ::size_t cpu_elemsize;
    ::size_t opencl_elemsize;
    ::starpu_codelet *cpu_to_opencl_cl;
    ::starpu_codelet *opencl_to_cpu_cl;
    ::size_t cuda_elemsize;
    ::starpu_codelet *cpu_to_cuda_cl;
    ::starpu_codelet *cuda_to_cpu_cl;
    ::size_t mic_elemsize;
    ::starpu_codelet *cpu_to_mic_cl;
    ::starpu_codelet *mic_to_cpu_cl;
};
struct  starpu_multiformat_interface
{
    ::starpu_data_interface_id id;
    void *cpu_ptr;
    void *cuda_ptr;
    void *opencl_ptr;
    void *mic_ptr;
    ::uint32_t nx;
    ::starpu_multiformat_data_interface_ops *ops;
};
extern "C"
{
  void starpu_multiformat_data_register(::starpu_data_handle_t *handle, int home_node, void *ptr, ::uint32_t nobjects, ::starpu_multiformat_data_interface_ops *format_ops);
}
extern "C"
{
  ::starpu_data_interface_id starpu_data_get_interface_id(::starpu_data_handle_t handle);
}
extern "C"
{
  int starpu_data_pack(::starpu_data_handle_t handle, void **ptr, ::starpu_ssize_t *count);
}
extern "C"
{
  int starpu_data_unpack(::starpu_data_handle_t handle, void *ptr, ::size_t count);
}
extern "C"
{
  ::size_t starpu_data_get_size(::starpu_data_handle_t handle);
}
extern "C"
{
  ::starpu_data_handle_t starpu_data_lookup(const void *ptr);
}
struct starpu_data_filter;
struct  starpu_data_filter
{
    void (*filter_func)(void *, void *, ::starpu_data_filter *, unsigned int, unsigned int);
    unsigned int nchildren;
    unsigned int (*get_nchildren)(::starpu_data_filter *, ::starpu_data_handle_t);
    ::starpu_data_interface_ops *(*get_child_ops)(::starpu_data_filter *, unsigned int);
    unsigned int filter_arg;
    void *filter_arg_ptr;
};
extern "C"
{
  void starpu_data_partition(::starpu_data_handle_t initial_handle, ::starpu_data_filter *f);
}
extern "C"
{
  void starpu_data_unpartition(::starpu_data_handle_t root_data, unsigned int gathering_node);
}
extern "C"
{
  void starpu_data_partition_plan(::starpu_data_handle_t initial_handle, ::starpu_data_filter *f, ::starpu_data_handle_t *children);
}
extern "C"
{
  void starpu_data_partition_submit(::starpu_data_handle_t initial_handle, unsigned int nparts, ::starpu_data_handle_t *children);
}
extern "C"
{
  void starpu_data_partition_readonly_submit(::starpu_data_handle_t initial_handle, unsigned int nparts, ::starpu_data_handle_t *children);
}
extern "C"
{
  void starpu_data_partition_readwrite_upgrade_submit(::starpu_data_handle_t initial_handle, unsigned int nparts, ::starpu_data_handle_t *children);
}
extern "C"
{
  void starpu_data_unpartition_submit(::starpu_data_handle_t initial_handle, unsigned int nparts, ::starpu_data_handle_t *children, int gathering_node);
}
extern "C"
{
  void starpu_data_unpartition_readonly_submit(::starpu_data_handle_t initial_handle, unsigned int nparts, ::starpu_data_handle_t *children, int gathering_node);
}
extern "C"
{
  void starpu_data_partition_clean(::starpu_data_handle_t root_data, unsigned int nparts, ::starpu_data_handle_t *children);
}
extern "C"
{
  int starpu_data_get_nb_children(::starpu_data_handle_t handle);
}
extern "C"
{
  ::starpu_data_handle_t starpu_data_get_child(::starpu_data_handle_t handle, unsigned int i);
}
extern "C"
{
  ::starpu_data_handle_t starpu_data_get_sub_data(::starpu_data_handle_t root_data, unsigned int depth, ...);
}
extern "C"
{
  ::starpu_data_handle_t starpu_data_vget_sub_data(::starpu_data_handle_t root_data, unsigned int depth, ::va_list pa);
}
extern "C"
{
  void starpu_data_map_filters(::starpu_data_handle_t root_data, unsigned int nfilters, ...);
}
extern "C"
{
  void starpu_data_vmap_filters(::starpu_data_handle_t root_data, unsigned int nfilters, ::va_list pa);
}
extern "C"
{
  void starpu_bcsr_filter_canonical_block(void *father_interface, void *child_interface, ::starpu_data_filter *f, unsigned int id, unsigned int nparts);
}
extern "C"
{
  void starpu_csr_filter_vertical_block(void *father_interface, void *child_interface, ::starpu_data_filter *f, unsigned int id, unsigned int nparts);
}
extern "C"
{
  void starpu_matrix_filter_block(void *father_interface, void *child_interface, ::starpu_data_filter *f, unsigned int id, unsigned int nparts);
}
extern "C"
{
  void starpu_matrix_filter_block_shadow(void *father_interface, void *child_interface, ::starpu_data_filter *f, unsigned int id, unsigned int nparts);
}
extern "C"
{
  void starpu_matrix_filter_vertical_block(void *father_interface, void *child_interface, ::starpu_data_filter *f, unsigned int id, unsigned int nparts);
}
extern "C"
{
  void starpu_matrix_filter_vertical_block_shadow(void *father_interface, void *child_interface, ::starpu_data_filter *f, unsigned int id, unsigned int nparts);
}
extern "C"
{
  void starpu_vector_filter_block(void *father_interface, void *child_interface, ::starpu_data_filter *f, unsigned int id, unsigned int nparts);
}
extern "C"
{
  void starpu_vector_filter_block_shadow(void *father_interface, void *child_interface, ::starpu_data_filter *f, unsigned int id, unsigned int nparts);
}
extern "C"
{
  void starpu_vector_filter_list_long(void *father_interface, void *child_interface, ::starpu_data_filter *f, unsigned int id, unsigned int nparts);
}
extern "C"
{
  void starpu_vector_filter_list(void *father_interface, void *child_interface, ::starpu_data_filter *f, unsigned int id, unsigned int nparts);
}
extern "C"
{
  void starpu_vector_filter_divide_in_2(void *father_interface, void *child_interface, ::starpu_data_filter *f, unsigned int id, unsigned int nparts);
}
extern "C"
{
  void starpu_block_filter_block(void *father_interface, void *child_interface, ::starpu_data_filter *f, unsigned int id, unsigned int nparts);
}
extern "C"
{
  void starpu_block_filter_block_shadow(void *father_interface, void *child_interface, ::starpu_data_filter *f, unsigned int id, unsigned int nparts);
}
extern "C"
{
  void starpu_block_filter_vertical_block(void *father_interface, void *child_interface, ::starpu_data_filter *f, unsigned int id, unsigned int nparts);
}
extern "C"
{
  void starpu_block_filter_vertical_block_shadow(void *father_interface, void *child_interface, ::starpu_data_filter *f, unsigned int id, unsigned int nparts);
}
extern "C"
{
  void starpu_block_filter_depth_block(void *father_interface, void *child_interface, ::starpu_data_filter *f, unsigned int id, unsigned int nparts);
}
extern "C"
{
  void starpu_block_filter_depth_block_shadow(void *father_interface, void *child_interface, ::starpu_data_filter *f, unsigned int id, unsigned int nparts);
}
extern "C"
{
  void starpu_malloc_set_align(::size_t align);
}
extern "C"
{
  int starpu_malloc(void **A, ::size_t dim) __attribute__((alloc_size(2)));
}
extern "C"
{
  int starpu_free(void *A);
}
extern "C"
{
  int starpu_malloc_flags(void **A, ::size_t dim, int flags) __attribute__((alloc_size(2)));
}
extern "C"
{
  int starpu_free_flags(void *A, ::size_t dim, int flags);
}
extern "C"
{
  int starpu_memory_pin(void *addr, ::size_t size);
}
extern "C"
{
  int starpu_memory_unpin(void *addr, ::size_t size);
}
extern "C"
{
  ::starpu_ssize_t starpu_memory_get_total(unsigned int node);
}
extern "C"
{
  ::starpu_ssize_t starpu_memory_get_available(unsigned int node);
}
extern "C"
{
  void starpu_memory_wait_available(unsigned int node, ::size_t size);
}
extern "C"
{
  int starpu_memory_allocate(unsigned int node, ::size_t size, int flags);
}
extern "C"
{
  void starpu_memory_deallocate(unsigned int node, ::size_t size);
}
extern "C"
{
  void starpu_sleep(float nb_sec);
}
enum starpu_worker_archtype
{
  STARPU_CPU_WORKER = 0,
  STARPU_CUDA_WORKER = 1,
  STARPU_OPENCL_WORKER = 2,
  STARPU_MIC_WORKER = 3,
  STARPU_SCC_WORKER = 4,
  STARPU_ANY_WORKER = 5
};
struct  starpu_sched_ctx_iterator
{
    int cursor;
    void *value;
    void *possible_value;
    char visited[80L];
};
enum starpu_worker_collection_type
{
  STARPU_WORKER_TREE = 0,
  STARPU_WORKER_LIST = 1
};
struct starpu_worker_collection;
struct  starpu_worker_collection
{
    int *workerids;
    void *collection_private;
    unsigned int nworkers;
    void *masters;
    unsigned int nmasters;
    char present[80L];
    char is_master[80L];
    ::starpu_worker_collection_type type;
    unsigned int (*has_next)(::starpu_worker_collection *, ::starpu_sched_ctx_iterator *);
    int (*get_next)(::starpu_worker_collection *, ::starpu_sched_ctx_iterator *);
    unsigned int (*has_next_master)(::starpu_worker_collection *, ::starpu_sched_ctx_iterator *);
    int (*get_next_master)(::starpu_worker_collection *, ::starpu_sched_ctx_iterator *);
    int (*add)(::starpu_worker_collection *, int);
    int (*remove)(::starpu_worker_collection *, int);
    void (*init)(::starpu_worker_collection *);
    void (*deinit)(::starpu_worker_collection *);
    void (*init_iterator)(::starpu_worker_collection *, ::starpu_sched_ctx_iterator *);
};
extern "C"
{
  extern ::starpu_worker_collection worker_list;
}
extern "C"
{
  extern ::starpu_worker_collection worker_tree;
}
extern "C"
{
  unsigned int starpu_worker_get_count();
}
extern "C"
{
  unsigned int starpu_combined_worker_get_count();
}
extern "C"
{
  unsigned int starpu_worker_is_combined_worker(int id);
}
extern "C"
{
  unsigned int starpu_cpu_worker_get_count();
}
extern "C"
{
  unsigned int starpu_cuda_worker_get_count();
}
extern "C"
{
  unsigned int starpu_opencl_worker_get_count();
}
extern "C"
{
  unsigned int starpu_mic_worker_get_count();
}
extern "C"
{
  unsigned int starpu_scc_worker_get_count();
}
extern "C"
{
  unsigned int starpu_mic_device_get_count();
}
extern "C"
{
  int starpu_worker_get_id();
}
extern "C"
{
  unsigned int _starpu_worker_get_id_check(const char *f, int l);
}
extern "C"
{
  unsigned int starpu_worker_get_id_check();
}
extern "C"
{
  int starpu_worker_get_bindid(int workerid);
}
extern "C"
{
  int starpu_combined_worker_get_id();
}
extern "C"
{
  int starpu_combined_worker_get_size();
}
extern "C"
{
  int starpu_combined_worker_get_rank();
}
extern "C"
{
  ::starpu_worker_archtype starpu_worker_get_type(int id);
}
extern "C"
{
  int starpu_worker_get_count_by_type(::starpu_worker_archtype type);
}
extern "C"
{
  int starpu_worker_get_ids_by_type(::starpu_worker_archtype type, int *workerids, int maxsize);
}
extern "C"
{
  int starpu_worker_get_by_type(::starpu_worker_archtype type, int num);
}
extern "C"
{
  int starpu_worker_get_by_devid(::starpu_worker_archtype type, int devid);
}
extern "C"
{
  void starpu_worker_get_name(int id, char *dst, ::size_t maxlen);
}
extern "C"
{
  int starpu_worker_get_devid(int id);
}
extern "C"
{
  int starpu_worker_get_mp_nodeid(int id);
}
struct starpu_tree;
extern "C"
{
  ::starpu_tree *starpu_workers_get_tree();
}
extern "C"
{
  unsigned int starpu_worker_get_sched_ctx_list(int worker, unsigned int **sched_ctx);
}
extern "C"
{
  unsigned int starpu_worker_is_slave(int workerid);
}
extern "C"
{
  char *starpu_worker_get_type_as_string(::starpu_worker_archtype type);
}
struct  starpu_perfmodel_device
{
    ::starpu_worker_archtype type;
    int devid;
    int ncores;
};
struct  starpu_perfmodel_arch
{
    int ndevices;
    ::starpu_perfmodel_device *devices;
};
struct  starpu_perfmodel_history_entry
{
    double mean;
    double deviation;
    double sum;
    double sum2;
    unsigned int nsample;
    unsigned int nerror;
    ::uint32_t footprint;
    ::size_t size;
    double flops;
};
struct starpu_perfmodel_history_list;
struct  starpu_perfmodel_history_list
{
    ::starpu_perfmodel_history_list *next;
    ::starpu_perfmodel_history_entry *entry;
};
struct  starpu_perfmodel_regression_model
{
    double sumlny;
    double sumlnx;
    double sumlnx2;
    unsigned long int minx;
    unsigned long int maxx;
    double sumlnxlny;
    double alpha;
    double beta;
    unsigned int valid;
    double a;
    double b;
    double c;
    unsigned int nl_valid;
    unsigned int nsample;
};
struct starpu_perfmodel_history_table;
typedef double (*starpu_perfmodel_per_arch_cost_function)(::starpu_task *, ::starpu_perfmodel_arch *, unsigned int);
typedef ::size_t (*starpu_perfmodel_per_arch_size_base)(::starpu_task *, ::starpu_perfmodel_arch *, unsigned int);
struct  starpu_perfmodel_per_arch
{
    ::starpu_perfmodel_per_arch_cost_function cost_function;
    ::starpu_perfmodel_per_arch_size_base size_base;
    ::starpu_perfmodel_history_table *history;
    ::starpu_perfmodel_history_list *list;
    ::starpu_perfmodel_regression_model regression;
    char debug_path[256L];
};
enum starpu_perfmodel_type
{
  STARPU_PERFMODEL_INVALID = 0,
  STARPU_PER_ARCH = 1,
  STARPU_COMMON = 2,
  STARPU_HISTORY_BASED = 3,
  STARPU_REGRESSION_BASED = 4,
  STARPU_NL_REGRESSION_BASED = 5
};
struct _starpu_perfmodel_state;
typedef ::_starpu_perfmodel_state *starpu_perfmodel_state_t;
struct  starpu_perfmodel
{
    ::starpu_perfmodel_type type;
    double (*cost_function)(::starpu_task *, unsigned int);
    double (*arch_cost_function)(::starpu_task *, ::starpu_perfmodel_arch *, unsigned int);
    ::size_t (*size_base)(::starpu_task *, unsigned int);
    ::uint32_t (*footprint)(::starpu_task *);
    const char *symbol;
    unsigned int is_loaded;
    unsigned int benchmarking;
    unsigned int is_init;
    ::starpu_perfmodel_state_t state;
};
extern "C"
{
  void starpu_perfmodel_init(::starpu_perfmodel *model);
}
extern "C"
{
  int starpu_perfmodel_load_file(const char *filename, ::starpu_perfmodel *model);
}
extern "C"
{
  int starpu_perfmodel_load_symbol(const char *symbol, ::starpu_perfmodel *model);
}
extern "C"
{
  int starpu_perfmodel_unload_model(::starpu_perfmodel *model);
}
extern "C"
{
  void starpu_perfmodel_get_model_path(const char *symbol, char *path, ::size_t maxlen);
}
extern "C"
{
  void starpu_perfmodel_free_sampling_directories();
}
extern "C"
{
  ::starpu_perfmodel_arch *starpu_worker_get_perf_archtype(int workerid, unsigned int sched_ctx_id);
}
extern "C"
{
  int starpu_perfmodel_get_narch_combs();
}
extern "C"
{
  int starpu_perfmodel_arch_comb_add(int ndevices, ::starpu_perfmodel_device *devices);
}
extern "C"
{
  int starpu_perfmodel_arch_comb_get(int ndevices, ::starpu_perfmodel_device *devices);
}
extern "C"
{
  ::starpu_perfmodel_arch *starpu_perfmodel_arch_comb_fetch(int comb);
}
extern "C"
{
  ::starpu_perfmodel_per_arch *starpu_perfmodel_get_model_per_arch(::starpu_perfmodel *model, ::starpu_perfmodel_arch *arch, unsigned int impl);
}
extern "C"
{
  ::starpu_perfmodel_per_arch *starpu_perfmodel_get_model_per_devices(::starpu_perfmodel *model, int impl, ...);
}
extern "C"
{
  int starpu_perfmodel_set_per_devices_cost_function(::starpu_perfmodel *model, int impl, ::starpu_perfmodel_per_arch_cost_function func, ...);
}
extern "C"
{
  int starpu_perfmodel_set_per_devices_size_base(::starpu_perfmodel *model, int impl, ::starpu_perfmodel_per_arch_size_base func, ...);
}
extern "C"
{
  void starpu_perfmodel_debugfilepath(::starpu_perfmodel *model, ::starpu_perfmodel_arch *arch, char *path, ::size_t maxlen, unsigned int nimpl);
}
extern "C"
{
  char *starpu_perfmodel_get_archtype_name(::starpu_worker_archtype archtype);
}
extern "C"
{
  void starpu_perfmodel_get_arch_name(::starpu_perfmodel_arch *arch, char *archname, ::size_t maxlen, unsigned int nimpl);
}
extern "C"
{
  double starpu_perfmodel_history_based_expected_perf(::starpu_perfmodel *model, ::starpu_perfmodel_arch *arch, ::uint32_t footprint);
}
extern "C"
{
  void starpu_perfmodel_initialize();
}
extern "C"
{
  int starpu_perfmodel_list(::FILE *output);
}
extern "C"
{
  void starpu_perfmodel_print(::starpu_perfmodel *model, ::starpu_perfmodel_arch *arch, unsigned int nimpl, char *parameter, ::uint32_t *footprint, ::FILE *output);
}
extern "C"
{
  int starpu_perfmodel_print_all(::starpu_perfmodel *model, char *arch, char *parameter, ::uint32_t *footprint, ::FILE *output);
}
extern "C"
{
  int starpu_perfmodel_print_estimations(::starpu_perfmodel *model, ::uint32_t footprint, ::FILE *output);
}
extern "C"
{
  int starpu_perfmodel_list_combs(::FILE *output, ::starpu_perfmodel *model);
}
extern "C"
{
  void starpu_perfmodel_update_history(::starpu_perfmodel *model, ::starpu_task *task, ::starpu_perfmodel_arch *arch, unsigned int cpuid, unsigned int nimpl, double measured);
}
extern "C"
{
  void starpu_perfmodel_directory(::FILE *output);
}
extern "C"
{
  void starpu_bus_print_bandwidth(::FILE *f);
}
extern "C"
{
  void starpu_bus_print_affinity(::FILE *f);
}
extern "C"
{
  void starpu_bus_print_filenames(::FILE *f);
}
extern "C"
{
  double starpu_transfer_bandwidth(unsigned int src_node, unsigned int dst_node);
}
extern "C"
{
  double starpu_transfer_latency(unsigned int src_node, unsigned int dst_node);
}
extern "C"
{
  double starpu_transfer_predict(unsigned int src_node, unsigned int dst_node, ::size_t size);
}
struct  starpu_task_list
{
    ::starpu_task *head;
    ::starpu_task *tail;
};
extern "C"
{
  static inline void starpu_task_list_init(::starpu_task_list *list)
  {
    (*list).head = 0L;
    (*list).tail = 0L;
  }
}
extern "C"
{
  static inline void starpu_task_list_push_front(::starpu_task_list *list, ::starpu_task *task)
  {
    if ((*list).tail == 0L)
      {
        (*list).tail = task;
      }
    else
      {
        (*(*list).head).prev = task;
      }
    (*task).prev = 0L;
    (*task).next = (*list).head;
    (*list).head = task;
  }
}
extern "C"
{
  static inline void starpu_task_list_push_back(::starpu_task_list *list, ::starpu_task *task)
  {
    if ((*list).head == 0L)
      {
        (*list).head = task;
      }
    else
      {
        (*(*list).tail).next = task;
      }
    (*task).next = 0L;
    (*task).prev = (*list).tail;
    (*list).tail = task;
  }
}
extern "C"
{
  static inline ::starpu_task *starpu_task_list_front(::starpu_task_list *list)
  {
    return (*list).head;
  }
}
extern "C"
{
  static inline ::starpu_task *starpu_task_list_back(::starpu_task_list *list)
  {
    return (*list).tail;
  }
}
extern "C"
{
  static inline int starpu_task_list_empty(::starpu_task_list *list)
  {
    return (*list).head == 0L;
  }
}
extern "C"
{
  static inline void starpu_task_list_erase(::starpu_task_list *list, ::starpu_task *task)
  {
    ::starpu_task *p((*task).prev);
    if (p)
      {
        (*p).next = (*task).next;
      }
    else
      {
        (*list).head = (*task).next;
      }
    if ((*task).next)
      {
        (*(*task).next).prev = p;
      }
    else
      {
        (*list).tail = p;
      }
    (*task).prev = 0L;
    (*task).next = 0L;
  }
}
extern "C"
{
  static inline ::starpu_task *starpu_task_list_pop_front(::starpu_task_list *list)
  {
    ::starpu_task *task((*list).head);
    if (task)
      {
        ::starpu_task_list_erase(list, task);
      }
    return task;
  }
}
extern "C"
{
  static inline ::starpu_task *starpu_task_list_pop_back(::starpu_task_list *list)
  {
    ::starpu_task *task((*list).tail);
    if (task)
      {
        ::starpu_task_list_erase(list, task);
      }
    return task;
  }
}
extern "C"
{
  static inline ::starpu_task *starpu_task_list_begin(::starpu_task_list *list)
  {
    return (*list).head;
  }
}
extern "C"
{
  static inline ::starpu_task *starpu_task_list_end(::starpu_task_list *list __attribute__((unused)))
  {
    return 0L;
  }
}
extern "C"
{
  static inline ::starpu_task *starpu_task_list_next(::starpu_task *task)
  {
    return (*task).next;
  }
}
extern "C"
{
  static inline int starpu_task_list_ismember(::starpu_task_list *list, ::starpu_task *look)
  {
    ::starpu_task *task;
    for (task = (*list).head; task != 0L; task = (*task).next)
      {
        if (task == look)
          {
            return 1;
          }
      }
    return 0;
  }
}
extern "C"
{
  void starpu_create_sync_task(::starpu_tag_t sync_tag, unsigned int ndeps, ::starpu_tag_t *deps, void (*callback)(void *), void *callback_arg);
}
extern "C"
{
  ::starpu_task *starpu_task_build(::starpu_codelet *cl, ...);
}
extern "C"
{
  int starpu_task_insert(::starpu_codelet *cl, ...);
}
extern "C"
{
  int starpu_insert_task(::starpu_codelet *cl, ...);
}
extern "C"
{
  void starpu_codelet_unpack_args(void *cl_arg, ...);
}
extern "C"
{
  void starpu_codelet_unpack_args_and_copyleft(void *cl_arg, void *buffer, ::size_t buffer_size, ...);
}
extern "C"
{
  void starpu_codelet_pack_args(void **arg_buffer, ::size_t *arg_buffer_size, ...);
}
extern "C"
{
  unsigned int starpu_sched_ctx_create(int *workerids_ctx, int nworkers_ctx, const char *sched_ctx_name, ...);
}
extern "C"
{
  unsigned int starpu_sched_ctx_create_inside_interval(const char *policy_name, const char *sched_ctx_name, int min_ncpus, int max_ncpus, int min_ngpus, int max_ngpus, unsigned int allow_overlap);
}
extern "C"
{
  void starpu_sched_ctx_register_close_callback(unsigned int sched_ctx_id, void (*close_callback)(unsigned int, void *), void *args);
}
extern "C"
{
  void starpu_sched_ctx_add_workers(int *workerids_ctx, int nworkers_ctx, unsigned int sched_ctx_id);
}
extern "C"
{
  void starpu_sched_ctx_remove_workers(int *workerids_ctx, int nworkers_ctx, unsigned int sched_ctx_id);
}
extern "C"
{
  void starpu_sched_ctx_display_workers(unsigned int sched_ctx_id, ::FILE *f);
}
extern "C"
{
  void starpu_sched_ctx_delete(unsigned int sched_ctx_id);
}
extern "C"
{
  void starpu_sched_ctx_set_inheritor(unsigned int sched_ctx_id, unsigned int inheritor);
}
extern "C"
{
  unsigned int starpu_sched_ctx_get_inheritor(unsigned int sched_ctx_id);
}
extern "C"
{
  unsigned int starpu_sched_ctx_get_hierarchy_level(unsigned int sched_ctx_id);
}
extern "C"
{
  void starpu_sched_ctx_set_context(unsigned int *sched_ctx_id);
}
extern "C"
{
  unsigned int starpu_sched_ctx_get_context();
}
extern "C"
{
  void starpu_sched_ctx_stop_task_submission();
}
extern "C"
{
  void starpu_sched_ctx_finished_submit(unsigned int sched_ctx_id);
}
extern "C"
{
  unsigned int starpu_sched_ctx_get_workers_list(unsigned int sched_ctx_id, int **workerids);
}
extern "C"
{
  unsigned int starpu_sched_ctx_get_workers_list_raw(unsigned int sched_ctx_id, int **workerids);
}
extern "C"
{
  unsigned int starpu_sched_ctx_get_nworkers(unsigned int sched_ctx_id);
}
extern "C"
{
  unsigned int starpu_sched_ctx_get_nshared_workers(unsigned int sched_ctx_id, unsigned int sched_ctx_id2);
}
extern "C"
{
  unsigned int starpu_sched_ctx_contains_worker(int workerid, unsigned int sched_ctx_id);
}
extern "C"
{
  unsigned int starpu_sched_ctx_contains_type_of_worker(::starpu_worker_archtype arch, unsigned int sched_ctx_id);
}
extern "C"
{
  unsigned int starpu_sched_ctx_worker_get_id(unsigned int sched_ctx_id);
}
extern "C"
{
  unsigned int starpu_sched_ctx_overlapping_ctxs_on_worker(int workerid);
}
extern "C"
{
  int starpu_sched_get_min_priority();
}
extern "C"
{
  int starpu_sched_get_max_priority();
}
extern "C"
{
  int starpu_sched_set_min_priority(int min_prio);
}
extern "C"
{
  int starpu_sched_set_max_priority(int max_prio);
}
extern "C"
{
  int starpu_sched_ctx_get_min_priority(unsigned int sched_ctx_id);
}
extern "C"
{
  int starpu_sched_ctx_get_max_priority(unsigned int sched_ctx_id);
}
extern "C"
{
  int starpu_sched_ctx_set_min_priority(unsigned int sched_ctx_id, int min_prio);
}
extern "C"
{
  int starpu_sched_ctx_set_max_priority(unsigned int sched_ctx_id, int max_prio);
}
extern "C"
{
  int starpu_sched_ctx_min_priority_is_set(unsigned int sched_ctx_id);
}
extern "C"
{
  int starpu_sched_ctx_max_priority_is_set(unsigned int sched_ctx_id);
}
extern "C"
{
  ::starpu_worker_collection *starpu_sched_ctx_create_worker_collection(unsigned int sched_ctx_id, ::starpu_worker_collection_type type) __attribute__((malloc));
}
extern "C"
{
  void starpu_sched_ctx_delete_worker_collection(unsigned int sched_ctx_id);
}
extern "C"
{
  ::starpu_worker_collection *starpu_sched_ctx_get_worker_collection(unsigned int sched_ctx_id);
}
extern "C"
{
  void starpu_sched_ctx_set_policy_data(unsigned int sched_ctx_id, void *policy_data);
}
extern "C"
{
  void *starpu_sched_ctx_get_policy_data(unsigned int sched_ctx_id);
}
extern "C"
{
  void *starpu_sched_ctx_exec_parallel_code(void *(*func)(void *), void *param, unsigned int sched_ctx_id);
}
extern "C"
{
  int starpu_sched_ctx_get_nready_tasks(unsigned int sched_ctx_id);
}
extern "C"
{
  double starpu_sched_ctx_get_nready_flops(unsigned int sched_ctx_id);
}
extern "C"
{
  void starpu_sched_ctx_set_priority(int *workers, int nworkers, unsigned int sched_ctx_id, unsigned int priority);
}
extern "C"
{
  void starpu_sched_ctx_set_priority_on_level(int *workers_to_add, unsigned int nworkers_to_add, unsigned int sched_ctx, unsigned int priority);
}
extern "C"
{
  unsigned int starpu_sched_ctx_get_priority(int worker, unsigned int sched_ctx_id);
}
extern "C"
{
  void starpu_sched_ctx_get_available_cpuids(unsigned int sched_ctx_id, int **cpuids, int *ncpuids);
}
extern "C"
{
  void starpu_sched_ctx_bind_current_thread_to_cpuid(unsigned int cpuid);
}
extern "C"
{
  int starpu_sched_ctx_book_workers_for_task(unsigned int sched_ctx_id, int *workerids, int nworkers);
}
extern "C"
{
  void starpu_sched_ctx_unbook_workers_for_task(unsigned int sched_ctx_id, int master);
}
extern "C"
{
  unsigned int starpu_sched_ctx_worker_is_master_for_child_ctx(int workerid, unsigned int sched_ctx_id);
}
extern "C"
{
  void starpu_sched_ctx_revert_task_counters(unsigned int sched_ctx_id, double flops);
}
extern "C"
{
  void starpu_sched_ctx_move_task_to_ctx(::starpu_task *task, unsigned int sched_ctx);
}
extern "C"
{
  int starpu_sched_ctx_get_worker_rank(unsigned int sched_ctx_id);
}
extern "C"
{
  void starpu_wake_all_blocked_workers();
}
extern "C"
{
  int starpu_progression_hook_register(unsigned int (*func)(void *), void *arg);
}
extern "C"
{
  void starpu_progression_hook_deregister(int hook_id);
}
typedef ::drand48_data starpu_drand48_data;
extern "C"
{
  void starpu_cublas_init();
}
extern "C"
{
  void starpu_cublas_shutdown();
}
extern "C"
{
  void starpu_cusparse_init();
}
extern "C"
{
  void starpu_cusparse_shutdown();
}
extern "C"
{
  void starpu_bound_start(int deps, int prio);
}
extern "C"
{
  void starpu_bound_stop();
}
extern "C"
{
  void starpu_bound_print_dot(::FILE *output);
}
extern "C"
{
  void starpu_bound_compute(double *res, double *integer_res, int integer);
}
extern "C"
{
  void starpu_bound_print_lp(::FILE *output);
}
extern "C"
{
  void starpu_bound_print_mps(::FILE *output);
}
extern "C"
{
  void starpu_bound_print(::FILE *output, int integer);
}
extern "C"
{
  ::uint32_t starpu_hash_crc32c_be_n(const void *input, ::size_t n, ::uint32_t inputcrc);
}
extern "C"
{
  ::uint32_t starpu_hash_crc32c_be(::uint32_t input, ::uint32_t inputcrc);
}
extern "C"
{
  ::uint32_t starpu_hash_crc32c_string(const char *str, ::uint32_t inputcrc);
}
struct  starpu_profiling_task_info
{
    ::timespec submit_time;
    ::timespec push_start_time;
    ::timespec push_end_time;
    ::timespec pop_start_time;
    ::timespec pop_end_time;
    ::timespec acquire_data_start_time;
    ::timespec acquire_data_end_time;
    ::timespec start_time;
    ::timespec end_time;
    ::timespec release_data_start_time;
    ::timespec release_data_end_time;
    ::timespec callback_start_time;
    ::timespec callback_end_time;
    int workerid;
    ::uint64_t used_cycles;
    ::uint64_t stall_cycles;
    double energy_consumed;
};
struct  starpu_profiling_worker_info
{
    ::timespec start_time;
    ::timespec total_time;
    ::timespec executing_time;
    ::timespec sleeping_time;
    int executed_tasks;
    ::uint64_t used_cycles;
    ::uint64_t stall_cycles;
    double energy_consumed;
};
struct  starpu_profiling_bus_info
{
    ::timespec start_time;
    ::timespec total_time;
    long long int transferred_bytes;
    int transfer_count;
};
extern "C"
{
  void starpu_profiling_init();
}
extern "C"
{
  void starpu_profiling_set_id(int new_id);
}
extern "C"
{
  int starpu_profiling_status_set(int status);
}
extern "C"
{
  int starpu_profiling_status_get();
}
extern "C"
{
  int starpu_profiling_worker_get_info(int workerid, ::starpu_profiling_worker_info *worker_info);
}
extern "C"
{
  int starpu_bus_get_count();
}
extern "C"
{
  int starpu_bus_get_id(int src, int dst);
}
extern "C"
{
  int starpu_bus_get_src(int busid);
}
extern "C"
{
  int starpu_bus_get_dst(int busid);
}
extern "C"
{
  int starpu_bus_get_profiling_info(int busid, ::starpu_profiling_bus_info *bus_info);
}
extern "C"
{
  static inline void starpu_timespec_clear(::timespec *tsp)
  {
    (*tsp).tv_sec = 0;
    (*tsp).tv_nsec = 0;
  }
}
extern "C"
{
  static inline void starpu_timespec_add(::timespec *a, ::timespec *b, ::timespec *result)
  {
    (*result).tv_sec = (*a).tv_sec + (*b).tv_sec;
    (*result).tv_nsec = (*a).tv_nsec + (*b).tv_nsec;
    if ((*result).tv_nsec >= 1000000000)
      {
         ++(*result).tv_sec;
        (*result).tv_nsec -= 1000000000;
      }
  }
}
extern "C"
{
  static inline void starpu_timespec_accumulate(::timespec *result, ::timespec *a)
  {
    (*result).tv_sec += (*a).tv_sec;
    (*result).tv_nsec += (*a).tv_nsec;
    if ((*result).tv_nsec >= 1000000000)
      {
         ++(*result).tv_sec;
        (*result).tv_nsec -= 1000000000;
      }
  }
}
extern "C"
{
  static inline void starpu_timespec_sub(const ::timespec *a, const ::timespec *b, ::timespec *result)
  {
    (*result).tv_sec = (*a).tv_sec - (*b).tv_sec;
    (*result).tv_nsec = (*a).tv_nsec - (*b).tv_nsec;
    if ((*result).tv_nsec < 0)
      {
         --(*result).tv_sec;
        (*result).tv_nsec += 1000000000;
      }
  }
}
extern "C"
{
  double starpu_timing_timespec_delay_us(::timespec *start, ::timespec *end);
}
extern "C"
{
  double starpu_timing_timespec_to_us(::timespec *ts);
}
extern "C"
{
  void starpu_profiling_bus_helper_display_summary();
}
extern "C"
{
  void starpu_profiling_worker_helper_display_summary();
}
enum starpu_top_data_type
{
  STARPU_TOP_DATA_BOOLEAN = 0,
  STARPU_TOP_DATA_INTEGER = 1,
  STARPU_TOP_DATA_FLOAT = 2
};
struct starpu_top_data;
struct  starpu_top_data
{
    unsigned int id;
    const char *name;
    int int_min_value;
    int int_max_value;
    double double_min_value;
    double double_max_value;
    int active;
    ::starpu_top_data_type type;
    ::starpu_top_data *next;
};
enum starpu_top_param_type
{
  STARPU_TOP_PARAM_BOOLEAN = 0,
  STARPU_TOP_PARAM_INTEGER = 1,
  STARPU_TOP_PARAM_FLOAT = 2,
  STARPU_TOP_PARAM_ENUM = 3
};
struct starpu_top_param;
struct  starpu_top_param
{
    unsigned int id;
    const char *name;
    ::starpu_top_param_type type;
    void *value;
    char **enum_values;
    int nb_values;
    void (*callback)(::starpu_top_param *);
    int int_min_value;
    int int_max_value;
    double double_min_value;
    double double_max_value;
    ::starpu_top_param *next;
};
enum starpu_top_message_type
{
  TOP_TYPE_GO = 0,
  TOP_TYPE_SET = 1,
  TOP_TYPE_CONTINUE = 2,
  TOP_TYPE_ENABLE = 3,
  TOP_TYPE_DISABLE = 4,
  TOP_TYPE_DEBUG = 5,
  TOP_TYPE_UNKNOW = 6
};
extern "C"
{
  ::starpu_top_data *starpu_top_add_data_boolean(const char *data_name, int active);
}
extern "C"
{
  ::starpu_top_data *starpu_top_add_data_integer(const char *data_name, int minimum_value, int maximum_value, int active);
}
extern "C"
{
  ::starpu_top_data *starpu_top_add_data_float(const char *data_name, double minimum_value, double maximum_value, int active);
}
extern "C"
{
  ::starpu_top_param *starpu_top_register_parameter_boolean(const char *param_name, int *parameter_field, void (*callback)(::starpu_top_param *));
}
extern "C"
{
  ::starpu_top_param *starpu_top_register_parameter_integer(const char *param_name, int *parameter_field, int minimum_value, int maximum_value, void (*callback)(::starpu_top_param *));
}
extern "C"
{
  ::starpu_top_param *starpu_top_register_parameter_float(const char *param_name, double *parameter_field, double minimum_value, double maximum_value, void (*callback)(::starpu_top_param *));
}
extern "C"
{
  ::starpu_top_param *starpu_top_register_parameter_enum(const char *param_name, int *parameter_field, char **values, int nb_values, void (*callback)(::starpu_top_param *));
}
extern "C"
{
  void starpu_top_init_and_wait(const char *server_name);
}
extern "C"
{
  void starpu_top_update_parameter(const ::starpu_top_param *param);
}
extern "C"
{
  void starpu_top_update_data_boolean(const ::starpu_top_data *data, int value);
}
extern "C"
{
  void starpu_top_update_data_integer(const ::starpu_top_data *data, int value);
}
extern "C"
{
  void starpu_top_update_data_float(const ::starpu_top_data *data, double value);
}
extern "C"
{
  void starpu_top_task_prevision(::starpu_task *task, int devid, unsigned long long int start, unsigned long long int end);
}
extern "C"
{
  void starpu_top_debug_log(const char *message);
}
extern "C"
{
  void starpu_top_debug_lock(const char *message);
}
struct  starpu_fxt_codelet_event
{
    char symbol[256L];
    int workerid;
    char perfmodel_archname[256L];
    ::uint32_t hash;
    ::size_t size;
    float time;
};
struct  starpu_fxt_options
{
    unsigned int per_task_colour;
    unsigned int no_events;
    unsigned int no_counter;
    unsigned int no_bus;
    unsigned int no_flops;
    unsigned int ninputfiles;
    char *filenames[64L];
    char *out_paje_path;
    char *distrib_time_path;
    char *activity_path;
    char *dag_path;
    char *tasks_path;
    char *data_path;
    char *anim_path;
    char *file_prefix;
    ::uint64_t file_offset;
    int file_rank;
    char worker_names[80L][256L];
    ::starpu_perfmodel_arch worker_archtypes[80L];
    int nworkers;
    ::starpu_fxt_codelet_event **dumped_codelets;
    long int dumped_codelets_count;
};
extern "C"
{
  void starpu_fxt_options_init(::starpu_fxt_options *options);
}
extern "C"
{
  void starpu_fxt_generate_trace(::starpu_fxt_options *options);
}
extern "C"
{
  void starpu_fxt_autostart_profiling(int autostart);
}
extern "C"
{
  void starpu_fxt_start_profiling();
}
extern "C"
{
  void starpu_fxt_stop_profiling();
}
extern "C"
{
  void starpu_fxt_write_data_trace(char *filename_in);
}
extern "C"
{
  void starpu_fxt_trace_user_event(unsigned long int code);
}
extern "C"
{
  void starpu_fxt_trace_user_event_string(const char *s);
}
struct  starpu_driver
{
    ::starpu_worker_archtype type;
    union  mcc_union_anon_210
    {
        unsigned int cpu_id;
        unsigned int cuda_id;
        ::cl_device_id opencl_id;
    };
    ::starpu_driver::mcc_union_anon_210 id;
};
extern "C"
{
  int starpu_driver_run(::starpu_driver *d);
}
extern "C"
{
  void starpu_drivers_request_termination();
}
extern "C"
{
  int starpu_driver_init(::starpu_driver *d);
}
extern "C"
{
  int starpu_driver_run_once(::starpu_driver *d);
}
extern "C"
{
  int starpu_driver_deinit(::starpu_driver *d);
}
struct  starpu_tree
{
    ::starpu_tree *nodes;
    ::starpu_tree *father;
    int arity;
    int id;
    int level;
    int is_pu;
};
extern "C"
{
  void starpu_tree_reset_visited(::starpu_tree *tree, char *visited);
}
extern "C"
{
  void starpu_tree_prepare_children(unsigned int arity, ::starpu_tree *father);
}
extern "C"
{
  void starpu_tree_insert(::starpu_tree *tree, int id, int level, int is_pu, int arity, ::starpu_tree *father);
}
extern "C"
{
  ::starpu_tree *starpu_tree_get(::starpu_tree *tree, int id);
}
extern "C"
{
  ::starpu_tree *starpu_tree_get_neighbour(::starpu_tree *tree, ::starpu_tree *node, char *visited, char *present);
}
extern "C"
{
  void starpu_tree_free(::starpu_tree *tree);
}
struct  starpu_omp_lock_t
{
    void *internal;
};
struct  starpu_omp_nest_lock_t
{
    void *internal;
};
enum starpu_omp_sched_value
{
  starpu_omp_sched_undefined = 0,
  starpu_omp_sched_static = 1,
  starpu_omp_sched_dynamic = 2,
  starpu_omp_sched_guided = 3,
  starpu_omp_sched_auto = 4,
  starpu_omp_sched_runtime = 5
};
enum starpu_omp_proc_bind_value
{
  starpu_omp_proc_bind_undefined =  -1,
  starpu_omp_proc_bind_false = 0,
  starpu_omp_proc_bind_true = 1,
  starpu_omp_proc_bind_master = 2,
  starpu_omp_proc_bind_close = 3,
  starpu_omp_proc_bind_spread = 4
};
struct  starpu_omp_parallel_region_attr
{
    ::starpu_codelet cl;
    ::starpu_data_handle_t *handles;
    void *cl_arg;
    ::size_t cl_arg_size;
    unsigned int cl_arg_free;
    int if_clause;
    int num_threads;
};
struct  starpu_omp_task_region_attr
{
    ::starpu_codelet cl;
    ::starpu_data_handle_t *handles;
    void *cl_arg;
    ::size_t cl_arg_size;
    unsigned int cl_arg_free;
    int priority;
    int if_clause;
    int final_clause;
    int untied_clause;
    int mergeable_clause;
};
extern "C"
{
  extern int starpu_omp_init() throw();
}
extern "C"
{
  extern void starpu_omp_shutdown() throw();
}
extern "C"
{
  extern void starpu_omp_parallel_region(const ::starpu_omp_parallel_region_attr *attr) throw();
}
extern "C"
{
  extern void starpu_omp_barrier() throw();
}
extern "C"
{
  extern void starpu_omp_master(void (*f)(void *), void *arg) throw();
}
extern "C"
{
  extern int starpu_omp_master_inline() throw();
}
extern "C"
{
  extern void starpu_omp_single(void (*f)(void *), void *arg, int nowait) throw();
}
extern "C"
{
  extern int starpu_omp_single_inline() throw();
}
extern "C"
{
  extern void starpu_omp_single_copyprivate(void (*f)(void *, void *, unsigned long long int), void *arg, void *data, unsigned long long int data_size) throw();
}
extern "C"
{
  extern void *starpu_omp_single_copyprivate_inline_begin(void *data) throw();
}
extern "C"
{
  extern void starpu_omp_single_copyprivate_inline_end() throw();
}
extern "C"
{
  extern void starpu_omp_critical(void (*f)(void *), void *arg, const char *name) throw();
}
extern "C"
{
  extern void starpu_omp_critical_inline_begin(const char *name) throw();
}
extern "C"
{
  extern void starpu_omp_critical_inline_end(const char *name) throw();
}
extern "C"
{
  extern void starpu_omp_task_region(const ::starpu_omp_task_region_attr *attr) throw();
}
extern "C"
{
  extern void starpu_omp_taskwait() throw();
}
extern "C"
{
  extern void starpu_omp_taskgroup(void (*f)(void *), void *arg) throw();
}
extern "C"
{
  extern void starpu_omp_taskgroup_inline_begin() throw();
}
extern "C"
{
  extern void starpu_omp_taskgroup_inline_end() throw();
}
extern "C"
{
  extern void starpu_omp_for(void (*f)(unsigned long long int, unsigned long long int, void *), void *arg, unsigned long long int nb_iterations, unsigned long long int chunk, int schedule, int ordered, int nowait) throw();
}
extern "C"
{
  extern int starpu_omp_for_inline_first(unsigned long long int nb_iterations, unsigned long long int chunk, int schedule, int ordered, unsigned long long int *_first_i, unsigned long long int *_nb_i) throw();
}
extern "C"
{
  extern int starpu_omp_for_inline_next(unsigned long long int nb_iterations, unsigned long long int chunk, int schedule, int ordered, unsigned long long int *_first_i, unsigned long long int *_nb_i) throw();
}
extern "C"
{
  extern void starpu_omp_for_alt(void (*f)(unsigned long long int, unsigned long long int, void *), void *arg, unsigned long long int nb_iterations, unsigned long long int chunk, int schedule, int ordered, int nowait) throw();
}
extern "C"
{
  extern int starpu_omp_for_inline_first_alt(unsigned long long int nb_iterations, unsigned long long int chunk, int schedule, int ordered, unsigned long long int *_begin_i, unsigned long long int *_end_i) throw();
}
extern "C"
{
  extern int starpu_omp_for_inline_next_alt(unsigned long long int nb_iterations, unsigned long long int chunk, int schedule, int ordered, unsigned long long int *_begin_i, unsigned long long int *_end_i) throw();
}
extern "C"
{
  extern void starpu_omp_ordered_inline_begin() throw();
}
extern "C"
{
  extern void starpu_omp_ordered_inline_end() throw();
}
extern "C"
{
  extern void starpu_omp_ordered(void (*f)(void *), void *arg) throw();
}
extern "C"
{
  extern void starpu_omp_sections(unsigned long long int nb_sections, void (**section_f)(void *), void **section_arg, int nowait) throw();
}
extern "C"
{
  extern void starpu_omp_sections_combined(unsigned long long int nb_sections, void (*section_f)(unsigned long long int, void *), void *section_arg, int nowait) throw();
}
extern "C"
{
  extern void starpu_omp_set_num_threads(int threads) throw();
}
extern "C"
{
  extern int starpu_omp_get_num_threads() throw();
}
extern "C"
{
  extern int starpu_omp_get_thread_num() throw();
}
extern "C"
{
  extern int starpu_omp_get_max_threads() throw();
}
extern "C"
{
  extern int starpu_omp_get_num_procs() throw();
}
extern "C"
{
  extern int starpu_omp_in_parallel() throw();
}
extern "C"
{
  extern void starpu_omp_set_dynamic(int dynamic_threads) throw();
}
extern "C"
{
  extern int starpu_omp_get_dynamic() throw();
}
extern "C"
{
  extern void starpu_omp_set_nested(int nested) throw();
}
extern "C"
{
  extern int starpu_omp_get_nested() throw();
}
extern "C"
{
  extern int starpu_omp_get_cancellation() throw();
}
extern "C"
{
  extern void starpu_omp_set_schedule(::starpu_omp_sched_value kind, int modifier) throw();
}
extern "C"
{
  extern void starpu_omp_get_schedule(::starpu_omp_sched_value *kind, int *modifier) throw();
}
extern "C"
{
  extern int starpu_omp_get_thread_limit() throw();
}
extern "C"
{
  extern void starpu_omp_set_max_active_levels(int max_levels) throw();
}
extern "C"
{
  extern int starpu_omp_get_max_active_levels() throw();
}
extern "C"
{
  extern int starpu_omp_get_level() throw();
}
extern "C"
{
  extern int starpu_omp_get_ancestor_thread_num(int level) throw();
}
extern "C"
{
  extern int starpu_omp_get_team_size(int level) throw();
}
extern "C"
{
  extern int starpu_omp_get_active_level() throw();
}
extern "C"
{
  extern int starpu_omp_in_final() throw();
}
extern "C"
{
  extern ::starpu_omp_proc_bind_value starpu_omp_get_proc_bind() throw();
}
extern "C"
{
  extern void starpu_omp_set_default_device(int device_num) throw();
}
extern "C"
{
  extern int starpu_omp_get_default_device() throw();
}
extern "C"
{
  extern int starpu_omp_get_num_devices() throw();
}
extern "C"
{
  extern int starpu_omp_get_num_teams() throw();
}
extern "C"
{
  extern int starpu_omp_get_team_num() throw();
}
extern "C"
{
  extern int starpu_omp_is_initial_device() throw();
}
extern "C"
{
  extern void starpu_omp_init_lock(::starpu_omp_lock_t *lock) throw();
}
extern "C"
{
  extern void starpu_omp_destroy_lock(::starpu_omp_lock_t *lock) throw();
}
extern "C"
{
  extern void starpu_omp_set_lock(::starpu_omp_lock_t *lock) throw();
}
extern "C"
{
  extern void starpu_omp_unset_lock(::starpu_omp_lock_t *lock) throw();
}
extern "C"
{
  extern int starpu_omp_test_lock(::starpu_omp_lock_t *lock) throw();
}
extern "C"
{
  extern void starpu_omp_init_nest_lock(::starpu_omp_nest_lock_t *lock) throw();
}
extern "C"
{
  extern void starpu_omp_destroy_nest_lock(::starpu_omp_nest_lock_t *lock) throw();
}
extern "C"
{
  extern void starpu_omp_set_nest_lock(::starpu_omp_nest_lock_t *lock) throw();
}
extern "C"
{
  extern void starpu_omp_unset_nest_lock(::starpu_omp_nest_lock_t *lock) throw();
}
extern "C"
{
  extern int starpu_omp_test_nest_lock(::starpu_omp_nest_lock_t *lock) throw();
}
extern "C"
{
  extern void starpu_omp_atomic_fallback_inline_begin() throw();
}
extern "C"
{
  extern void starpu_omp_atomic_fallback_inline_end() throw();
}
extern "C"
{
  extern double starpu_omp_get_wtime() throw();
}
extern "C"
{
  extern double starpu_omp_get_wtick() throw();
}
extern "C"
{
  extern void starpu_omp_vector_annotate(::starpu_data_handle_t handle, ::uint32_t slice_base) throw();
}
extern "C"
{
  extern ::starpu_arbiter *starpu_omp_get_default_arbiter() throw();
}
struct starpu_bitmap;
extern "C"
{
  ::starpu_bitmap *starpu_bitmap_create() __attribute__((malloc));
}
extern "C"
{
  void starpu_bitmap_destroy(::starpu_bitmap *b);
}
extern "C"
{
  void starpu_bitmap_set(::starpu_bitmap *b, int e);
}
extern "C"
{
  void starpu_bitmap_unset(::starpu_bitmap *b, int e);
}
extern "C"
{
  void starpu_bitmap_unset_all(::starpu_bitmap *b);
}
extern "C"
{
  int starpu_bitmap_get(::starpu_bitmap *b, int e);
}
extern "C"
{
  void starpu_bitmap_unset_and(::starpu_bitmap *a, ::starpu_bitmap *b, ::starpu_bitmap *c);
}
extern "C"
{
  void starpu_bitmap_or(::starpu_bitmap *a, ::starpu_bitmap *b);
}
extern "C"
{
  int starpu_bitmap_and_get(::starpu_bitmap *b1, ::starpu_bitmap *b2, int e);
}
extern "C"
{
  int starpu_bitmap_cardinal(::starpu_bitmap *b);
}
extern "C"
{
  int starpu_bitmap_first(::starpu_bitmap *b);
}
extern "C"
{
  int starpu_bitmap_last(::starpu_bitmap *b);
}
extern "C"
{
  int starpu_bitmap_next(::starpu_bitmap *b, int e);
}
extern "C"
{
  int starpu_bitmap_has_next(::starpu_bitmap *b, int e);
}
struct starpu_sched_policy;
struct  starpu_conf
{
    int magic;
    const char *sched_policy_name;
    ::starpu_sched_policy *sched_policy;
    int ncpus;
    int ncuda;
    int nopencl;
    int nmic;
    int nscc;
    unsigned int use_explicit_workers_bindid;
    unsigned int workers_bindid[80L];
    unsigned int use_explicit_workers_cuda_gpuid;
    unsigned int workers_cuda_gpuid[80L];
    unsigned int use_explicit_workers_opencl_gpuid;
    unsigned int workers_opencl_gpuid[80L];
    unsigned int use_explicit_workers_mic_deviceid;
    unsigned int workers_mic_deviceid[80L];
    unsigned int use_explicit_workers_scc_deviceid;
    unsigned int workers_scc_deviceid[80L];
    int bus_calibrate;
    int calibrate;
    int single_combined_worker;
    char *mic_sink_program_path;
    int disable_asynchronous_copy;
    int disable_asynchronous_cuda_copy;
    int disable_asynchronous_opencl_copy;
    int disable_asynchronous_mic_copy;
    unsigned int *cuda_opengl_interoperability;
    unsigned int n_cuda_opengl_interoperability;
    ::starpu_driver *not_launched_drivers;
    unsigned int n_not_launched_drivers;
    unsigned int trace_buffer_size;
    int global_sched_ctx_min_priority;
    int global_sched_ctx_max_priority;
};
extern "C"
{
  int starpu_conf_init(::starpu_conf *conf);
}
extern "C"
{
  int starpu_init(::starpu_conf *conf) __attribute__((__warn_unused_result__));
}
extern "C"
{
  int starpu_initialize(::starpu_conf *user_conf, int *argc, char ***argv);
}
extern "C"
{
  void starpu_pause();
}
extern "C"
{
  void starpu_resume();
}
extern "C"
{
  void starpu_shutdown();
}
extern "C"
{
  void starpu_topology_print(::FILE *f);
}
extern "C"
{
  int starpu_asynchronous_copy_disabled();
}
extern "C"
{
  int starpu_asynchronous_cuda_copy_disabled();
}
extern "C"
{
  int starpu_asynchronous_opencl_copy_disabled();
}
extern "C"
{
  int starpu_asynchronous_mic_copy_disabled();
}
extern "C"
{
  void starpu_display_stats();
}
extern "C"
{
  void starpu_get_version(int *major, int *minor, int *release);
}
class  StarPuAligner : public ::AbstractBlockAligner
{
  public:
    StarPuAligner(::AbstractBlockProcessor *blockProcessor  = (0L));
    virtual ~StarPuAligner();
    void processBlock(int bx, int by, int i0, int j0, int i1, int j1, int dispatchThisSpecialRows);
    static void callBack(void *descr[], void *_args);
    virtual void printInitialStatistics(::FILE *file);
  protected:
    virtual void scheduleBlocks(int grid_width, int grid_height);
    virtual void alignBlock(int bx, int by, int i0, int j0, int i1, int j1);
    virtual void allocateStructures();
    virtual void deallocateStructures();
    virtual void increaseBlockStat(const bool pruned);
  private:
    ::cell_t **renamedRow;
    char *rowChain;
    char columnChain;
  public:
};
typedef ::__socklen_t socklen_t;
extern "C"
{
  extern int access(const char *__name, int __type) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int euidaccess(const char *__name, int __type) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int eaccess(const char *__name, int __type) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int faccessat(int __fd, const char *__file, int __type, int __flag) throw() __attribute__((__nonnull__(2))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::__off_t lseek(int __fd, ::__off_t __offset, int __whence) throw();
}
extern "C"
{
  extern ::__off64_t lseek64(int __fd, ::__off64_t __offset, int __whence) throw();
}
extern "C"
{
  extern int close(int __fd);
}
extern "C"
{
  extern inline ::ssize_t read(int __fd, void *__buf, ::size_t __nbytes) __attribute__((__warn_unused_result__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern ::ssize_t write(int __fd, const void *__buf, ::size_t __n) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern inline ::ssize_t pread(int __fd, void *__buf, ::size_t __nbytes, ::__off_t __offset) __attribute__((__warn_unused_result__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern ::ssize_t pwrite(int __fd, const void *__buf, ::size_t __n, ::__off_t __offset) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern inline ::ssize_t pread64(int __fd, void *__buf, ::size_t __nbytes, ::__off64_t __offset) __attribute__((__warn_unused_result__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern ::ssize_t pwrite64(int __fd, const void *__buf, ::size_t __n, ::__off64_t __offset) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int pipe(int __pipedes[2L]) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int pipe2(int __pipedes[2L], int __flags) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern unsigned int alarm(unsigned int __seconds) throw();
}
extern "C"
{
  extern unsigned int sleep(unsigned int __seconds);
}
extern "C"
{
  extern ::__useconds_t ualarm(::__useconds_t __value, ::__useconds_t __interval) throw();
}
extern "C"
{
  extern int usleep(::__useconds_t __useconds);
}
extern "C"
{
  extern int pause();
}
extern "C"
{
  extern int chown(const char *__file, ::__uid_t __owner, ::__gid_t __group) throw() __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int fchown(int __fd, ::__uid_t __owner, ::__gid_t __group) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int lchown(const char *__file, ::__uid_t __owner, ::__gid_t __group) throw() __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int fchownat(int __fd, const char *__file, ::__uid_t __owner, ::__gid_t __group, int __flag) throw() __attribute__((__nonnull__(2))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int chdir(const char *__path) throw() __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int fchdir(int __fd) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern inline char *getcwd(char *__buf, ::size_t __size) throw() __attribute__((__warn_unused_result__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern char *get_current_dir_name() throw();
}
extern "C"
{
  extern inline char *getwd(char *__buf) throw() __attribute__((__nonnull__(1))) __attribute__((__deprecated__)) __attribute__((__warn_unused_result__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern int dup(int __fd) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int dup2(int __fd, int __fd2) throw();
}
extern "C"
{
  extern int dup3(int __fd, int __fd2, int __flags) throw();
}
extern "C"
{
  extern char **__environ;
}
extern "C"
{
  extern char **environ;
}
extern "C"
{
  extern int execve(const char *__path, char *const __argv[], char *const __envp[]) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int fexecve(int __fd, char *const __argv[], char *const __envp[]) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int execv(const char *__path, char *const __argv[]) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int execle(const char *__path, const char *__arg, ...) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int execl(const char *__path, const char *__arg, ...) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int execvp(const char *__file, char *const __argv[]) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int execlp(const char *__file, const char *__arg, ...) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int execvpe(const char *__file, char *const __argv[], char *const __envp[]) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int nice(int __inc) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern void _exit(int __status) __attribute__((__noreturn__));
}
enum mcc_enum_anon_50
{
  _PC_LINK_MAX = 0,
  _PC_MAX_CANON = 1,
  _PC_MAX_INPUT = 2,
  _PC_NAME_MAX = 3,
  _PC_PATH_MAX = 4,
  _PC_PIPE_BUF = 5,
  _PC_CHOWN_RESTRICTED = 6,
  _PC_NO_TRUNC = 7,
  _PC_VDISABLE = 8,
  _PC_SYNC_IO = 9,
  _PC_ASYNC_IO = 10,
  _PC_PRIO_IO = 11,
  _PC_SOCK_MAXBUF = 12,
  _PC_FILESIZEBITS = 13,
  _PC_REC_INCR_XFER_SIZE = 14,
  _PC_REC_MAX_XFER_SIZE = 15,
  _PC_REC_MIN_XFER_SIZE = 16,
  _PC_REC_XFER_ALIGN = 17,
  _PC_ALLOC_SIZE_MIN = 18,
  _PC_SYMLINK_MAX = 19,
  _PC_2_SYMLINKS = 20
};
enum mcc_enum_anon_51
{
  _SC_ARG_MAX = 0,
  _SC_CHILD_MAX = 1,
  _SC_CLK_TCK = 2,
  _SC_NGROUPS_MAX = 3,
  _SC_OPEN_MAX = 4,
  _SC_STREAM_MAX = 5,
  _SC_TZNAME_MAX = 6,
  _SC_JOB_CONTROL = 7,
  _SC_SAVED_IDS = 8,
  _SC_REALTIME_SIGNALS = 9,
  _SC_PRIORITY_SCHEDULING = 10,
  _SC_TIMERS = 11,
  _SC_ASYNCHRONOUS_IO = 12,
  _SC_PRIORITIZED_IO = 13,
  _SC_SYNCHRONIZED_IO = 14,
  _SC_FSYNC = 15,
  _SC_MAPPED_FILES = 16,
  _SC_MEMLOCK = 17,
  _SC_MEMLOCK_RANGE = 18,
  _SC_MEMORY_PROTECTION = 19,
  _SC_MESSAGE_PASSING = 20,
  _SC_SEMAPHORES = 21,
  _SC_SHARED_MEMORY_OBJECTS = 22,
  _SC_AIO_LISTIO_MAX = 23,
  _SC_AIO_MAX = 24,
  _SC_AIO_PRIO_DELTA_MAX = 25,
  _SC_DELAYTIMER_MAX = 26,
  _SC_MQ_OPEN_MAX = 27,
  _SC_MQ_PRIO_MAX = 28,
  _SC_VERSION = 29,
  _SC_PAGESIZE = 30,
  _SC_RTSIG_MAX = 31,
  _SC_SEM_NSEMS_MAX = 32,
  _SC_SEM_VALUE_MAX = 33,
  _SC_SIGQUEUE_MAX = 34,
  _SC_TIMER_MAX = 35,
  _SC_BC_BASE_MAX = 36,
  _SC_BC_DIM_MAX = 37,
  _SC_BC_SCALE_MAX = 38,
  _SC_BC_STRING_MAX = 39,
  _SC_COLL_WEIGHTS_MAX = 40,
  _SC_EQUIV_CLASS_MAX = 41,
  _SC_EXPR_NEST_MAX = 42,
  _SC_LINE_MAX = 43,
  _SC_RE_DUP_MAX = 44,
  _SC_CHARCLASS_NAME_MAX = 45,
  _SC_2_VERSION = 46,
  _SC_2_C_BIND = 47,
  _SC_2_C_DEV = 48,
  _SC_2_FORT_DEV = 49,
  _SC_2_FORT_RUN = 50,
  _SC_2_SW_DEV = 51,
  _SC_2_LOCALEDEF = 52,
  _SC_PII = 53,
  _SC_PII_XTI = 54,
  _SC_PII_SOCKET = 55,
  _SC_PII_INTERNET = 56,
  _SC_PII_OSI = 57,
  _SC_POLL = 58,
  _SC_SELECT = 59,
  _SC_UIO_MAXIOV = 60,
  _SC_IOV_MAX = ::_SC_UIO_MAXIOV,
  _SC_PII_INTERNET_STREAM = 61,
  _SC_PII_INTERNET_DGRAM = 62,
  _SC_PII_OSI_COTS = 63,
  _SC_PII_OSI_CLTS = 64,
  _SC_PII_OSI_M = 65,
  _SC_T_IOV_MAX = 66,
  _SC_THREADS = 67,
  _SC_THREAD_SAFE_FUNCTIONS = 68,
  _SC_GETGR_R_SIZE_MAX = 69,
  _SC_GETPW_R_SIZE_MAX = 70,
  _SC_LOGIN_NAME_MAX = 71,
  _SC_TTY_NAME_MAX = 72,
  _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
  _SC_THREAD_KEYS_MAX = 74,
  _SC_THREAD_STACK_MIN = 75,
  _SC_THREAD_THREADS_MAX = 76,
  _SC_THREAD_ATTR_STACKADDR = 77,
  _SC_THREAD_ATTR_STACKSIZE = 78,
  _SC_THREAD_PRIORITY_SCHEDULING = 79,
  _SC_THREAD_PRIO_INHERIT = 80,
  _SC_THREAD_PRIO_PROTECT = 81,
  _SC_THREAD_PROCESS_SHARED = 82,
  _SC_NPROCESSORS_CONF = 83,
  _SC_NPROCESSORS_ONLN = 84,
  _SC_PHYS_PAGES = 85,
  _SC_AVPHYS_PAGES = 86,
  _SC_ATEXIT_MAX = 87,
  _SC_PASS_MAX = 88,
  _SC_XOPEN_VERSION = 89,
  _SC_XOPEN_XCU_VERSION = 90,
  _SC_XOPEN_UNIX = 91,
  _SC_XOPEN_CRYPT = 92,
  _SC_XOPEN_ENH_I18N = 93,
  _SC_XOPEN_SHM = 94,
  _SC_2_CHAR_TERM = 95,
  _SC_2_C_VERSION = 96,
  _SC_2_UPE = 97,
  _SC_XOPEN_XPG2 = 98,
  _SC_XOPEN_XPG3 = 99,
  _SC_XOPEN_XPG4 = 100,
  _SC_CHAR_BIT = 101,
  _SC_CHAR_MAX = 102,
  _SC_CHAR_MIN = 103,
  _SC_INT_MAX = 104,
  _SC_INT_MIN = 105,
  _SC_LONG_BIT = 106,
  _SC_WORD_BIT = 107,
  _SC_MB_LEN_MAX = 108,
  _SC_NZERO = 109,
  _SC_SSIZE_MAX = 110,
  _SC_SCHAR_MAX = 111,
  _SC_SCHAR_MIN = 112,
  _SC_SHRT_MAX = 113,
  _SC_SHRT_MIN = 114,
  _SC_UCHAR_MAX = 115,
  _SC_UINT_MAX = 116,
  _SC_ULONG_MAX = 117,
  _SC_USHRT_MAX = 118,
  _SC_NL_ARGMAX = 119,
  _SC_NL_LANGMAX = 120,
  _SC_NL_MSGMAX = 121,
  _SC_NL_NMAX = 122,
  _SC_NL_SETMAX = 123,
  _SC_NL_TEXTMAX = 124,
  _SC_XBS5_ILP32_OFF32 = 125,
  _SC_XBS5_ILP32_OFFBIG = 126,
  _SC_XBS5_LP64_OFF64 = 127,
  _SC_XBS5_LPBIG_OFFBIG = 128,
  _SC_XOPEN_LEGACY = 129,
  _SC_XOPEN_REALTIME = 130,
  _SC_XOPEN_REALTIME_THREADS = 131,
  _SC_ADVISORY_INFO = 132,
  _SC_BARRIERS = 133,
  _SC_BASE = 134,
  _SC_C_LANG_SUPPORT = 135,
  _SC_C_LANG_SUPPORT_R = 136,
  _SC_CLOCK_SELECTION = 137,
  _SC_CPUTIME = 138,
  _SC_THREAD_CPUTIME = 139,
  _SC_DEVICE_IO = 140,
  _SC_DEVICE_SPECIFIC = 141,
  _SC_DEVICE_SPECIFIC_R = 142,
  _SC_FD_MGMT = 143,
  _SC_FIFO = 144,
  _SC_PIPE = 145,
  _SC_FILE_ATTRIBUTES = 146,
  _SC_FILE_LOCKING = 147,
  _SC_FILE_SYSTEM = 148,
  _SC_MONOTONIC_CLOCK = 149,
  _SC_MULTI_PROCESS = 150,
  _SC_SINGLE_PROCESS = 151,
  _SC_NETWORKING = 152,
  _SC_READER_WRITER_LOCKS = 153,
  _SC_SPIN_LOCKS = 154,
  _SC_REGEXP = 155,
  _SC_REGEX_VERSION = 156,
  _SC_SHELL = 157,
  _SC_SIGNALS = 158,
  _SC_SPAWN = 159,
  _SC_SPORADIC_SERVER = 160,
  _SC_THREAD_SPORADIC_SERVER = 161,
  _SC_SYSTEM_DATABASE = 162,
  _SC_SYSTEM_DATABASE_R = 163,
  _SC_TIMEOUTS = 164,
  _SC_TYPED_MEMORY_OBJECTS = 165,
  _SC_USER_GROUPS = 166,
  _SC_USER_GROUPS_R = 167,
  _SC_2_PBS = 168,
  _SC_2_PBS_ACCOUNTING = 169,
  _SC_2_PBS_LOCATE = 170,
  _SC_2_PBS_MESSAGE = 171,
  _SC_2_PBS_TRACK = 172,
  _SC_SYMLOOP_MAX = 173,
  _SC_STREAMS = 174,
  _SC_2_PBS_CHECKPOINT = 175,
  _SC_V6_ILP32_OFF32 = 176,
  _SC_V6_ILP32_OFFBIG = 177,
  _SC_V6_LP64_OFF64 = 178,
  _SC_V6_LPBIG_OFFBIG = 179,
  _SC_HOST_NAME_MAX = 180,
  _SC_TRACE = 181,
  _SC_TRACE_EVENT_FILTER = 182,
  _SC_TRACE_INHERIT = 183,
  _SC_TRACE_LOG = 184,
  _SC_LEVEL1_ICACHE_SIZE = 185,
  _SC_LEVEL1_ICACHE_ASSOC = 186,
  _SC_LEVEL1_ICACHE_LINESIZE = 187,
  _SC_LEVEL1_DCACHE_SIZE = 188,
  _SC_LEVEL1_DCACHE_ASSOC = 189,
  _SC_LEVEL1_DCACHE_LINESIZE = 190,
  _SC_LEVEL2_CACHE_SIZE = 191,
  _SC_LEVEL2_CACHE_ASSOC = 192,
  _SC_LEVEL2_CACHE_LINESIZE = 193,
  _SC_LEVEL3_CACHE_SIZE = 194,
  _SC_LEVEL3_CACHE_ASSOC = 195,
  _SC_LEVEL3_CACHE_LINESIZE = 196,
  _SC_LEVEL4_CACHE_SIZE = 197,
  _SC_LEVEL4_CACHE_ASSOC = 198,
  _SC_LEVEL4_CACHE_LINESIZE = 199,
  _SC_IPV6 = ::_SC_LEVEL1_ICACHE_SIZE + 50,
  _SC_RAW_SOCKETS = 236,
  _SC_V7_ILP32_OFF32 = 237,
  _SC_V7_ILP32_OFFBIG = 238,
  _SC_V7_LP64_OFF64 = 239,
  _SC_V7_LPBIG_OFFBIG = 240,
  _SC_SS_REPL_MAX = 241,
  _SC_TRACE_EVENT_NAME_MAX = 242,
  _SC_TRACE_NAME_MAX = 243,
  _SC_TRACE_SYS_MAX = 244,
  _SC_TRACE_USER_EVENT_MAX = 245,
  _SC_XOPEN_STREAMS = 246,
  _SC_THREAD_ROBUST_PRIO_INHERIT = 247,
  _SC_THREAD_ROBUST_PRIO_PROTECT = 248
};
enum mcc_enum_anon_52
{
  _CS_PATH = 0,
  _CS_V6_WIDTH_RESTRICTED_ENVS = 1,
  _CS_GNU_LIBC_VERSION = 2,
  _CS_GNU_LIBPTHREAD_VERSION = 3,
  _CS_V5_WIDTH_RESTRICTED_ENVS = 4,
  _CS_V7_WIDTH_RESTRICTED_ENVS = 5,
  _CS_LFS_CFLAGS = 1000,
  _CS_LFS_LDFLAGS = 1001,
  _CS_LFS_LIBS = 1002,
  _CS_LFS_LINTFLAGS = 1003,
  _CS_LFS64_CFLAGS = 1004,
  _CS_LFS64_LDFLAGS = 1005,
  _CS_LFS64_LIBS = 1006,
  _CS_LFS64_LINTFLAGS = 1007,
  _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
  _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
  _CS_XBS5_ILP32_OFF32_LIBS = 1102,
  _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
  _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
  _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
  _CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
  _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
  _CS_XBS5_LP64_OFF64_CFLAGS = 1108,
  _CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
  _CS_XBS5_LP64_OFF64_LIBS = 1110,
  _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
  _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
  _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
  _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
  _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
  _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
  _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
  _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
  _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
  _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
  _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
  _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
  _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
  _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
  _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
  _CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
  _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
  _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
  _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
  _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
  _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
  _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
  _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
  _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
  _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
  _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
  _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
  _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
  _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
  _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
  _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
  _CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
  _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
  _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
  _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
  _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
  _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147,
  _CS_V6_ENV = 1148,
  _CS_V7_ENV = 1149
};
extern "C"
{
  extern long int pathconf(const char *__path, int __name) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long int fpathconf(int __fd, int __name) throw();
}
extern "C"
{
  extern long int sysconf(int __name) throw();
}
extern "C"
{
  extern inline ::size_t confstr(int __name, char *__buf, ::size_t __len) throw() __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern ::__pid_t getpid() throw();
}
extern "C"
{
  extern ::__pid_t getppid() throw();
}
extern "C"
{
  extern ::__pid_t getpgrp() throw();
}
extern "C"
{
  extern ::__pid_t __getpgid(::__pid_t __pid) throw();
}
extern "C"
{
  extern ::__pid_t getpgid(::__pid_t __pid) throw();
}
extern "C"
{
  extern int setpgid(::__pid_t __pid, ::__pid_t __pgid) throw();
}
extern "C"
{
  extern int setpgrp() throw();
}
extern "C"
{
  extern ::__pid_t setsid() throw();
}
extern "C"
{
  extern ::__pid_t getsid(::__pid_t __pid) throw();
}
extern "C"
{
  extern ::__uid_t getuid() throw();
}
extern "C"
{
  extern ::__uid_t geteuid() throw();
}
extern "C"
{
  extern ::__gid_t getgid() throw();
}
extern "C"
{
  extern ::__gid_t getegid() throw();
}
extern "C"
{
  extern inline int getgroups(int __size, ::__gid_t __list[]) throw() __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern int group_member(::__gid_t __gid) throw();
}
extern "C"
{
  extern int setuid(::__uid_t __uid) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int setreuid(::__uid_t __ruid, ::__uid_t __euid) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int seteuid(::__uid_t __uid) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int setgid(::__gid_t __gid) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int setregid(::__gid_t __rgid, ::__gid_t __egid) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int setegid(::__gid_t __gid) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int getresuid(::__uid_t *__ruid, ::__uid_t *__euid, ::__uid_t *__suid) throw();
}
extern "C"
{
  extern int getresgid(::__gid_t *__rgid, ::__gid_t *__egid, ::__gid_t *__sgid) throw();
}
extern "C"
{
  extern int setresuid(::__uid_t __ruid, ::__uid_t __euid, ::__uid_t __suid) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int setresgid(::__gid_t __rgid, ::__gid_t __egid, ::__gid_t __sgid) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::__pid_t fork() throw();
}
extern "C"
{
  extern ::__pid_t vfork() throw();
}
extern "C"
{
  extern char *ttyname(int __fd) throw();
}
extern "C"
{
  extern inline int ttyname_r(int __fd, char *__buf, ::size_t __buflen) throw() __attribute__((__nonnull__(2))) __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern int isatty(int __fd) throw();
}
extern "C"
{
  extern int ttyslot() throw();
}
extern "C"
{
  extern int link(const char *__from, const char *__to) throw() __attribute__((__nonnull__(1, 2))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int linkat(int __fromfd, const char *__from, int __tofd, const char *__to, int __flags) throw() __attribute__((__nonnull__(2, 4))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int symlink(const char *__from, const char *__to) throw() __attribute__((__nonnull__(1, 2))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern inline ::ssize_t readlink(const char *__restrict __path, char *__restrict __buf, ::size_t __len) throw() __attribute__((__nonnull__(1, 2))) __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern int symlinkat(const char *__from, int __tofd, const char *__to) throw() __attribute__((__nonnull__(1, 3))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern inline ::ssize_t readlinkat(int __fd, const char *__restrict __path, char *__restrict __buf, ::size_t __len) throw() __attribute__((__nonnull__(2, 3))) __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern int unlink(const char *__name) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int unlinkat(int __fd, const char *__name, int __flag) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int rmdir(const char *__path) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern ::__pid_t tcgetpgrp(int __fd) throw();
}
extern "C"
{
  extern int tcsetpgrp(int __fd, ::__pid_t __pgrp_id) throw();
}
extern "C"
{
  extern char *getlogin();
}
extern "C"
{
  extern inline int getlogin_r(char *__buf, ::size_t __buflen) __attribute__((__nonnull__(1))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern int setlogin(const char *__name) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern inline int gethostname(char *__buf, ::size_t __buflen) throw() __attribute__((__nonnull__(1))) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern int sethostname(const char *__name, ::size_t __len) throw() __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int sethostid(long int __id) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern inline int getdomainname(char *__buf, ::size_t __buflen) throw() __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__));
}
extern "C"
{
  extern int setdomainname(const char *__name, ::size_t __len) throw() __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int vhangup() throw();
}
extern "C"
{
  extern int revoke(const char *__file) throw() __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int profil(unsigned short int *__sample_buffer, ::size_t __size, ::size_t __offset, unsigned int __scale) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int acct(const char *__name) throw();
}
extern "C"
{
  extern char *getusershell() throw();
}
extern "C"
{
  extern void endusershell() throw();
}
extern "C"
{
  extern void setusershell() throw();
}
extern "C"
{
  extern int daemon(int __nochdir, int __noclose) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int chroot(const char *__path) throw() __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern char *getpass(const char *__prompt) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int fsync(int __fd);
}
extern "C"
{
  extern int syncfs(int __fd) throw();
}
extern "C"
{
  extern long int gethostid();
}
extern "C"
{
  extern void sync() throw();
}
extern "C"
{
  extern int getpagesize() throw() __attribute__((__const__));
}
extern "C"
{
  extern int getdtablesize() throw();
}
extern "C"
{
  extern int truncate(const char *__file, ::__off_t __length) throw() __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int truncate64(const char *__file, ::__off64_t __length) throw() __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int ftruncate(int __fd, ::__off_t __length) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int ftruncate64(int __fd, ::__off64_t __length) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int brk(void *__addr) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern void *sbrk(::intptr_t __delta) throw();
}
extern "C"
{
  extern long int syscall(long int __sysno, ...) throw();
}
extern "C"
{
  extern int lockf(int __fd, int __cmd, ::__off_t __len) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int lockf64(int __fd, int __cmd, ::__off64_t __len) __attribute__((__warn_unused_result__));
}
extern "C"
{
  ::ssize_t copy_file_range(int __infd, ::__off64_t *__pinoff, int __outfd, ::__off64_t *__poutoff, ::size_t __length, unsigned int __flags);
}
extern "C"
{
  extern int fdatasync(int __fildes);
}
extern "C"
{
  extern char *crypt(const char *__key, const char *__salt) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern void encrypt(char *__glibc_block, int __edflag) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern void swab(const void *__restrict __from, void *__restrict __to, ::ssize_t __n) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  int getentropy(void *__buffer, ::size_t __length) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::ssize_t __read_chk(int __fd, void *__buf, ::size_t __nbytes, ::size_t __buflen) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::ssize_t __read_alias(int __fd, void *__buf, ::size_t __nbytes) __asm("""read") __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::ssize_t __read_chk_warn(int __fd, void *__buf, ::size_t __nbytes, ::size_t __buflen) __asm("""__read_chk") __attribute__((__warn_unused_result__)) __attribute__((__warning__("read called with bigger length than size of ""the destination buffer")));
}
extern "C"
{
  extern inline __attribute__((__warn_unused_result__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) ::ssize_t read(int __fd, void *__buf, ::size_t __nbytes)
  {
    if (__builtin_object_size(__buf, 0) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__nbytes))
          {
            return ::__read_chk(__fd, __buf, __nbytes, __builtin_object_size(__buf, 0));
          }
        if (__nbytes > __builtin_object_size(__buf, 0))
          {
            return ::__read_chk_warn(__fd, __buf, __nbytes, __builtin_object_size(__buf, 0));
          }
      }
    return ::__read_alias(__fd, __buf, __nbytes);
  }
}
extern "C"
{
  extern ::ssize_t __pread_chk(int __fd, void *__buf, ::size_t __nbytes, ::__off_t __offset, ::size_t __bufsize) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::ssize_t __pread64_chk(int __fd, void *__buf, ::size_t __nbytes, ::__off64_t __offset, ::size_t __bufsize) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::ssize_t __pread_alias(int __fd, void *__buf, ::size_t __nbytes, ::__off_t __offset) __asm("""pread") __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::ssize_t __pread64_alias(int __fd, void *__buf, ::size_t __nbytes, ::__off64_t __offset) __asm("""pread64") __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::ssize_t __pread_chk_warn(int __fd, void *__buf, ::size_t __nbytes, ::__off_t __offset, ::size_t __bufsize) __asm("""__pread_chk") __attribute__((__warn_unused_result__)) __attribute__((__warning__("pread called with bigger length than size of ""the destination buffer")));
}
extern "C"
{
  extern ::ssize_t __pread64_chk_warn(int __fd, void *__buf, ::size_t __nbytes, ::__off64_t __offset, ::size_t __bufsize) __asm("""__pread64_chk") __attribute__((__warn_unused_result__)) __attribute__((__warning__("pread64 called with bigger length than size of ""the destination buffer")));
}
extern "C"
{
  extern inline __attribute__((__warn_unused_result__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) ::ssize_t pread(int __fd, void *__buf, ::size_t __nbytes, ::__off_t __offset)
  {
    if (__builtin_object_size(__buf, 0) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__nbytes))
          {
            return ::__pread_chk(__fd, __buf, __nbytes, __offset, __builtin_object_size(__buf, 0));
          }
        if (__nbytes > __builtin_object_size(__buf, 0))
          {
            return ::__pread_chk_warn(__fd, __buf, __nbytes, __offset, __builtin_object_size(__buf, 0));
          }
      }
    return ::__pread_alias(__fd, __buf, __nbytes, __offset);
  }
}
extern "C"
{
  extern inline __attribute__((__warn_unused_result__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) ::ssize_t pread64(int __fd, void *__buf, ::size_t __nbytes, ::__off64_t __offset)
  {
    if (__builtin_object_size(__buf, 0) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__nbytes))
          {
            return ::__pread64_chk(__fd, __buf, __nbytes, __offset, __builtin_object_size(__buf, 0));
          }
        if (__nbytes > __builtin_object_size(__buf, 0))
          {
            return ::__pread64_chk_warn(__fd, __buf, __nbytes, __offset, __builtin_object_size(__buf, 0));
          }
      }
    return ::__pread64_alias(__fd, __buf, __nbytes, __offset);
  }
}
extern "C"
{
  extern ::ssize_t __readlink_chk(const char *__restrict __path, char *__restrict __buf, ::size_t __len, ::size_t __buflen) throw() __attribute__((__nonnull__(1, 2))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::ssize_t __readlink_alias(const char *__restrict __path, char *__restrict __buf, ::size_t __len) throw() __asm("""readlink") __attribute__((__nonnull__(1, 2))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::ssize_t __readlink_chk_warn(const char *__restrict __path, char *__restrict __buf, ::size_t __len, ::size_t __buflen) throw() __asm("""__readlink_chk") __attribute__((__nonnull__(1, 2))) __attribute__((__warn_unused_result__)) __attribute__((__warning__("readlink called with bigger length ""than size of destination buffer")));
}
extern "C"
{
  extern inline __attribute__((__nonnull__(1, 2))) __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) ::ssize_t readlink(const char *__restrict __path, char *__restrict __buf, ::size_t __len) throw()
  {
    if (__builtin_object_size(__buf, 2 > 1) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__len))
          {
            return ::__readlink_chk(__path, __buf, __len, __builtin_object_size(__buf, 2 > 1));
          }
        if (__len > __builtin_object_size(__buf, 2 > 1))
          {
            return ::__readlink_chk_warn(__path, __buf, __len, __builtin_object_size(__buf, 2 > 1));
          }
      }
    return ::__readlink_alias(__path, __buf, __len);
  }
}
extern "C"
{
  extern ::ssize_t __readlinkat_chk(int __fd, const char *__restrict __path, char *__restrict __buf, ::size_t __len, ::size_t __buflen) throw() __attribute__((__nonnull__(2, 3))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::ssize_t __readlinkat_alias(int __fd, const char *__restrict __path, char *__restrict __buf, ::size_t __len) throw() __asm("""readlinkat") __attribute__((__nonnull__(2, 3))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern ::ssize_t __readlinkat_chk_warn(int __fd, const char *__restrict __path, char *__restrict __buf, ::size_t __len, ::size_t __buflen) throw() __asm("""__readlinkat_chk") __attribute__((__nonnull__(2, 3))) __attribute__((__warn_unused_result__)) __attribute__((__warning__("readlinkat called with bigger ""length than size of destination ""buffer")));
}
extern "C"
{
  extern inline __attribute__((__nonnull__(2, 3))) __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) ::ssize_t readlinkat(int __fd, const char *__restrict __path, char *__restrict __buf, ::size_t __len) throw()
  {
    if (__builtin_object_size(__buf, 2 > 1) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__len))
          {
            return ::__readlinkat_chk(__fd, __path, __buf, __len, __builtin_object_size(__buf, 2 > 1));
          }
        if (__len > __builtin_object_size(__buf, 2 > 1))
          {
            return ::__readlinkat_chk_warn(__fd, __path, __buf, __len, __builtin_object_size(__buf, 2 > 1));
          }
      }
    return ::__readlinkat_alias(__fd, __path, __buf, __len);
  }
}
extern "C"
{
  extern char *__getcwd_chk(char *__buf, ::size_t __size, ::size_t __buflen) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern char *__getcwd_alias(char *__buf, ::size_t __size) throw() __asm("""getcwd") __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern char *__getcwd_chk_warn(char *__buf, ::size_t __size, ::size_t __buflen) throw() __asm("""__getcwd_chk") __attribute__((__warn_unused_result__)) __attribute__((__warning__("getcwd caller with bigger length than size of ""destination buffer")));
}
extern "C"
{
  extern inline __attribute__((__warn_unused_result__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) char *getcwd(char *__buf, ::size_t __size) throw()
  {
    if (__builtin_object_size(__buf, 2 > 1) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__size))
          {
            return ::__getcwd_chk(__buf, __size, __builtin_object_size(__buf, 2 > 1));
          }
        if (__size > __builtin_object_size(__buf, 2 > 1))
          {
            return ::__getcwd_chk_warn(__buf, __size, __builtin_object_size(__buf, 2 > 1));
          }
      }
    return ::__getcwd_alias(__buf, __size);
  }
}
extern "C"
{
  extern char *__getwd_chk(char *__buf, ::size_t buflen) throw() __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern char *__getwd_warn(char *__buf) throw() __asm("""getwd") __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__)) __attribute__((__warning__("please use getcwd instead, as getwd ""doesn't specify buffer size")));
}
extern "C"
{
  extern inline __attribute__((__nonnull__(1))) __attribute__((__deprecated__)) __attribute__((__warn_unused_result__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) char *getwd(char *__buf) throw()
  {
    if (__builtin_object_size(__buf, 2 > 1) != (::size_t) -1)
      {
        return ::__getwd_chk(__buf, __builtin_object_size(__buf, 2 > 1));
      }
    return ::__getwd_warn(__buf);
  }
}
extern "C"
{
  extern ::size_t __confstr_chk(int __name, char *__buf, ::size_t __len, ::size_t __buflen) throw();
}
extern "C"
{
  extern ::size_t __confstr_alias(int __name, char *__buf, ::size_t __len) throw() __asm("""confstr");
}
extern "C"
{
  extern ::size_t __confstr_chk_warn(int __name, char *__buf, ::size_t __len, ::size_t __buflen) throw() __asm("""__confstr_chk") __attribute__((__warning__("confstr called with bigger length than size of destination ""buffer")));
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) ::size_t confstr(int __name, char *__buf, ::size_t __len) throw()
  {
    if (__builtin_object_size(__buf, 2 > 1) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__len))
          {
            return ::__confstr_chk(__name, __buf, __len, __builtin_object_size(__buf, 2 > 1));
          }
        if (__builtin_object_size(__buf, 2 > 1) < __len)
          {
            return ::__confstr_chk_warn(__name, __buf, __len, __builtin_object_size(__buf, 2 > 1));
          }
      }
    return ::__confstr_alias(__name, __buf, __len);
  }
}
extern "C"
{
  extern int __getgroups_chk(int __size, ::__gid_t __list[], ::size_t __listlen) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int __getgroups_alias(int __size, ::__gid_t __list[]) throw() __asm("""getgroups") __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int __getgroups_chk_warn(int __size, ::__gid_t __list[], ::size_t __listlen) throw() __asm("""__getgroups_chk") __attribute__((__warn_unused_result__)) __attribute__((__warning__("getgroups called with bigger group count than what ""can fit into destination buffer")));
}
extern "C"
{
  extern inline __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int getgroups(int __size, ::__gid_t *__list) throw()
  {
    if (__builtin_object_size(__list, 2 > 1) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__size) || __size < 0)
          {
            return ::__getgroups_chk(__size, __list, __builtin_object_size(__list, 2 > 1));
          }
        if (__size * sizeof(::__gid_t) > __builtin_object_size(__list, 2 > 1))
          {
            return ::__getgroups_chk_warn(__size, __list, __builtin_object_size(__list, 2 > 1));
          }
      }
    return ::__getgroups_alias(__size, __list);
  }
}
extern "C"
{
  extern int __ttyname_r_chk(int __fd, char *__buf, ::size_t __buflen, ::size_t __nreal) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int __ttyname_r_alias(int __fd, char *__buf, ::size_t __buflen) throw() __asm("""ttyname_r") __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int __ttyname_r_chk_warn(int __fd, char *__buf, ::size_t __buflen, ::size_t __nreal) throw() __asm("""__ttyname_r_chk") __attribute__((__nonnull__(2))) __attribute__((__warning__("ttyname_r called with bigger buflen than ""size of destination buffer")));
}
extern "C"
{
  extern inline __attribute__((__nonnull__(2))) __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int ttyname_r(int __fd, char *__buf, ::size_t __buflen) throw()
  {
    if (__builtin_object_size(__buf, 2 > 1) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__buflen))
          {
            return ::__ttyname_r_chk(__fd, __buf, __buflen, __builtin_object_size(__buf, 2 > 1));
          }
        if (__buflen > __builtin_object_size(__buf, 2 > 1))
          {
            return ::__ttyname_r_chk_warn(__fd, __buf, __buflen, __builtin_object_size(__buf, 2 > 1));
          }
      }
    return ::__ttyname_r_alias(__fd, __buf, __buflen);
  }
}
extern "C"
{
  extern int __getlogin_r_chk(char *__buf, ::size_t __buflen, ::size_t __nreal) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int __getlogin_r_alias(char *__buf, ::size_t __buflen) __asm("""getlogin_r") __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int __getlogin_r_chk_warn(char *__buf, ::size_t __buflen, ::size_t __nreal) __asm("""__getlogin_r_chk") __attribute__((__nonnull__(1))) __attribute__((__warning__("getlogin_r called with bigger buflen than ""size of destination buffer")));
}
extern "C"
{
  extern inline __attribute__((__nonnull__(1))) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int getlogin_r(char *__buf, ::size_t __buflen)
  {
    if (__builtin_object_size(__buf, 2 > 1) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__buflen))
          {
            return ::__getlogin_r_chk(__buf, __buflen, __builtin_object_size(__buf, 2 > 1));
          }
        if (__buflen > __builtin_object_size(__buf, 2 > 1))
          {
            return ::__getlogin_r_chk_warn(__buf, __buflen, __builtin_object_size(__buf, 2 > 1));
          }
      }
    return ::__getlogin_r_alias(__buf, __buflen);
  }
}
extern "C"
{
  extern int __gethostname_chk(char *__buf, ::size_t __buflen, ::size_t __nreal) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int __gethostname_alias(char *__buf, ::size_t __buflen) throw() __asm("""gethostname") __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int __gethostname_chk_warn(char *__buf, ::size_t __buflen, ::size_t __nreal) throw() __asm("""__gethostname_chk") __attribute__((__nonnull__(1))) __attribute__((__warning__("gethostname called with bigger buflen than ""size of destination buffer")));
}
extern "C"
{
  extern inline __attribute__((__nonnull__(1))) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int gethostname(char *__buf, ::size_t __buflen) throw()
  {
    if (__builtin_object_size(__buf, 2 > 1) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__buflen))
          {
            return ::__gethostname_chk(__buf, __buflen, __builtin_object_size(__buf, 2 > 1));
          }
        if (__buflen > __builtin_object_size(__buf, 2 > 1))
          {
            return ::__gethostname_chk_warn(__buf, __buflen, __builtin_object_size(__buf, 2 > 1));
          }
      }
    return ::__gethostname_alias(__buf, __buflen);
  }
}
extern "C"
{
  extern int __getdomainname_chk(char *__buf, ::size_t __buflen, ::size_t __nreal) throw() __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int __getdomainname_alias(char *__buf, ::size_t __buflen) throw() __asm("""getdomainname") __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern int __getdomainname_chk_warn(char *__buf, ::size_t __buflen, ::size_t __nreal) throw() __asm("""__getdomainname_chk") __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__)) __attribute__((__warning__("getdomainname called with bigger ""buflen than size of destination ""buffer")));
}
extern "C"
{
  extern inline __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__)) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) __attribute__((__artificial__)) int getdomainname(char *__buf, ::size_t __buflen) throw()
  {
    if (__builtin_object_size(__buf, 2 > 1) != (::size_t) -1)
      {
        if (!__builtin_constant_p(__buflen))
          {
            return ::__getdomainname_chk(__buf, __buflen, __builtin_object_size(__buf, 2 > 1));
          }
        if (__buflen > __builtin_object_size(__buf, 2 > 1))
          {
            return ::__getdomainname_chk_warn(__buf, __buflen, __builtin_object_size(__buf, 2 > 1));
          }
      }
    return ::__getdomainname_alias(__buf, __buflen);
  }
}
typedef float float_t;
typedef double double_t;
enum mcc_enum_anon_53
{
  FP_INT_UPWARD = 0,
  FP_INT_DOWNWARD = 1,
  FP_INT_TOWARDZERO = 2,
  FP_INT_TONEARESTFROMZERO = 3,
  FP_INT_TONEAREST = 4
};
extern "C"
{
  extern int __fpclassify(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __signbit(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __isinf(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __finite(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __isnan(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __iseqsig(double __x, double __y) throw();
}
extern "C"
{
  extern int __issignaling(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern double acos(double __x) throw();
}
extern "C"
{
  extern double __acos(double __x) throw();
}
extern "C"
{
  extern double asin(double __x) throw();
}
extern "C"
{
  extern double __asin(double __x) throw();
}
extern "C"
{
  extern double atan(double __x) throw();
}
extern "C"
{
  extern double __atan(double __x) throw();
}
extern "C"
{
  extern double atan2(double __y, double __x) throw();
}
extern "C"
{
  extern double __atan2(double __y, double __x) throw();
}
extern "C"
{
  extern double cos(double __x) throw();
}
extern "C"
{
  extern double __cos(double __x) throw();
}
extern "C"
{
  extern double sin(double __x) throw();
}
extern "C"
{
  extern double __sin(double __x) throw();
}
extern "C"
{
  extern double tan(double __x) throw();
}
extern "C"
{
  extern double __tan(double __x) throw();
}
extern "C"
{
  extern double cosh(double __x) throw();
}
extern "C"
{
  extern double __cosh(double __x) throw();
}
extern "C"
{
  extern double sinh(double __x) throw();
}
extern "C"
{
  extern double __sinh(double __x) throw();
}
extern "C"
{
  extern double tanh(double __x) throw();
}
extern "C"
{
  extern double __tanh(double __x) throw();
}
extern "C"
{
  extern void sincos(double __x, double *__sinx, double *__cosx) throw();
}
extern "C"
{
  extern void __sincos(double __x, double *__sinx, double *__cosx) throw();
}
extern "C"
{
  extern double acosh(double __x) throw();
}
extern "C"
{
  extern double __acosh(double __x) throw();
}
extern "C"
{
  extern double asinh(double __x) throw();
}
extern "C"
{
  extern double __asinh(double __x) throw();
}
extern "C"
{
  extern double atanh(double __x) throw();
}
extern "C"
{
  extern double __atanh(double __x) throw();
}
extern "C"
{
  extern double exp(double __x) throw();
}
extern "C"
{
  extern double __exp(double __x) throw();
}
extern "C"
{
  extern double frexp(double __x, int *__exponent) throw();
}
extern "C"
{
  extern double __frexp(double __x, int *__exponent) throw();
}
extern "C"
{
  extern double ldexp(double __x, int __exponent) throw();
}
extern "C"
{
  extern double __ldexp(double __x, int __exponent) throw();
}
extern "C"
{
  extern double log(double __x) throw();
}
extern "C"
{
  extern double __log(double __x) throw();
}
extern "C"
{
  extern double log10(double __x) throw();
}
extern "C"
{
  extern double __log10(double __x) throw();
}
extern "C"
{
  extern double modf(double __x, double *__iptr) throw();
}
extern "C"
{
  extern double __modf(double __x, double *__iptr) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern double exp10(double __x) throw();
}
extern "C"
{
  extern double __exp10(double __x) throw();
}
extern "C"
{
  extern double expm1(double __x) throw();
}
extern "C"
{
  extern double __expm1(double __x) throw();
}
extern "C"
{
  extern double log1p(double __x) throw();
}
extern "C"
{
  extern double __log1p(double __x) throw();
}
extern "C"
{
  extern double logb(double __x) throw();
}
extern "C"
{
  extern double __logb(double __x) throw();
}
extern "C"
{
  extern double exp2(double __x) throw();
}
extern "C"
{
  extern double __exp2(double __x) throw();
}
extern "C"
{
  extern double log2(double __x) throw();
}
extern "C"
{
  extern double __log2(double __x) throw();
}
extern "C"
{
  extern double pow(double __x, double __y) throw();
}
extern "C"
{
  extern double __pow(double __x, double __y) throw();
}
extern "C"
{
  extern double sqrt(double __x) throw();
}
extern "C"
{
  extern double __sqrt(double __x) throw();
}
extern "C"
{
  extern double hypot(double __x, double __y) throw();
}
extern "C"
{
  extern double __hypot(double __x, double __y) throw();
}
extern "C"
{
  extern double cbrt(double __x) throw();
}
extern "C"
{
  extern double __cbrt(double __x) throw();
}
extern "C"
{
  extern double ceil(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __ceil(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double fabs(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __fabs(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double floor(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __floor(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double fmod(double __x, double __y) throw();
}
extern "C"
{
  extern double __fmod(double __x, double __y) throw();
}
extern "C"
{
  extern int isinf(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int finite(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern double drem(double __x, double __y) throw();
}
extern "C"
{
  extern double __drem(double __x, double __y) throw();
}
extern "C"
{
  extern double significand(double __x) throw();
}
extern "C"
{
  extern double __significand(double __x) throw();
}
extern "C"
{
  extern double copysign(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __copysign(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double nan(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __nan(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern int isnan(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern double j0(double) throw();
}
extern "C"
{
  extern double __j0(double) throw();
}
extern "C"
{
  extern double j1(double) throw();
}
extern "C"
{
  extern double __j1(double) throw();
}
extern "C"
{
  extern double jn(int, double) throw();
}
extern "C"
{
  extern double __jn(int, double) throw();
}
extern "C"
{
  extern double y0(double) throw();
}
extern "C"
{
  extern double __y0(double) throw();
}
extern "C"
{
  extern double y1(double) throw();
}
extern "C"
{
  extern double __y1(double) throw();
}
extern "C"
{
  extern double yn(int, double) throw();
}
extern "C"
{
  extern double __yn(int, double) throw();
}
extern "C"
{
  extern double erf(double) throw();
}
extern "C"
{
  extern double __erf(double) throw();
}
extern "C"
{
  extern double erfc(double) throw();
}
extern "C"
{
  extern double __erfc(double) throw();
}
extern "C"
{
  extern double lgamma(double) throw();
}
extern "C"
{
  extern double __lgamma(double) throw();
}
extern "C"
{
  extern double tgamma(double) throw();
}
extern "C"
{
  extern double __tgamma(double) throw();
}
extern "C"
{
  extern double gamma(double) throw();
}
extern "C"
{
  extern double __gamma(double) throw();
}
extern "C"
{
  extern double lgamma_r(double, int *__signgamp) throw();
}
extern "C"
{
  extern double __lgamma_r(double, int *__signgamp) throw();
}
extern "C"
{
  extern double rint(double __x) throw();
}
extern "C"
{
  extern double __rint(double __x) throw();
}
extern "C"
{
  extern double nextafter(double __x, double __y) throw();
}
extern "C"
{
  extern double __nextafter(double __x, double __y) throw();
}
extern "C"
{
  extern double nexttoward(double __x, long double __y) throw();
}
extern "C"
{
  extern double __nexttoward(double __x, long double __y) throw();
}
extern "C"
{
  extern double nextdown(double __x) throw();
}
extern "C"
{
  extern double __nextdown(double __x) throw();
}
extern "C"
{
  extern double nextup(double __x) throw();
}
extern "C"
{
  extern double __nextup(double __x) throw();
}
extern "C"
{
  extern double remainder(double __x, double __y) throw();
}
extern "C"
{
  extern double __remainder(double __x, double __y) throw();
}
extern "C"
{
  extern double scalbn(double __x, int __n) throw();
}
extern "C"
{
  extern double __scalbn(double __x, int __n) throw();
}
extern "C"
{
  extern int ilogb(double __x) throw();
}
extern "C"
{
  extern int __ilogb(double __x) throw();
}
extern "C"
{
  extern long int llogb(double __x) throw();
}
extern "C"
{
  extern long int __llogb(double __x) throw();
}
extern "C"
{
  extern double scalbln(double __x, long int __n) throw();
}
extern "C"
{
  extern double __scalbln(double __x, long int __n) throw();
}
extern "C"
{
  extern double nearbyint(double __x) throw();
}
extern "C"
{
  extern double __nearbyint(double __x) throw();
}
extern "C"
{
  extern double round(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __round(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double trunc(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __trunc(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double remquo(double __x, double __y, int *__quo) throw();
}
extern "C"
{
  extern double __remquo(double __x, double __y, int *__quo) throw();
}
extern "C"
{
  extern long int lrint(double __x) throw();
}
extern "C"
{
  extern long int __lrint(double __x) throw();
}
extern "C"
{
  extern long long int llrint(double __x) throw();
}
extern "C"
{
  extern long long int __llrint(double __x) throw();
}
extern "C"
{
  extern long int lround(double __x) throw();
}
extern "C"
{
  extern long int __lround(double __x) throw();
}
extern "C"
{
  extern long long int llround(double __x) throw();
}
extern "C"
{
  extern long long int __llround(double __x) throw();
}
extern "C"
{
  extern double fdim(double __x, double __y) throw();
}
extern "C"
{
  extern double __fdim(double __x, double __y) throw();
}
extern "C"
{
  extern double fmax(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __fmax(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double fmin(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __fmin(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double fma(double __x, double __y, double __z) throw();
}
extern "C"
{
  extern double __fma(double __x, double __y, double __z) throw();
}
extern "C"
{
  extern double roundeven(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __roundeven(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::__intmax_t fromfp(double __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__intmax_t __fromfp(double __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t ufromfp(double __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t __ufromfp(double __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__intmax_t fromfpx(double __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__intmax_t __fromfpx(double __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t ufromfpx(double __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t __ufromfpx(double __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern double fmaxmag(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __fmaxmag(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double fminmag(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __fminmag(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int totalorder(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int totalordermag(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int canonicalize(double *__cx, const double *__x) throw();
}
extern "C"
{
  extern double getpayload(const double *__x) throw();
}
extern "C"
{
  extern double __getpayload(const double *__x) throw();
}
extern "C"
{
  extern int setpayload(double *__x, double __payload) throw();
}
extern "C"
{
  extern int setpayloadsig(double *__x, double __payload) throw();
}
extern "C"
{
  extern double scalb(double __x, double __n) throw();
}
extern "C"
{
  extern double __scalb(double __x, double __n) throw();
}
extern "C"
{
  extern int __fpclassifyf(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __signbitf(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __isinff(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __finitef(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __isnanf(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __iseqsigf(float __x, float __y) throw();
}
extern "C"
{
  extern int __issignalingf(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern float acosf(float __x) throw();
}
extern "C"
{
  extern float __acosf(float __x) throw();
}
extern "C"
{
  extern float asinf(float __x) throw();
}
extern "C"
{
  extern float __asinf(float __x) throw();
}
extern "C"
{
  extern float atanf(float __x) throw();
}
extern "C"
{
  extern float __atanf(float __x) throw();
}
extern "C"
{
  extern float atan2f(float __y, float __x) throw();
}
extern "C"
{
  extern float __atan2f(float __y, float __x) throw();
}
extern "C"
{
  extern float cosf(float __x) throw();
}
extern "C"
{
  extern float __cosf(float __x) throw();
}
extern "C"
{
  extern float sinf(float __x) throw();
}
extern "C"
{
  extern float __sinf(float __x) throw();
}
extern "C"
{
  extern float tanf(float __x) throw();
}
extern "C"
{
  extern float __tanf(float __x) throw();
}
extern "C"
{
  extern float coshf(float __x) throw();
}
extern "C"
{
  extern float __coshf(float __x) throw();
}
extern "C"
{
  extern float sinhf(float __x) throw();
}
extern "C"
{
  extern float __sinhf(float __x) throw();
}
extern "C"
{
  extern float tanhf(float __x) throw();
}
extern "C"
{
  extern float __tanhf(float __x) throw();
}
extern "C"
{
  extern void sincosf(float __x, float *__sinx, float *__cosx) throw();
}
extern "C"
{
  extern void __sincosf(float __x, float *__sinx, float *__cosx) throw();
}
extern "C"
{
  extern float acoshf(float __x) throw();
}
extern "C"
{
  extern float __acoshf(float __x) throw();
}
extern "C"
{
  extern float asinhf(float __x) throw();
}
extern "C"
{
  extern float __asinhf(float __x) throw();
}
extern "C"
{
  extern float atanhf(float __x) throw();
}
extern "C"
{
  extern float __atanhf(float __x) throw();
}
extern "C"
{
  extern float expf(float __x) throw();
}
extern "C"
{
  extern float __expf(float __x) throw();
}
extern "C"
{
  extern float frexpf(float __x, int *__exponent) throw();
}
extern "C"
{
  extern float __frexpf(float __x, int *__exponent) throw();
}
extern "C"
{
  extern float ldexpf(float __x, int __exponent) throw();
}
extern "C"
{
  extern float __ldexpf(float __x, int __exponent) throw();
}
extern "C"
{
  extern float logf(float __x) throw();
}
extern "C"
{
  extern float __logf(float __x) throw();
}
extern "C"
{
  extern float log10f(float __x) throw();
}
extern "C"
{
  extern float __log10f(float __x) throw();
}
extern "C"
{
  extern float modff(float __x, float *__iptr) throw();
}
extern "C"
{
  extern float __modff(float __x, float *__iptr) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern float exp10f(float __x) throw();
}
extern "C"
{
  extern float __exp10f(float __x) throw();
}
extern "C"
{
  extern float expm1f(float __x) throw();
}
extern "C"
{
  extern float __expm1f(float __x) throw();
}
extern "C"
{
  extern float log1pf(float __x) throw();
}
extern "C"
{
  extern float __log1pf(float __x) throw();
}
extern "C"
{
  extern float logbf(float __x) throw();
}
extern "C"
{
  extern float __logbf(float __x) throw();
}
extern "C"
{
  extern float exp2f(float __x) throw();
}
extern "C"
{
  extern float __exp2f(float __x) throw();
}
extern "C"
{
  extern float log2f(float __x) throw();
}
extern "C"
{
  extern float __log2f(float __x) throw();
}
extern "C"
{
  extern float powf(float __x, float __y) throw();
}
extern "C"
{
  extern float __powf(float __x, float __y) throw();
}
extern "C"
{
  extern float sqrtf(float __x) throw();
}
extern "C"
{
  extern float __sqrtf(float __x) throw();
}
extern "C"
{
  extern float hypotf(float __x, float __y) throw();
}
extern "C"
{
  extern float __hypotf(float __x, float __y) throw();
}
extern "C"
{
  extern float cbrtf(float __x) throw();
}
extern "C"
{
  extern float __cbrtf(float __x) throw();
}
extern "C"
{
  extern float ceilf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __ceilf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float fabsf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __fabsf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float floorf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __floorf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float fmodf(float __x, float __y) throw();
}
extern "C"
{
  extern float __fmodf(float __x, float __y) throw();
}
extern "C"
{
  extern int isinff(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int finitef(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern float dremf(float __x, float __y) throw();
}
extern "C"
{
  extern float __dremf(float __x, float __y) throw();
}
extern "C"
{
  extern float significandf(float __x) throw();
}
extern "C"
{
  extern float __significandf(float __x) throw();
}
extern "C"
{
  extern float copysignf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __copysignf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float nanf(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __nanf(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern int isnanf(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern float j0f(float) throw();
}
extern "C"
{
  extern float __j0f(float) throw();
}
extern "C"
{
  extern float j1f(float) throw();
}
extern "C"
{
  extern float __j1f(float) throw();
}
extern "C"
{
  extern float jnf(int, float) throw();
}
extern "C"
{
  extern float __jnf(int, float) throw();
}
extern "C"
{
  extern float y0f(float) throw();
}
extern "C"
{
  extern float __y0f(float) throw();
}
extern "C"
{
  extern float y1f(float) throw();
}
extern "C"
{
  extern float __y1f(float) throw();
}
extern "C"
{
  extern float ynf(int, float) throw();
}
extern "C"
{
  extern float __ynf(int, float) throw();
}
extern "C"
{
  extern float erff(float) throw();
}
extern "C"
{
  extern float __erff(float) throw();
}
extern "C"
{
  extern float erfcf(float) throw();
}
extern "C"
{
  extern float __erfcf(float) throw();
}
extern "C"
{
  extern float lgammaf(float) throw();
}
extern "C"
{
  extern float __lgammaf(float) throw();
}
extern "C"
{
  extern float tgammaf(float) throw();
}
extern "C"
{
  extern float __tgammaf(float) throw();
}
extern "C"
{
  extern float gammaf(float) throw();
}
extern "C"
{
  extern float __gammaf(float) throw();
}
extern "C"
{
  extern float lgammaf_r(float, int *__signgamp) throw();
}
extern "C"
{
  extern float __lgammaf_r(float, int *__signgamp) throw();
}
extern "C"
{
  extern float rintf(float __x) throw();
}
extern "C"
{
  extern float __rintf(float __x) throw();
}
extern "C"
{
  extern float nextafterf(float __x, float __y) throw();
}
extern "C"
{
  extern float __nextafterf(float __x, float __y) throw();
}
extern "C"
{
  extern float nexttowardf(float __x, long double __y) throw();
}
extern "C"
{
  extern float __nexttowardf(float __x, long double __y) throw();
}
extern "C"
{
  extern float nextdownf(float __x) throw();
}
extern "C"
{
  extern float __nextdownf(float __x) throw();
}
extern "C"
{
  extern float nextupf(float __x) throw();
}
extern "C"
{
  extern float __nextupf(float __x) throw();
}
extern "C"
{
  extern float remainderf(float __x, float __y) throw();
}
extern "C"
{
  extern float __remainderf(float __x, float __y) throw();
}
extern "C"
{
  extern float scalbnf(float __x, int __n) throw();
}
extern "C"
{
  extern float __scalbnf(float __x, int __n) throw();
}
extern "C"
{
  extern int ilogbf(float __x) throw();
}
extern "C"
{
  extern int __ilogbf(float __x) throw();
}
extern "C"
{
  extern long int llogbf(float __x) throw();
}
extern "C"
{
  extern long int __llogbf(float __x) throw();
}
extern "C"
{
  extern float scalblnf(float __x, long int __n) throw();
}
extern "C"
{
  extern float __scalblnf(float __x, long int __n) throw();
}
extern "C"
{
  extern float nearbyintf(float __x) throw();
}
extern "C"
{
  extern float __nearbyintf(float __x) throw();
}
extern "C"
{
  extern float roundf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __roundf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float truncf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __truncf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float remquof(float __x, float __y, int *__quo) throw();
}
extern "C"
{
  extern float __remquof(float __x, float __y, int *__quo) throw();
}
extern "C"
{
  extern long int lrintf(float __x) throw();
}
extern "C"
{
  extern long int __lrintf(float __x) throw();
}
extern "C"
{
  extern long long int llrintf(float __x) throw();
}
extern "C"
{
  extern long long int __llrintf(float __x) throw();
}
extern "C"
{
  extern long int lroundf(float __x) throw();
}
extern "C"
{
  extern long int __lroundf(float __x) throw();
}
extern "C"
{
  extern long long int llroundf(float __x) throw();
}
extern "C"
{
  extern long long int __llroundf(float __x) throw();
}
extern "C"
{
  extern float fdimf(float __x, float __y) throw();
}
extern "C"
{
  extern float __fdimf(float __x, float __y) throw();
}
extern "C"
{
  extern float fmaxf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __fmaxf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float fminf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __fminf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float fmaf(float __x, float __y, float __z) throw();
}
extern "C"
{
  extern float __fmaf(float __x, float __y, float __z) throw();
}
extern "C"
{
  extern float roundevenf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __roundevenf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::__intmax_t fromfpf(float __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__intmax_t __fromfpf(float __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t ufromfpf(float __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t __ufromfpf(float __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__intmax_t fromfpxf(float __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__intmax_t __fromfpxf(float __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t ufromfpxf(float __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t __ufromfpxf(float __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern float fmaxmagf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __fmaxmagf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float fminmagf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __fminmagf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int totalorderf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int totalordermagf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int canonicalizef(float *__cx, const float *__x) throw();
}
extern "C"
{
  extern float getpayloadf(const float *__x) throw();
}
extern "C"
{
  extern float __getpayloadf(const float *__x) throw();
}
extern "C"
{
  extern int setpayloadf(float *__x, float __payload) throw();
}
extern "C"
{
  extern int setpayloadsigf(float *__x, float __payload) throw();
}
extern "C"
{
  extern float scalbf(float __x, float __n) throw();
}
extern "C"
{
  extern float __scalbf(float __x, float __n) throw();
}
extern "C"
{
  extern int __fpclassifyl(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __signbitl(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __isinfl(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __finitel(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __isnanl(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __iseqsigl(long double __x, long double __y) throw();
}
extern "C"
{
  extern int __issignalingl(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double acosl(long double __x) throw();
}
extern "C"
{
  extern long double __acosl(long double __x) throw();
}
extern "C"
{
  extern long double asinl(long double __x) throw();
}
extern "C"
{
  extern long double __asinl(long double __x) throw();
}
extern "C"
{
  extern long double atanl(long double __x) throw();
}
extern "C"
{
  extern long double __atanl(long double __x) throw();
}
extern "C"
{
  extern long double atan2l(long double __y, long double __x) throw();
}
extern "C"
{
  extern long double __atan2l(long double __y, long double __x) throw();
}
extern "C"
{
  extern long double cosl(long double __x) throw();
}
extern "C"
{
  extern long double __cosl(long double __x) throw();
}
extern "C"
{
  extern long double sinl(long double __x) throw();
}
extern "C"
{
  extern long double __sinl(long double __x) throw();
}
extern "C"
{
  extern long double tanl(long double __x) throw();
}
extern "C"
{
  extern long double __tanl(long double __x) throw();
}
extern "C"
{
  extern long double coshl(long double __x) throw();
}
extern "C"
{
  extern long double __coshl(long double __x) throw();
}
extern "C"
{
  extern long double sinhl(long double __x) throw();
}
extern "C"
{
  extern long double __sinhl(long double __x) throw();
}
extern "C"
{
  extern long double tanhl(long double __x) throw();
}
extern "C"
{
  extern long double __tanhl(long double __x) throw();
}
extern "C"
{
  extern void sincosl(long double __x, long double *__sinx, long double *__cosx) throw();
}
extern "C"
{
  extern void __sincosl(long double __x, long double *__sinx, long double *__cosx) throw();
}
extern "C"
{
  extern long double acoshl(long double __x) throw();
}
extern "C"
{
  extern long double __acoshl(long double __x) throw();
}
extern "C"
{
  extern long double asinhl(long double __x) throw();
}
extern "C"
{
  extern long double __asinhl(long double __x) throw();
}
extern "C"
{
  extern long double atanhl(long double __x) throw();
}
extern "C"
{
  extern long double __atanhl(long double __x) throw();
}
extern "C"
{
  extern long double expl(long double __x) throw();
}
extern "C"
{
  extern long double __expl(long double __x) throw();
}
extern "C"
{
  extern long double frexpl(long double __x, int *__exponent) throw();
}
extern "C"
{
  extern long double __frexpl(long double __x, int *__exponent) throw();
}
extern "C"
{
  extern long double ldexpl(long double __x, int __exponent) throw();
}
extern "C"
{
  extern long double __ldexpl(long double __x, int __exponent) throw();
}
extern "C"
{
  extern long double logl(long double __x) throw();
}
extern "C"
{
  extern long double __logl(long double __x) throw();
}
extern "C"
{
  extern long double log10l(long double __x) throw();
}
extern "C"
{
  extern long double __log10l(long double __x) throw();
}
extern "C"
{
  extern long double modfl(long double __x, long double *__iptr) throw();
}
extern "C"
{
  extern long double __modfl(long double __x, long double *__iptr) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern long double exp10l(long double __x) throw();
}
extern "C"
{
  extern long double __exp10l(long double __x) throw();
}
extern "C"
{
  extern long double expm1l(long double __x) throw();
}
extern "C"
{
  extern long double __expm1l(long double __x) throw();
}
extern "C"
{
  extern long double log1pl(long double __x) throw();
}
extern "C"
{
  extern long double __log1pl(long double __x) throw();
}
extern "C"
{
  extern long double logbl(long double __x) throw();
}
extern "C"
{
  extern long double __logbl(long double __x) throw();
}
extern "C"
{
  extern long double exp2l(long double __x) throw();
}
extern "C"
{
  extern long double __exp2l(long double __x) throw();
}
extern "C"
{
  extern long double log2l(long double __x) throw();
}
extern "C"
{
  extern long double __log2l(long double __x) throw();
}
extern "C"
{
  extern long double powl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __powl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double sqrtl(long double __x) throw();
}
extern "C"
{
  extern long double __sqrtl(long double __x) throw();
}
extern "C"
{
  extern long double hypotl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __hypotl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double cbrtl(long double __x) throw();
}
extern "C"
{
  extern long double __cbrtl(long double __x) throw();
}
extern "C"
{
  extern long double ceill(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __ceill(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double fabsl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __fabsl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double floorl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __floorl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double fmodl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __fmodl(long double __x, long double __y) throw();
}
extern "C"
{
  extern int isinfl(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int finitel(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double dreml(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __dreml(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double significandl(long double __x) throw();
}
extern "C"
{
  extern long double __significandl(long double __x) throw();
}
extern "C"
{
  extern long double copysignl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __copysignl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double nanl(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __nanl(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern int isnanl(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double j0l(long double) throw();
}
extern "C"
{
  extern long double __j0l(long double) throw();
}
extern "C"
{
  extern long double j1l(long double) throw();
}
extern "C"
{
  extern long double __j1l(long double) throw();
}
extern "C"
{
  extern long double jnl(int, long double) throw();
}
extern "C"
{
  extern long double __jnl(int, long double) throw();
}
extern "C"
{
  extern long double y0l(long double) throw();
}
extern "C"
{
  extern long double __y0l(long double) throw();
}
extern "C"
{
  extern long double y1l(long double) throw();
}
extern "C"
{
  extern long double __y1l(long double) throw();
}
extern "C"
{
  extern long double ynl(int, long double) throw();
}
extern "C"
{
  extern long double __ynl(int, long double) throw();
}
extern "C"
{
  extern long double erfl(long double) throw();
}
extern "C"
{
  extern long double __erfl(long double) throw();
}
extern "C"
{
  extern long double erfcl(long double) throw();
}
extern "C"
{
  extern long double __erfcl(long double) throw();
}
extern "C"
{
  extern long double lgammal(long double) throw();
}
extern "C"
{
  extern long double __lgammal(long double) throw();
}
extern "C"
{
  extern long double tgammal(long double) throw();
}
extern "C"
{
  extern long double __tgammal(long double) throw();
}
extern "C"
{
  extern long double gammal(long double) throw();
}
extern "C"
{
  extern long double __gammal(long double) throw();
}
extern "C"
{
  extern long double lgammal_r(long double, int *__signgamp) throw();
}
extern "C"
{
  extern long double __lgammal_r(long double, int *__signgamp) throw();
}
extern "C"
{
  extern long double rintl(long double __x) throw();
}
extern "C"
{
  extern long double __rintl(long double __x) throw();
}
extern "C"
{
  extern long double nextafterl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __nextafterl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double nexttowardl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __nexttowardl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double nextdownl(long double __x) throw();
}
extern "C"
{
  extern long double __nextdownl(long double __x) throw();
}
extern "C"
{
  extern long double nextupl(long double __x) throw();
}
extern "C"
{
  extern long double __nextupl(long double __x) throw();
}
extern "C"
{
  extern long double remainderl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __remainderl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double scalbnl(long double __x, int __n) throw();
}
extern "C"
{
  extern long double __scalbnl(long double __x, int __n) throw();
}
extern "C"
{
  extern int ilogbl(long double __x) throw();
}
extern "C"
{
  extern int __ilogbl(long double __x) throw();
}
extern "C"
{
  extern long int llogbl(long double __x) throw();
}
extern "C"
{
  extern long int __llogbl(long double __x) throw();
}
extern "C"
{
  extern long double scalblnl(long double __x, long int __n) throw();
}
extern "C"
{
  extern long double __scalblnl(long double __x, long int __n) throw();
}
extern "C"
{
  extern long double nearbyintl(long double __x) throw();
}
extern "C"
{
  extern long double __nearbyintl(long double __x) throw();
}
extern "C"
{
  extern long double roundl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __roundl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double truncl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __truncl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double remquol(long double __x, long double __y, int *__quo) throw();
}
extern "C"
{
  extern long double __remquol(long double __x, long double __y, int *__quo) throw();
}
extern "C"
{
  extern long int lrintl(long double __x) throw();
}
extern "C"
{
  extern long int __lrintl(long double __x) throw();
}
extern "C"
{
  extern long long int llrintl(long double __x) throw();
}
extern "C"
{
  extern long long int __llrintl(long double __x) throw();
}
extern "C"
{
  extern long int lroundl(long double __x) throw();
}
extern "C"
{
  extern long int __lroundl(long double __x) throw();
}
extern "C"
{
  extern long long int llroundl(long double __x) throw();
}
extern "C"
{
  extern long long int __llroundl(long double __x) throw();
}
extern "C"
{
  extern long double fdiml(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __fdiml(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double fmaxl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __fmaxl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double fminl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __fminl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double fmal(long double __x, long double __y, long double __z) throw();
}
extern "C"
{
  extern long double __fmal(long double __x, long double __y, long double __z) throw();
}
extern "C"
{
  extern long double roundevenl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __roundevenl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::__intmax_t fromfpl(long double __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__intmax_t __fromfpl(long double __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t ufromfpl(long double __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t __ufromfpl(long double __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__intmax_t fromfpxl(long double __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__intmax_t __fromfpxl(long double __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t ufromfpxl(long double __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t __ufromfpxl(long double __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern long double fmaxmagl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __fmaxmagl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double fminmagl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __fminmagl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int totalorderl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int totalordermagl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int canonicalizel(long double *__cx, const long double *__x) throw();
}
extern "C"
{
  extern long double getpayloadl(const long double *__x) throw();
}
extern "C"
{
  extern long double __getpayloadl(const long double *__x) throw();
}
extern "C"
{
  extern int setpayloadl(long double *__x, long double __payload) throw();
}
extern "C"
{
  extern int setpayloadsigl(long double *__x, long double __payload) throw();
}
extern "C"
{
  extern long double scalbl(long double __x, long double __n) throw();
}
extern "C"
{
  extern long double __scalbl(long double __x, long double __n) throw();
}
extern "C"
{
  extern ::_Float32 acosf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __acosf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 asinf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __asinf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 atanf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __atanf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 atan2f32(::_Float32 __y, ::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __atan2f32(::_Float32 __y, ::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 cosf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __cosf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 sinf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __sinf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 tanf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __tanf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 coshf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __coshf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 sinhf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __sinhf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 tanhf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __tanhf32(::_Float32 __x) throw();
}
extern "C"
{
  extern void sincosf32(::_Float32 __x, ::_Float32 *__sinx, ::_Float32 *__cosx) throw();
}
extern "C"
{
  extern void __sincosf32(::_Float32 __x, ::_Float32 *__sinx, ::_Float32 *__cosx) throw();
}
extern "C"
{
  extern ::_Float32 acoshf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __acoshf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 asinhf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __asinhf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 atanhf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __atanhf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 expf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __expf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 frexpf32(::_Float32 __x, int *__exponent) throw();
}
extern "C"
{
  extern ::_Float32 __frexpf32(::_Float32 __x, int *__exponent) throw();
}
extern "C"
{
  extern ::_Float32 ldexpf32(::_Float32 __x, int __exponent) throw();
}
extern "C"
{
  extern ::_Float32 __ldexpf32(::_Float32 __x, int __exponent) throw();
}
extern "C"
{
  extern ::_Float32 logf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __logf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 log10f32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __log10f32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 modff32(::_Float32 __x, ::_Float32 *__iptr) throw();
}
extern "C"
{
  extern ::_Float32 __modff32(::_Float32 __x, ::_Float32 *__iptr) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern ::_Float32 exp10f32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __exp10f32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 expm1f32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __expm1f32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 log1pf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __log1pf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 logbf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __logbf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 exp2f32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __exp2f32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 log2f32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __log2f32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 powf32(::_Float32 __x, ::_Float32 __y) throw();
}
extern "C"
{
  extern ::_Float32 __powf32(::_Float32 __x, ::_Float32 __y) throw();
}
extern "C"
{
  extern ::_Float32 sqrtf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __sqrtf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 hypotf32(::_Float32 __x, ::_Float32 __y) throw();
}
extern "C"
{
  extern ::_Float32 __hypotf32(::_Float32 __x, ::_Float32 __y) throw();
}
extern "C"
{
  extern ::_Float32 cbrtf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __cbrtf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 ceilf32(::_Float32 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32 __ceilf32(::_Float32 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32 fabsf32(::_Float32 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32 __fabsf32(::_Float32 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32 floorf32(::_Float32 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32 __floorf32(::_Float32 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32 fmodf32(::_Float32 __x, ::_Float32 __y) throw();
}
extern "C"
{
  extern ::_Float32 __fmodf32(::_Float32 __x, ::_Float32 __y) throw();
}
extern "C"
{
  extern ::_Float32 copysignf32(::_Float32 __x, ::_Float32 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32 __copysignf32(::_Float32 __x, ::_Float32 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32 nanf32(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32 __nanf32(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32 j0f32(::_Float32) throw();
}
extern "C"
{
  extern ::_Float32 __j0f32(::_Float32) throw();
}
extern "C"
{
  extern ::_Float32 j1f32(::_Float32) throw();
}
extern "C"
{
  extern ::_Float32 __j1f32(::_Float32) throw();
}
extern "C"
{
  extern ::_Float32 jnf32(int, ::_Float32) throw();
}
extern "C"
{
  extern ::_Float32 __jnf32(int, ::_Float32) throw();
}
extern "C"
{
  extern ::_Float32 y0f32(::_Float32) throw();
}
extern "C"
{
  extern ::_Float32 __y0f32(::_Float32) throw();
}
extern "C"
{
  extern ::_Float32 y1f32(::_Float32) throw();
}
extern "C"
{
  extern ::_Float32 __y1f32(::_Float32) throw();
}
extern "C"
{
  extern ::_Float32 ynf32(int, ::_Float32) throw();
}
extern "C"
{
  extern ::_Float32 __ynf32(int, ::_Float32) throw();
}
extern "C"
{
  extern ::_Float32 erff32(::_Float32) throw();
}
extern "C"
{
  extern ::_Float32 __erff32(::_Float32) throw();
}
extern "C"
{
  extern ::_Float32 erfcf32(::_Float32) throw();
}
extern "C"
{
  extern ::_Float32 __erfcf32(::_Float32) throw();
}
extern "C"
{
  extern ::_Float32 lgammaf32(::_Float32) throw();
}
extern "C"
{
  extern ::_Float32 __lgammaf32(::_Float32) throw();
}
extern "C"
{
  extern ::_Float32 tgammaf32(::_Float32) throw();
}
extern "C"
{
  extern ::_Float32 __tgammaf32(::_Float32) throw();
}
extern "C"
{
  extern ::_Float32 lgammaf32_r(::_Float32, int *__signgamp) throw();
}
extern "C"
{
  extern ::_Float32 __lgammaf32_r(::_Float32, int *__signgamp) throw();
}
extern "C"
{
  extern ::_Float32 rintf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __rintf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 nextafterf32(::_Float32 __x, ::_Float32 __y) throw();
}
extern "C"
{
  extern ::_Float32 __nextafterf32(::_Float32 __x, ::_Float32 __y) throw();
}
extern "C"
{
  extern ::_Float32 nextdownf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __nextdownf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 nextupf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __nextupf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 remainderf32(::_Float32 __x, ::_Float32 __y) throw();
}
extern "C"
{
  extern ::_Float32 __remainderf32(::_Float32 __x, ::_Float32 __y) throw();
}
extern "C"
{
  extern ::_Float32 scalbnf32(::_Float32 __x, int __n) throw();
}
extern "C"
{
  extern ::_Float32 __scalbnf32(::_Float32 __x, int __n) throw();
}
extern "C"
{
  extern int ilogbf32(::_Float32 __x) throw();
}
extern "C"
{
  extern int __ilogbf32(::_Float32 __x) throw();
}
extern "C"
{
  extern long int llogbf32(::_Float32 __x) throw();
}
extern "C"
{
  extern long int __llogbf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 scalblnf32(::_Float32 __x, long int __n) throw();
}
extern "C"
{
  extern ::_Float32 __scalblnf32(::_Float32 __x, long int __n) throw();
}
extern "C"
{
  extern ::_Float32 nearbyintf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 __nearbyintf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 roundf32(::_Float32 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32 __roundf32(::_Float32 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32 truncf32(::_Float32 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32 __truncf32(::_Float32 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32 remquof32(::_Float32 __x, ::_Float32 __y, int *__quo) throw();
}
extern "C"
{
  extern ::_Float32 __remquof32(::_Float32 __x, ::_Float32 __y, int *__quo) throw();
}
extern "C"
{
  extern long int lrintf32(::_Float32 __x) throw();
}
extern "C"
{
  extern long int __lrintf32(::_Float32 __x) throw();
}
extern "C"
{
  extern long long int llrintf32(::_Float32 __x) throw();
}
extern "C"
{
  extern long long int __llrintf32(::_Float32 __x) throw();
}
extern "C"
{
  extern long int lroundf32(::_Float32 __x) throw();
}
extern "C"
{
  extern long int __lroundf32(::_Float32 __x) throw();
}
extern "C"
{
  extern long long int llroundf32(::_Float32 __x) throw();
}
extern "C"
{
  extern long long int __llroundf32(::_Float32 __x) throw();
}
extern "C"
{
  extern ::_Float32 fdimf32(::_Float32 __x, ::_Float32 __y) throw();
}
extern "C"
{
  extern ::_Float32 __fdimf32(::_Float32 __x, ::_Float32 __y) throw();
}
extern "C"
{
  extern ::_Float32 fmaxf32(::_Float32 __x, ::_Float32 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32 __fmaxf32(::_Float32 __x, ::_Float32 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32 fminf32(::_Float32 __x, ::_Float32 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32 __fminf32(::_Float32 __x, ::_Float32 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32 fmaf32(::_Float32 __x, ::_Float32 __y, ::_Float32 __z) throw();
}
extern "C"
{
  extern ::_Float32 __fmaf32(::_Float32 __x, ::_Float32 __y, ::_Float32 __z) throw();
}
extern "C"
{
  extern ::_Float32 roundevenf32(::_Float32 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32 __roundevenf32(::_Float32 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::__intmax_t fromfpf32(::_Float32 __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__intmax_t __fromfpf32(::_Float32 __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t ufromfpf32(::_Float32 __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t __ufromfpf32(::_Float32 __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__intmax_t fromfpxf32(::_Float32 __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__intmax_t __fromfpxf32(::_Float32 __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t ufromfpxf32(::_Float32 __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t __ufromfpxf32(::_Float32 __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::_Float32 fmaxmagf32(::_Float32 __x, ::_Float32 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32 __fmaxmagf32(::_Float32 __x, ::_Float32 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32 fminmagf32(::_Float32 __x, ::_Float32 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32 __fminmagf32(::_Float32 __x, ::_Float32 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int totalorderf32(::_Float32 __x, ::_Float32 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int totalordermagf32(::_Float32 __x, ::_Float32 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int canonicalizef32(::_Float32 *__cx, const ::_Float32 *__x) throw();
}
extern "C"
{
  extern ::_Float32 getpayloadf32(const ::_Float32 *__x) throw();
}
extern "C"
{
  extern ::_Float32 __getpayloadf32(const ::_Float32 *__x) throw();
}
extern "C"
{
  extern int setpayloadf32(::_Float32 *__x, ::_Float32 __payload) throw();
}
extern "C"
{
  extern int setpayloadsigf32(::_Float32 *__x, ::_Float32 __payload) throw();
}
extern "C"
{
  extern ::_Float64 acosf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __acosf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 asinf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __asinf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 atanf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __atanf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 atan2f64(::_Float64 __y, ::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __atan2f64(::_Float64 __y, ::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 cosf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __cosf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 sinf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __sinf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 tanf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __tanf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 coshf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __coshf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 sinhf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __sinhf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 tanhf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __tanhf64(::_Float64 __x) throw();
}
extern "C"
{
  extern void sincosf64(::_Float64 __x, ::_Float64 *__sinx, ::_Float64 *__cosx) throw();
}
extern "C"
{
  extern void __sincosf64(::_Float64 __x, ::_Float64 *__sinx, ::_Float64 *__cosx) throw();
}
extern "C"
{
  extern ::_Float64 acoshf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __acoshf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 asinhf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __asinhf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 atanhf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __atanhf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 expf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __expf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 frexpf64(::_Float64 __x, int *__exponent) throw();
}
extern "C"
{
  extern ::_Float64 __frexpf64(::_Float64 __x, int *__exponent) throw();
}
extern "C"
{
  extern ::_Float64 ldexpf64(::_Float64 __x, int __exponent) throw();
}
extern "C"
{
  extern ::_Float64 __ldexpf64(::_Float64 __x, int __exponent) throw();
}
extern "C"
{
  extern ::_Float64 logf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __logf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 log10f64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __log10f64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 modff64(::_Float64 __x, ::_Float64 *__iptr) throw();
}
extern "C"
{
  extern ::_Float64 __modff64(::_Float64 __x, ::_Float64 *__iptr) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern ::_Float64 exp10f64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __exp10f64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 expm1f64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __expm1f64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 log1pf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __log1pf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 logbf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __logbf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 exp2f64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __exp2f64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 log2f64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __log2f64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 powf64(::_Float64 __x, ::_Float64 __y) throw();
}
extern "C"
{
  extern ::_Float64 __powf64(::_Float64 __x, ::_Float64 __y) throw();
}
extern "C"
{
  extern ::_Float64 sqrtf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __sqrtf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 hypotf64(::_Float64 __x, ::_Float64 __y) throw();
}
extern "C"
{
  extern ::_Float64 __hypotf64(::_Float64 __x, ::_Float64 __y) throw();
}
extern "C"
{
  extern ::_Float64 cbrtf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __cbrtf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 ceilf64(::_Float64 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64 __ceilf64(::_Float64 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64 fabsf64(::_Float64 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64 __fabsf64(::_Float64 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64 floorf64(::_Float64 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64 __floorf64(::_Float64 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64 fmodf64(::_Float64 __x, ::_Float64 __y) throw();
}
extern "C"
{
  extern ::_Float64 __fmodf64(::_Float64 __x, ::_Float64 __y) throw();
}
extern "C"
{
  extern ::_Float64 copysignf64(::_Float64 __x, ::_Float64 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64 __copysignf64(::_Float64 __x, ::_Float64 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64 nanf64(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64 __nanf64(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64 j0f64(::_Float64) throw();
}
extern "C"
{
  extern ::_Float64 __j0f64(::_Float64) throw();
}
extern "C"
{
  extern ::_Float64 j1f64(::_Float64) throw();
}
extern "C"
{
  extern ::_Float64 __j1f64(::_Float64) throw();
}
extern "C"
{
  extern ::_Float64 jnf64(int, ::_Float64) throw();
}
extern "C"
{
  extern ::_Float64 __jnf64(int, ::_Float64) throw();
}
extern "C"
{
  extern ::_Float64 y0f64(::_Float64) throw();
}
extern "C"
{
  extern ::_Float64 __y0f64(::_Float64) throw();
}
extern "C"
{
  extern ::_Float64 y1f64(::_Float64) throw();
}
extern "C"
{
  extern ::_Float64 __y1f64(::_Float64) throw();
}
extern "C"
{
  extern ::_Float64 ynf64(int, ::_Float64) throw();
}
extern "C"
{
  extern ::_Float64 __ynf64(int, ::_Float64) throw();
}
extern "C"
{
  extern ::_Float64 erff64(::_Float64) throw();
}
extern "C"
{
  extern ::_Float64 __erff64(::_Float64) throw();
}
extern "C"
{
  extern ::_Float64 erfcf64(::_Float64) throw();
}
extern "C"
{
  extern ::_Float64 __erfcf64(::_Float64) throw();
}
extern "C"
{
  extern ::_Float64 lgammaf64(::_Float64) throw();
}
extern "C"
{
  extern ::_Float64 __lgammaf64(::_Float64) throw();
}
extern "C"
{
  extern ::_Float64 tgammaf64(::_Float64) throw();
}
extern "C"
{
  extern ::_Float64 __tgammaf64(::_Float64) throw();
}
extern "C"
{
  extern ::_Float64 lgammaf64_r(::_Float64, int *__signgamp) throw();
}
extern "C"
{
  extern ::_Float64 __lgammaf64_r(::_Float64, int *__signgamp) throw();
}
extern "C"
{
  extern ::_Float64 rintf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __rintf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 nextafterf64(::_Float64 __x, ::_Float64 __y) throw();
}
extern "C"
{
  extern ::_Float64 __nextafterf64(::_Float64 __x, ::_Float64 __y) throw();
}
extern "C"
{
  extern ::_Float64 nextdownf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __nextdownf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 nextupf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __nextupf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 remainderf64(::_Float64 __x, ::_Float64 __y) throw();
}
extern "C"
{
  extern ::_Float64 __remainderf64(::_Float64 __x, ::_Float64 __y) throw();
}
extern "C"
{
  extern ::_Float64 scalbnf64(::_Float64 __x, int __n) throw();
}
extern "C"
{
  extern ::_Float64 __scalbnf64(::_Float64 __x, int __n) throw();
}
extern "C"
{
  extern int ilogbf64(::_Float64 __x) throw();
}
extern "C"
{
  extern int __ilogbf64(::_Float64 __x) throw();
}
extern "C"
{
  extern long int llogbf64(::_Float64 __x) throw();
}
extern "C"
{
  extern long int __llogbf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 scalblnf64(::_Float64 __x, long int __n) throw();
}
extern "C"
{
  extern ::_Float64 __scalblnf64(::_Float64 __x, long int __n) throw();
}
extern "C"
{
  extern ::_Float64 nearbyintf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 __nearbyintf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 roundf64(::_Float64 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64 __roundf64(::_Float64 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64 truncf64(::_Float64 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64 __truncf64(::_Float64 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64 remquof64(::_Float64 __x, ::_Float64 __y, int *__quo) throw();
}
extern "C"
{
  extern ::_Float64 __remquof64(::_Float64 __x, ::_Float64 __y, int *__quo) throw();
}
extern "C"
{
  extern long int lrintf64(::_Float64 __x) throw();
}
extern "C"
{
  extern long int __lrintf64(::_Float64 __x) throw();
}
extern "C"
{
  extern long long int llrintf64(::_Float64 __x) throw();
}
extern "C"
{
  extern long long int __llrintf64(::_Float64 __x) throw();
}
extern "C"
{
  extern long int lroundf64(::_Float64 __x) throw();
}
extern "C"
{
  extern long int __lroundf64(::_Float64 __x) throw();
}
extern "C"
{
  extern long long int llroundf64(::_Float64 __x) throw();
}
extern "C"
{
  extern long long int __llroundf64(::_Float64 __x) throw();
}
extern "C"
{
  extern ::_Float64 fdimf64(::_Float64 __x, ::_Float64 __y) throw();
}
extern "C"
{
  extern ::_Float64 __fdimf64(::_Float64 __x, ::_Float64 __y) throw();
}
extern "C"
{
  extern ::_Float64 fmaxf64(::_Float64 __x, ::_Float64 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64 __fmaxf64(::_Float64 __x, ::_Float64 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64 fminf64(::_Float64 __x, ::_Float64 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64 __fminf64(::_Float64 __x, ::_Float64 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64 fmaf64(::_Float64 __x, ::_Float64 __y, ::_Float64 __z) throw();
}
extern "C"
{
  extern ::_Float64 __fmaf64(::_Float64 __x, ::_Float64 __y, ::_Float64 __z) throw();
}
extern "C"
{
  extern ::_Float64 roundevenf64(::_Float64 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64 __roundevenf64(::_Float64 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::__intmax_t fromfpf64(::_Float64 __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__intmax_t __fromfpf64(::_Float64 __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t ufromfpf64(::_Float64 __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t __ufromfpf64(::_Float64 __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__intmax_t fromfpxf64(::_Float64 __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__intmax_t __fromfpxf64(::_Float64 __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t ufromfpxf64(::_Float64 __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t __ufromfpxf64(::_Float64 __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::_Float64 fmaxmagf64(::_Float64 __x, ::_Float64 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64 __fmaxmagf64(::_Float64 __x, ::_Float64 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64 fminmagf64(::_Float64 __x, ::_Float64 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64 __fminmagf64(::_Float64 __x, ::_Float64 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int totalorderf64(::_Float64 __x, ::_Float64 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int totalordermagf64(::_Float64 __x, ::_Float64 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int canonicalizef64(::_Float64 *__cx, const ::_Float64 *__x) throw();
}
extern "C"
{
  extern ::_Float64 getpayloadf64(const ::_Float64 *__x) throw();
}
extern "C"
{
  extern ::_Float64 __getpayloadf64(const ::_Float64 *__x) throw();
}
extern "C"
{
  extern int setpayloadf64(::_Float64 *__x, ::_Float64 __payload) throw();
}
extern "C"
{
  extern int setpayloadsigf64(::_Float64 *__x, ::_Float64 __payload) throw();
}
extern "C"
{
  extern int __fpclassifyf128(::_Float128 __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __signbitf128(::_Float128 __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __isinff128(::_Float128 __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __finitef128(::_Float128 __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __isnanf128(::_Float128 __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __iseqsigf128(::_Float128 __x, ::_Float128 __y) throw();
}
extern "C"
{
  extern int __issignalingf128(::_Float128 __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float128 acosf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __acosf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 asinf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __asinf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 atanf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __atanf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 atan2f128(::_Float128 __y, ::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __atan2f128(::_Float128 __y, ::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 cosf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __cosf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 sinf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __sinf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 tanf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __tanf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 coshf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __coshf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 sinhf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __sinhf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 tanhf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __tanhf128(::_Float128 __x) throw();
}
extern "C"
{
  extern void sincosf128(::_Float128 __x, ::_Float128 *__sinx, ::_Float128 *__cosx) throw();
}
extern "C"
{
  extern void __sincosf128(::_Float128 __x, ::_Float128 *__sinx, ::_Float128 *__cosx) throw();
}
extern "C"
{
  extern ::_Float128 acoshf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __acoshf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 asinhf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __asinhf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 atanhf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __atanhf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 expf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __expf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 frexpf128(::_Float128 __x, int *__exponent) throw();
}
extern "C"
{
  extern ::_Float128 __frexpf128(::_Float128 __x, int *__exponent) throw();
}
extern "C"
{
  extern ::_Float128 ldexpf128(::_Float128 __x, int __exponent) throw();
}
extern "C"
{
  extern ::_Float128 __ldexpf128(::_Float128 __x, int __exponent) throw();
}
extern "C"
{
  extern ::_Float128 logf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __logf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 log10f128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __log10f128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 modff128(::_Float128 __x, ::_Float128 *__iptr) throw();
}
extern "C"
{
  extern ::_Float128 __modff128(::_Float128 __x, ::_Float128 *__iptr) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern ::_Float128 exp10f128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __exp10f128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 expm1f128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __expm1f128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 log1pf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __log1pf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 logbf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __logbf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 exp2f128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __exp2f128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 log2f128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __log2f128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 powf128(::_Float128 __x, ::_Float128 __y) throw();
}
extern "C"
{
  extern ::_Float128 __powf128(::_Float128 __x, ::_Float128 __y) throw();
}
extern "C"
{
  extern ::_Float128 sqrtf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __sqrtf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 hypotf128(::_Float128 __x, ::_Float128 __y) throw();
}
extern "C"
{
  extern ::_Float128 __hypotf128(::_Float128 __x, ::_Float128 __y) throw();
}
extern "C"
{
  extern ::_Float128 cbrtf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __cbrtf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 ceilf128(::_Float128 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float128 __ceilf128(::_Float128 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float128 fabsf128(::_Float128 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float128 __fabsf128(::_Float128 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float128 floorf128(::_Float128 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float128 __floorf128(::_Float128 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float128 fmodf128(::_Float128 __x, ::_Float128 __y) throw();
}
extern "C"
{
  extern ::_Float128 __fmodf128(::_Float128 __x, ::_Float128 __y) throw();
}
extern "C"
{
  extern ::_Float128 copysignf128(::_Float128 __x, ::_Float128 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float128 __copysignf128(::_Float128 __x, ::_Float128 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float128 nanf128(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float128 __nanf128(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float128 j0f128(::_Float128) throw();
}
extern "C"
{
  extern ::_Float128 __j0f128(::_Float128) throw();
}
extern "C"
{
  extern ::_Float128 j1f128(::_Float128) throw();
}
extern "C"
{
  extern ::_Float128 __j1f128(::_Float128) throw();
}
extern "C"
{
  extern ::_Float128 jnf128(int, ::_Float128) throw();
}
extern "C"
{
  extern ::_Float128 __jnf128(int, ::_Float128) throw();
}
extern "C"
{
  extern ::_Float128 y0f128(::_Float128) throw();
}
extern "C"
{
  extern ::_Float128 __y0f128(::_Float128) throw();
}
extern "C"
{
  extern ::_Float128 y1f128(::_Float128) throw();
}
extern "C"
{
  extern ::_Float128 __y1f128(::_Float128) throw();
}
extern "C"
{
  extern ::_Float128 ynf128(int, ::_Float128) throw();
}
extern "C"
{
  extern ::_Float128 __ynf128(int, ::_Float128) throw();
}
extern "C"
{
  extern ::_Float128 erff128(::_Float128) throw();
}
extern "C"
{
  extern ::_Float128 __erff128(::_Float128) throw();
}
extern "C"
{
  extern ::_Float128 erfcf128(::_Float128) throw();
}
extern "C"
{
  extern ::_Float128 __erfcf128(::_Float128) throw();
}
extern "C"
{
  extern ::_Float128 lgammaf128(::_Float128) throw();
}
extern "C"
{
  extern ::_Float128 __lgammaf128(::_Float128) throw();
}
extern "C"
{
  extern ::_Float128 tgammaf128(::_Float128) throw();
}
extern "C"
{
  extern ::_Float128 __tgammaf128(::_Float128) throw();
}
extern "C"
{
  extern ::_Float128 lgammaf128_r(::_Float128, int *__signgamp) throw();
}
extern "C"
{
  extern ::_Float128 __lgammaf128_r(::_Float128, int *__signgamp) throw();
}
extern "C"
{
  extern ::_Float128 rintf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __rintf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 nextafterf128(::_Float128 __x, ::_Float128 __y) throw();
}
extern "C"
{
  extern ::_Float128 __nextafterf128(::_Float128 __x, ::_Float128 __y) throw();
}
extern "C"
{
  extern ::_Float128 nextdownf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __nextdownf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 nextupf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __nextupf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 remainderf128(::_Float128 __x, ::_Float128 __y) throw();
}
extern "C"
{
  extern ::_Float128 __remainderf128(::_Float128 __x, ::_Float128 __y) throw();
}
extern "C"
{
  extern ::_Float128 scalbnf128(::_Float128 __x, int __n) throw();
}
extern "C"
{
  extern ::_Float128 __scalbnf128(::_Float128 __x, int __n) throw();
}
extern "C"
{
  extern int ilogbf128(::_Float128 __x) throw();
}
extern "C"
{
  extern int __ilogbf128(::_Float128 __x) throw();
}
extern "C"
{
  extern long int llogbf128(::_Float128 __x) throw();
}
extern "C"
{
  extern long int __llogbf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 scalblnf128(::_Float128 __x, long int __n) throw();
}
extern "C"
{
  extern ::_Float128 __scalblnf128(::_Float128 __x, long int __n) throw();
}
extern "C"
{
  extern ::_Float128 nearbyintf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 __nearbyintf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 roundf128(::_Float128 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float128 __roundf128(::_Float128 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float128 truncf128(::_Float128 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float128 __truncf128(::_Float128 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float128 remquof128(::_Float128 __x, ::_Float128 __y, int *__quo) throw();
}
extern "C"
{
  extern ::_Float128 __remquof128(::_Float128 __x, ::_Float128 __y, int *__quo) throw();
}
extern "C"
{
  extern long int lrintf128(::_Float128 __x) throw();
}
extern "C"
{
  extern long int __lrintf128(::_Float128 __x) throw();
}
extern "C"
{
  extern long long int llrintf128(::_Float128 __x) throw();
}
extern "C"
{
  extern long long int __llrintf128(::_Float128 __x) throw();
}
extern "C"
{
  extern long int lroundf128(::_Float128 __x) throw();
}
extern "C"
{
  extern long int __lroundf128(::_Float128 __x) throw();
}
extern "C"
{
  extern long long int llroundf128(::_Float128 __x) throw();
}
extern "C"
{
  extern long long int __llroundf128(::_Float128 __x) throw();
}
extern "C"
{
  extern ::_Float128 fdimf128(::_Float128 __x, ::_Float128 __y) throw();
}
extern "C"
{
  extern ::_Float128 __fdimf128(::_Float128 __x, ::_Float128 __y) throw();
}
extern "C"
{
  extern ::_Float128 fmaxf128(::_Float128 __x, ::_Float128 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float128 __fmaxf128(::_Float128 __x, ::_Float128 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float128 fminf128(::_Float128 __x, ::_Float128 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float128 __fminf128(::_Float128 __x, ::_Float128 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float128 fmaf128(::_Float128 __x, ::_Float128 __y, ::_Float128 __z) throw();
}
extern "C"
{
  extern ::_Float128 __fmaf128(::_Float128 __x, ::_Float128 __y, ::_Float128 __z) throw();
}
extern "C"
{
  extern ::_Float128 roundevenf128(::_Float128 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float128 __roundevenf128(::_Float128 __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::__intmax_t fromfpf128(::_Float128 __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__intmax_t __fromfpf128(::_Float128 __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t ufromfpf128(::_Float128 __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t __ufromfpf128(::_Float128 __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__intmax_t fromfpxf128(::_Float128 __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__intmax_t __fromfpxf128(::_Float128 __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t ufromfpxf128(::_Float128 __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t __ufromfpxf128(::_Float128 __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::_Float128 fmaxmagf128(::_Float128 __x, ::_Float128 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float128 __fmaxmagf128(::_Float128 __x, ::_Float128 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float128 fminmagf128(::_Float128 __x, ::_Float128 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float128 __fminmagf128(::_Float128 __x, ::_Float128 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int totalorderf128(::_Float128 __x, ::_Float128 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int totalordermagf128(::_Float128 __x, ::_Float128 __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int canonicalizef128(::_Float128 *__cx, const ::_Float128 *__x) throw();
}
extern "C"
{
  extern ::_Float128 getpayloadf128(const ::_Float128 *__x) throw();
}
extern "C"
{
  extern ::_Float128 __getpayloadf128(const ::_Float128 *__x) throw();
}
extern "C"
{
  extern int setpayloadf128(::_Float128 *__x, ::_Float128 __payload) throw();
}
extern "C"
{
  extern int setpayloadsigf128(::_Float128 *__x, ::_Float128 __payload) throw();
}
extern "C"
{
  extern ::_Float32x acosf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __acosf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x asinf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __asinf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x atanf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __atanf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x atan2f32x(::_Float32x __y, ::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __atan2f32x(::_Float32x __y, ::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x cosf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __cosf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x sinf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __sinf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x tanf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __tanf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x coshf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __coshf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x sinhf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __sinhf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x tanhf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __tanhf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern void sincosf32x(::_Float32x __x, ::_Float32x *__sinx, ::_Float32x *__cosx) throw();
}
extern "C"
{
  extern void __sincosf32x(::_Float32x __x, ::_Float32x *__sinx, ::_Float32x *__cosx) throw();
}
extern "C"
{
  extern ::_Float32x acoshf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __acoshf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x asinhf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __asinhf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x atanhf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __atanhf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x expf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __expf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x frexpf32x(::_Float32x __x, int *__exponent) throw();
}
extern "C"
{
  extern ::_Float32x __frexpf32x(::_Float32x __x, int *__exponent) throw();
}
extern "C"
{
  extern ::_Float32x ldexpf32x(::_Float32x __x, int __exponent) throw();
}
extern "C"
{
  extern ::_Float32x __ldexpf32x(::_Float32x __x, int __exponent) throw();
}
extern "C"
{
  extern ::_Float32x logf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __logf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x log10f32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __log10f32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x modff32x(::_Float32x __x, ::_Float32x *__iptr) throw();
}
extern "C"
{
  extern ::_Float32x __modff32x(::_Float32x __x, ::_Float32x *__iptr) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern ::_Float32x exp10f32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __exp10f32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x expm1f32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __expm1f32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x log1pf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __log1pf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x logbf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __logbf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x exp2f32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __exp2f32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x log2f32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __log2f32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x powf32x(::_Float32x __x, ::_Float32x __y) throw();
}
extern "C"
{
  extern ::_Float32x __powf32x(::_Float32x __x, ::_Float32x __y) throw();
}
extern "C"
{
  extern ::_Float32x sqrtf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __sqrtf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x hypotf32x(::_Float32x __x, ::_Float32x __y) throw();
}
extern "C"
{
  extern ::_Float32x __hypotf32x(::_Float32x __x, ::_Float32x __y) throw();
}
extern "C"
{
  extern ::_Float32x cbrtf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __cbrtf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x ceilf32x(::_Float32x __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32x __ceilf32x(::_Float32x __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32x fabsf32x(::_Float32x __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32x __fabsf32x(::_Float32x __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32x floorf32x(::_Float32x __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32x __floorf32x(::_Float32x __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32x fmodf32x(::_Float32x __x, ::_Float32x __y) throw();
}
extern "C"
{
  extern ::_Float32x __fmodf32x(::_Float32x __x, ::_Float32x __y) throw();
}
extern "C"
{
  extern ::_Float32x copysignf32x(::_Float32x __x, ::_Float32x __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32x __copysignf32x(::_Float32x __x, ::_Float32x __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32x nanf32x(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32x __nanf32x(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32x j0f32x(::_Float32x) throw();
}
extern "C"
{
  extern ::_Float32x __j0f32x(::_Float32x) throw();
}
extern "C"
{
  extern ::_Float32x j1f32x(::_Float32x) throw();
}
extern "C"
{
  extern ::_Float32x __j1f32x(::_Float32x) throw();
}
extern "C"
{
  extern ::_Float32x jnf32x(int, ::_Float32x) throw();
}
extern "C"
{
  extern ::_Float32x __jnf32x(int, ::_Float32x) throw();
}
extern "C"
{
  extern ::_Float32x y0f32x(::_Float32x) throw();
}
extern "C"
{
  extern ::_Float32x __y0f32x(::_Float32x) throw();
}
extern "C"
{
  extern ::_Float32x y1f32x(::_Float32x) throw();
}
extern "C"
{
  extern ::_Float32x __y1f32x(::_Float32x) throw();
}
extern "C"
{
  extern ::_Float32x ynf32x(int, ::_Float32x) throw();
}
extern "C"
{
  extern ::_Float32x __ynf32x(int, ::_Float32x) throw();
}
extern "C"
{
  extern ::_Float32x erff32x(::_Float32x) throw();
}
extern "C"
{
  extern ::_Float32x __erff32x(::_Float32x) throw();
}
extern "C"
{
  extern ::_Float32x erfcf32x(::_Float32x) throw();
}
extern "C"
{
  extern ::_Float32x __erfcf32x(::_Float32x) throw();
}
extern "C"
{
  extern ::_Float32x lgammaf32x(::_Float32x) throw();
}
extern "C"
{
  extern ::_Float32x __lgammaf32x(::_Float32x) throw();
}
extern "C"
{
  extern ::_Float32x tgammaf32x(::_Float32x) throw();
}
extern "C"
{
  extern ::_Float32x __tgammaf32x(::_Float32x) throw();
}
extern "C"
{
  extern ::_Float32x lgammaf32x_r(::_Float32x, int *__signgamp) throw();
}
extern "C"
{
  extern ::_Float32x __lgammaf32x_r(::_Float32x, int *__signgamp) throw();
}
extern "C"
{
  extern ::_Float32x rintf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __rintf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x nextafterf32x(::_Float32x __x, ::_Float32x __y) throw();
}
extern "C"
{
  extern ::_Float32x __nextafterf32x(::_Float32x __x, ::_Float32x __y) throw();
}
extern "C"
{
  extern ::_Float32x nextdownf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __nextdownf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x nextupf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __nextupf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x remainderf32x(::_Float32x __x, ::_Float32x __y) throw();
}
extern "C"
{
  extern ::_Float32x __remainderf32x(::_Float32x __x, ::_Float32x __y) throw();
}
extern "C"
{
  extern ::_Float32x scalbnf32x(::_Float32x __x, int __n) throw();
}
extern "C"
{
  extern ::_Float32x __scalbnf32x(::_Float32x __x, int __n) throw();
}
extern "C"
{
  extern int ilogbf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern int __ilogbf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern long int llogbf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern long int __llogbf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x scalblnf32x(::_Float32x __x, long int __n) throw();
}
extern "C"
{
  extern ::_Float32x __scalblnf32x(::_Float32x __x, long int __n) throw();
}
extern "C"
{
  extern ::_Float32x nearbyintf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x __nearbyintf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x roundf32x(::_Float32x __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32x __roundf32x(::_Float32x __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32x truncf32x(::_Float32x __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32x __truncf32x(::_Float32x __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32x remquof32x(::_Float32x __x, ::_Float32x __y, int *__quo) throw();
}
extern "C"
{
  extern ::_Float32x __remquof32x(::_Float32x __x, ::_Float32x __y, int *__quo) throw();
}
extern "C"
{
  extern long int lrintf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern long int __lrintf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern long long int llrintf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern long long int __llrintf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern long int lroundf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern long int __lroundf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern long long int llroundf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern long long int __llroundf32x(::_Float32x __x) throw();
}
extern "C"
{
  extern ::_Float32x fdimf32x(::_Float32x __x, ::_Float32x __y) throw();
}
extern "C"
{
  extern ::_Float32x __fdimf32x(::_Float32x __x, ::_Float32x __y) throw();
}
extern "C"
{
  extern ::_Float32x fmaxf32x(::_Float32x __x, ::_Float32x __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32x __fmaxf32x(::_Float32x __x, ::_Float32x __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32x fminf32x(::_Float32x __x, ::_Float32x __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32x __fminf32x(::_Float32x __x, ::_Float32x __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32x fmaf32x(::_Float32x __x, ::_Float32x __y, ::_Float32x __z) throw();
}
extern "C"
{
  extern ::_Float32x __fmaf32x(::_Float32x __x, ::_Float32x __y, ::_Float32x __z) throw();
}
extern "C"
{
  extern ::_Float32x roundevenf32x(::_Float32x __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32x __roundevenf32x(::_Float32x __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::__intmax_t fromfpf32x(::_Float32x __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__intmax_t __fromfpf32x(::_Float32x __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t ufromfpf32x(::_Float32x __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t __ufromfpf32x(::_Float32x __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__intmax_t fromfpxf32x(::_Float32x __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__intmax_t __fromfpxf32x(::_Float32x __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t ufromfpxf32x(::_Float32x __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t __ufromfpxf32x(::_Float32x __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::_Float32x fmaxmagf32x(::_Float32x __x, ::_Float32x __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32x __fmaxmagf32x(::_Float32x __x, ::_Float32x __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32x fminmagf32x(::_Float32x __x, ::_Float32x __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float32x __fminmagf32x(::_Float32x __x, ::_Float32x __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int totalorderf32x(::_Float32x __x, ::_Float32x __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int totalordermagf32x(::_Float32x __x, ::_Float32x __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int canonicalizef32x(::_Float32x *__cx, const ::_Float32x *__x) throw();
}
extern "C"
{
  extern ::_Float32x getpayloadf32x(const ::_Float32x *__x) throw();
}
extern "C"
{
  extern ::_Float32x __getpayloadf32x(const ::_Float32x *__x) throw();
}
extern "C"
{
  extern int setpayloadf32x(::_Float32x *__x, ::_Float32x __payload) throw();
}
extern "C"
{
  extern int setpayloadsigf32x(::_Float32x *__x, ::_Float32x __payload) throw();
}
extern "C"
{
  extern ::_Float64x acosf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __acosf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x asinf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __asinf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x atanf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __atanf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x atan2f64x(::_Float64x __y, ::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __atan2f64x(::_Float64x __y, ::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x cosf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __cosf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x sinf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __sinf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x tanf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __tanf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x coshf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __coshf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x sinhf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __sinhf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x tanhf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __tanhf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern void sincosf64x(::_Float64x __x, ::_Float64x *__sinx, ::_Float64x *__cosx) throw();
}
extern "C"
{
  extern void __sincosf64x(::_Float64x __x, ::_Float64x *__sinx, ::_Float64x *__cosx) throw();
}
extern "C"
{
  extern ::_Float64x acoshf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __acoshf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x asinhf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __asinhf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x atanhf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __atanhf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x expf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __expf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x frexpf64x(::_Float64x __x, int *__exponent) throw();
}
extern "C"
{
  extern ::_Float64x __frexpf64x(::_Float64x __x, int *__exponent) throw();
}
extern "C"
{
  extern ::_Float64x ldexpf64x(::_Float64x __x, int __exponent) throw();
}
extern "C"
{
  extern ::_Float64x __ldexpf64x(::_Float64x __x, int __exponent) throw();
}
extern "C"
{
  extern ::_Float64x logf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __logf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x log10f64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __log10f64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x modff64x(::_Float64x __x, ::_Float64x *__iptr) throw();
}
extern "C"
{
  extern ::_Float64x __modff64x(::_Float64x __x, ::_Float64x *__iptr) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern ::_Float64x exp10f64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __exp10f64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x expm1f64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __expm1f64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x log1pf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __log1pf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x logbf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __logbf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x exp2f64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __exp2f64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x log2f64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __log2f64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x powf64x(::_Float64x __x, ::_Float64x __y) throw();
}
extern "C"
{
  extern ::_Float64x __powf64x(::_Float64x __x, ::_Float64x __y) throw();
}
extern "C"
{
  extern ::_Float64x sqrtf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __sqrtf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x hypotf64x(::_Float64x __x, ::_Float64x __y) throw();
}
extern "C"
{
  extern ::_Float64x __hypotf64x(::_Float64x __x, ::_Float64x __y) throw();
}
extern "C"
{
  extern ::_Float64x cbrtf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __cbrtf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x ceilf64x(::_Float64x __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64x __ceilf64x(::_Float64x __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64x fabsf64x(::_Float64x __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64x __fabsf64x(::_Float64x __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64x floorf64x(::_Float64x __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64x __floorf64x(::_Float64x __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64x fmodf64x(::_Float64x __x, ::_Float64x __y) throw();
}
extern "C"
{
  extern ::_Float64x __fmodf64x(::_Float64x __x, ::_Float64x __y) throw();
}
extern "C"
{
  extern ::_Float64x copysignf64x(::_Float64x __x, ::_Float64x __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64x __copysignf64x(::_Float64x __x, ::_Float64x __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64x nanf64x(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64x __nanf64x(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64x j0f64x(::_Float64x) throw();
}
extern "C"
{
  extern ::_Float64x __j0f64x(::_Float64x) throw();
}
extern "C"
{
  extern ::_Float64x j1f64x(::_Float64x) throw();
}
extern "C"
{
  extern ::_Float64x __j1f64x(::_Float64x) throw();
}
extern "C"
{
  extern ::_Float64x jnf64x(int, ::_Float64x) throw();
}
extern "C"
{
  extern ::_Float64x __jnf64x(int, ::_Float64x) throw();
}
extern "C"
{
  extern ::_Float64x y0f64x(::_Float64x) throw();
}
extern "C"
{
  extern ::_Float64x __y0f64x(::_Float64x) throw();
}
extern "C"
{
  extern ::_Float64x y1f64x(::_Float64x) throw();
}
extern "C"
{
  extern ::_Float64x __y1f64x(::_Float64x) throw();
}
extern "C"
{
  extern ::_Float64x ynf64x(int, ::_Float64x) throw();
}
extern "C"
{
  extern ::_Float64x __ynf64x(int, ::_Float64x) throw();
}
extern "C"
{
  extern ::_Float64x erff64x(::_Float64x) throw();
}
extern "C"
{
  extern ::_Float64x __erff64x(::_Float64x) throw();
}
extern "C"
{
  extern ::_Float64x erfcf64x(::_Float64x) throw();
}
extern "C"
{
  extern ::_Float64x __erfcf64x(::_Float64x) throw();
}
extern "C"
{
  extern ::_Float64x lgammaf64x(::_Float64x) throw();
}
extern "C"
{
  extern ::_Float64x __lgammaf64x(::_Float64x) throw();
}
extern "C"
{
  extern ::_Float64x tgammaf64x(::_Float64x) throw();
}
extern "C"
{
  extern ::_Float64x __tgammaf64x(::_Float64x) throw();
}
extern "C"
{
  extern ::_Float64x lgammaf64x_r(::_Float64x, int *__signgamp) throw();
}
extern "C"
{
  extern ::_Float64x __lgammaf64x_r(::_Float64x, int *__signgamp) throw();
}
extern "C"
{
  extern ::_Float64x rintf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __rintf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x nextafterf64x(::_Float64x __x, ::_Float64x __y) throw();
}
extern "C"
{
  extern ::_Float64x __nextafterf64x(::_Float64x __x, ::_Float64x __y) throw();
}
extern "C"
{
  extern ::_Float64x nextdownf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __nextdownf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x nextupf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __nextupf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x remainderf64x(::_Float64x __x, ::_Float64x __y) throw();
}
extern "C"
{
  extern ::_Float64x __remainderf64x(::_Float64x __x, ::_Float64x __y) throw();
}
extern "C"
{
  extern ::_Float64x scalbnf64x(::_Float64x __x, int __n) throw();
}
extern "C"
{
  extern ::_Float64x __scalbnf64x(::_Float64x __x, int __n) throw();
}
extern "C"
{
  extern int ilogbf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern int __ilogbf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern long int llogbf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern long int __llogbf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x scalblnf64x(::_Float64x __x, long int __n) throw();
}
extern "C"
{
  extern ::_Float64x __scalblnf64x(::_Float64x __x, long int __n) throw();
}
extern "C"
{
  extern ::_Float64x nearbyintf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x __nearbyintf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x roundf64x(::_Float64x __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64x __roundf64x(::_Float64x __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64x truncf64x(::_Float64x __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64x __truncf64x(::_Float64x __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64x remquof64x(::_Float64x __x, ::_Float64x __y, int *__quo) throw();
}
extern "C"
{
  extern ::_Float64x __remquof64x(::_Float64x __x, ::_Float64x __y, int *__quo) throw();
}
extern "C"
{
  extern long int lrintf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern long int __lrintf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern long long int llrintf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern long long int __llrintf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern long int lroundf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern long int __lroundf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern long long int llroundf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern long long int __llroundf64x(::_Float64x __x) throw();
}
extern "C"
{
  extern ::_Float64x fdimf64x(::_Float64x __x, ::_Float64x __y) throw();
}
extern "C"
{
  extern ::_Float64x __fdimf64x(::_Float64x __x, ::_Float64x __y) throw();
}
extern "C"
{
  extern ::_Float64x fmaxf64x(::_Float64x __x, ::_Float64x __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64x __fmaxf64x(::_Float64x __x, ::_Float64x __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64x fminf64x(::_Float64x __x, ::_Float64x __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64x __fminf64x(::_Float64x __x, ::_Float64x __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64x fmaf64x(::_Float64x __x, ::_Float64x __y, ::_Float64x __z) throw();
}
extern "C"
{
  extern ::_Float64x __fmaf64x(::_Float64x __x, ::_Float64x __y, ::_Float64x __z) throw();
}
extern "C"
{
  extern ::_Float64x roundevenf64x(::_Float64x __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64x __roundevenf64x(::_Float64x __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::__intmax_t fromfpf64x(::_Float64x __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__intmax_t __fromfpf64x(::_Float64x __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t ufromfpf64x(::_Float64x __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t __ufromfpf64x(::_Float64x __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__intmax_t fromfpxf64x(::_Float64x __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__intmax_t __fromfpxf64x(::_Float64x __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t ufromfpxf64x(::_Float64x __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::__uintmax_t __ufromfpxf64x(::_Float64x __x, int __round, unsigned int __width) throw();
}
extern "C"
{
  extern ::_Float64x fmaxmagf64x(::_Float64x __x, ::_Float64x __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64x __fmaxmagf64x(::_Float64x __x, ::_Float64x __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64x fminmagf64x(::_Float64x __x, ::_Float64x __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::_Float64x __fminmagf64x(::_Float64x __x, ::_Float64x __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int totalorderf64x(::_Float64x __x, ::_Float64x __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int totalordermagf64x(::_Float64x __x, ::_Float64x __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int canonicalizef64x(::_Float64x *__cx, const ::_Float64x *__x) throw();
}
extern "C"
{
  extern ::_Float64x getpayloadf64x(const ::_Float64x *__x) throw();
}
extern "C"
{
  extern ::_Float64x __getpayloadf64x(const ::_Float64x *__x) throw();
}
extern "C"
{
  extern int setpayloadf64x(::_Float64x *__x, ::_Float64x __payload) throw();
}
extern "C"
{
  extern int setpayloadsigf64x(::_Float64x *__x, ::_Float64x __payload) throw();
}
extern "C"
{
  extern int signgam;
}
enum mcc_enum_anon_54
{
  FP_NAN = 0,
  FP_INFINITE = 1,
  FP_ZERO = 2,
  FP_SUBNORMAL = 3,
  FP_NORMAL = 4
};
extern "C"
{
  extern int __iscanonicall(long double __x) throw() __attribute__((__const__));
}
inline int iscanonical(float __val)
{
  return ((void)(float)__val, 1);
}
inline int iscanonical(double __val)
{
  return ((void)(double)__val, 1);
}
inline int iscanonical(long double __val)
{
  return ::__iscanonicall(__val);
}
inline int iscanonical(::_Float128 __val)
{
  return ((void)(::_Float128)__val, 1);
}
inline int issignaling(float __val)
{
  return ::__issignalingf(__val);
}
inline int issignaling(double __val)
{
  return ::__issignaling(__val);
}
inline int issignaling(long double __val)
{
  return ::__issignalingl(__val);
}
inline int issignaling(::_Float128 __val)
{
  return ::__issignalingf128(__val);
}
template < typename __T >
inline bool iszero(__T __val);
template < typename __T >
inline bool iszero(__T __val)
{
  return __val == 0;
}
template < typename __type_tpl__param_1_0__ >
struct __iseqsig_type;
template <>
struct  __iseqsig_type<float>
{
    static inline int __call(float __x, float __y) throw()
    {
      return ::__iseqsigf(__x, __y);
    }
};
template <>
struct  __iseqsig_type<double>
{
    static inline int __call(double __x, double __y) throw()
    {
      return ::__iseqsig(__x, __y);
    }
};
template <>
struct  __iseqsig_type<long double>
{
    static inline int __call(double __x, double __y) throw()
    {
      return ::__iseqsigl(__x, __y);
    }
};
template <>
struct  __iseqsig_type<__float128>
{
    static inline int __call(::_Float128 __x, ::_Float128 __y) throw()
    {
      return ::__iseqsigf128(__x, __y);
    }
};
template < typename _T1, typename _T2 >
inline int iseqsig(_T1 __x, _T2 __y) throw();
template < typename _T1, typename _T2 >
inline int iseqsig(_T1 __x, _T2 __y) throw()
{
  typedef __typeof__(__x + __y + 0.000000000000000000000000e+00f) _T3;
  return __iseqsig_type<_T3>::__call(__x, __y);
}
namespace std __attribute__((__visibility__("default"))) {
  using ::acos;
  inline float acos(float __x)
  {
    return __builtin_acosf(__x);
  }
  inline long double acos(long double __x)
  {
    return __builtin_acosl(__x);
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type acos(_Tp __x);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type acos(_Tp __x)
  {
    return __builtin_acos(__x);
  }
  using ::asin;
  inline float asin(float __x)
  {
    return __builtin_asinf(__x);
  }
  inline long double asin(long double __x)
  {
    return __builtin_asinl(__x);
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type asin(_Tp __x);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type asin(_Tp __x)
  {
    return __builtin_asin(__x);
  }
  using ::atan;
  inline float atan(float __x)
  {
    return __builtin_atanf(__x);
  }
  inline long double atan(long double __x)
  {
    return __builtin_atanl(__x);
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type atan(_Tp __x);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type atan(_Tp __x)
  {
    return __builtin_atan(__x);
  }
  using ::atan2;
  inline float atan2(float __y, float __x)
  {
    return __builtin_atan2f(__y, __x);
  }
  inline long double atan2(long double __y, long double __x)
  {
    return __builtin_atan2l(__y, __x);
  }
  template < typename _Tp, typename _Up >
  inline typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type atan2(_Tp __y, _Up __x);
  template < typename _Tp, typename _Up >
  inline typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type atan2(_Tp __y, _Up __x)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return atan2(__type(__y), __type(__x));
  }
  using ::ceil;
  inline float ceil(float __x)
  {
    return __builtin_ceilf(__x);
  }
  inline long double ceil(long double __x)
  {
    return __builtin_ceill(__x);
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type ceil(_Tp __x);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type ceil(_Tp __x)
  {
    return __builtin_ceil(__x);
  }
  using ::cos;
  inline float cos(float __x)
  {
    return __builtin_cosf(__x);
  }
  inline long double cos(long double __x)
  {
    return __builtin_cosl(__x);
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type cos(_Tp __x);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type cos(_Tp __x)
  {
    return __builtin_cos(__x);
  }
  using ::cosh;
  inline float cosh(float __x)
  {
    return __builtin_coshf(__x);
  }
  inline long double cosh(long double __x)
  {
    return __builtin_coshl(__x);
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type cosh(_Tp __x);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type cosh(_Tp __x)
  {
    return __builtin_cosh(__x);
  }
  using ::exp;
  inline float exp(float __x)
  {
    return __builtin_expf(__x);
  }
  inline long double exp(long double __x)
  {
    return __builtin_expl(__x);
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type exp(_Tp __x);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type exp(_Tp __x)
  {
    return __builtin_exp(__x);
  }
  using ::fabs;
  inline float fabs(float __x)
  {
    return __builtin_fabsf(__x);
  }
  inline long double fabs(long double __x)
  {
    return __builtin_fabsl(__x);
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type fabs(_Tp __x);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type fabs(_Tp __x)
  {
    return __builtin_fabs(__x);
  }
  using ::floor;
  inline float floor(float __x)
  {
    return __builtin_floorf(__x);
  }
  inline long double floor(long double __x)
  {
    return __builtin_floorl(__x);
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type floor(_Tp __x);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type floor(_Tp __x)
  {
    return __builtin_floor(__x);
  }
  using ::fmod;
  inline float fmod(float __x, float __y)
  {
    return __builtin_fmodf(__x, __y);
  }
  inline long double fmod(long double __x, long double __y)
  {
    return __builtin_fmodl(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type fmod(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type fmod(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return fmod(__type(__x), __type(__y));
  }
  using ::frexp;
  inline float frexp(float __x, int *__exp)
  {
    return __builtin_frexpf(__x, __exp);
  }
  inline long double frexp(long double __x, int *__exp)
  {
    return __builtin_frexpl(__x, __exp);
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type frexp(_Tp __x, int *__exp);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type frexp(_Tp __x, int *__exp)
  {
    return __builtin_frexp(__x, __exp);
  }
  using ::ldexp;
  inline float ldexp(float __x, int __exp)
  {
    return __builtin_ldexpf(__x, __exp);
  }
  inline long double ldexp(long double __x, int __exp)
  {
    return __builtin_ldexpl(__x, __exp);
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type ldexp(_Tp __x, int __exp);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type ldexp(_Tp __x, int __exp)
  {
    return __builtin_ldexp(__x, __exp);
  }
  using ::log;
  inline float log(float __x)
  {
    return __builtin_logf(__x);
  }
  inline long double log(long double __x)
  {
    return __builtin_logl(__x);
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log(_Tp __x);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log(_Tp __x)
  {
    return __builtin_log(__x);
  }
  using ::log10;
  inline float log10(float __x)
  {
    return __builtin_log10f(__x);
  }
  inline long double log10(long double __x)
  {
    return __builtin_log10l(__x);
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log10(_Tp __x);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log10(_Tp __x)
  {
    return __builtin_log10(__x);
  }
  using ::modf;
  inline float modf(float __x, float *__iptr)
  {
    return __builtin_modff(__x, __iptr);
  }
  inline long double modf(long double __x, long double *__iptr)
  {
    return __builtin_modfl(__x, __iptr);
  }
  using ::pow;
  inline float pow(float __x, float __y)
  {
    return __builtin_powf(__x, __y);
  }
  inline long double pow(long double __x, long double __y)
  {
    return __builtin_powl(__x, __y);
  }
  inline double pow(double __x, int __i)
  {
    return __builtin_powi(__x, __i);
  }
  inline float pow(float __x, int __n)
  {
    return __builtin_powif(__x, __n);
  }
  inline long double pow(long double __x, int __n)
  {
    return __builtin_powil(__x, __n);
  }
  template < typename _Tp, typename _Up >
  inline typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type pow(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type pow(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return pow(__type(__x), __type(__y));
  }
  using ::sin;
  inline float sin(float __x)
  {
    return __builtin_sinf(__x);
  }
  inline long double sin(long double __x)
  {
    return __builtin_sinl(__x);
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sin(_Tp __x);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sin(_Tp __x)
  {
    return __builtin_sin(__x);
  }
  using ::sinh;
  inline float sinh(float __x)
  {
    return __builtin_sinhf(__x);
  }
  inline long double sinh(long double __x)
  {
    return __builtin_sinhl(__x);
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sinh(_Tp __x);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sinh(_Tp __x)
  {
    return __builtin_sinh(__x);
  }
  using ::sqrt;
  inline float sqrt(float __x)
  {
    return __builtin_sqrtf(__x);
  }
  inline long double sqrt(long double __x)
  {
    return __builtin_sqrtl(__x);
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sqrt(_Tp __x);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sqrt(_Tp __x)
  {
    return __builtin_sqrt(__x);
  }
  using ::tan;
  inline float tan(float __x)
  {
    return __builtin_tanf(__x);
  }
  inline long double tan(long double __x)
  {
    return __builtin_tanl(__x);
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type tan(_Tp __x);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type tan(_Tp __x)
  {
    return __builtin_tan(__x);
  }
  using ::tanh;
  inline float tanh(float __x)
  {
    return __builtin_tanhf(__x);
  }
  inline long double tanh(long double __x)
  {
    return __builtin_tanhl(__x);
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type tanh(_Tp __x);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type tanh(_Tp __x)
  {
    return __builtin_tanh(__x);
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value, int>::__type fpclassify(_Tp __f);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value, int>::__type fpclassify(_Tp __f)
  {
    typedef typename ::__gnu_cxx::__promote<_Tp>::__type __type;
    return __builtin_fpclassify(0, 1, 4, 3, 2, __type(__f));
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value, int>::__type isfinite(_Tp __f);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value, int>::__type isfinite(_Tp __f)
  {
    typedef typename ::__gnu_cxx::__promote<_Tp>::__type __type;
    return __builtin_isfinite(__type(__f));
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value, int>::__type isinf(_Tp __f);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value, int>::__type isinf(_Tp __f)
  {
    typedef typename ::__gnu_cxx::__promote<_Tp>::__type __type;
    return __builtin_isinf(__type(__f));
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value, int>::__type isnan(_Tp __f);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value, int>::__type isnan(_Tp __f)
  {
    typedef typename ::__gnu_cxx::__promote<_Tp>::__type __type;
    return __builtin_isnan(__type(__f));
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value, int>::__type isnormal(_Tp __f);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value, int>::__type isnormal(_Tp __f)
  {
    typedef typename ::__gnu_cxx::__promote<_Tp>::__type __type;
    return __builtin_isnormal(__type(__f));
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value, int>::__type signbit(_Tp __f);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value, int>::__type signbit(_Tp __f)
  {
    typedef typename ::__gnu_cxx::__promote<_Tp>::__type __type;
    return __builtin_signbit(__type(__f));
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value, int>::__type isgreater(_Tp __f1, _Tp __f2);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value, int>::__type isgreater(_Tp __f1, _Tp __f2)
  {
    typedef typename ::__gnu_cxx::__promote<_Tp>::__type __type;
    return __builtin_isgreater(__type(__f1), __type(__f2));
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value, int>::__type isgreaterequal(_Tp __f1, _Tp __f2);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value, int>::__type isgreaterequal(_Tp __f1, _Tp __f2)
  {
    typedef typename ::__gnu_cxx::__promote<_Tp>::__type __type;
    return __builtin_isgreaterequal(__type(__f1), __type(__f2));
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value, int>::__type isless(_Tp __f1, _Tp __f2);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value, int>::__type isless(_Tp __f1, _Tp __f2)
  {
    typedef typename ::__gnu_cxx::__promote<_Tp>::__type __type;
    return __builtin_isless(__type(__f1), __type(__f2));
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value, int>::__type islessequal(_Tp __f1, _Tp __f2);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value, int>::__type islessequal(_Tp __f1, _Tp __f2)
  {
    typedef typename ::__gnu_cxx::__promote<_Tp>::__type __type;
    return __builtin_islessequal(__type(__f1), __type(__f2));
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value, int>::__type islessgreater(_Tp __f1, _Tp __f2);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value, int>::__type islessgreater(_Tp __f1, _Tp __f2)
  {
    typedef typename ::__gnu_cxx::__promote<_Tp>::__type __type;
    return __builtin_islessgreater(__type(__f1), __type(__f2));
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value, int>::__type isunordered(_Tp __f1, _Tp __f2);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value, int>::__type isunordered(_Tp __f1, _Tp __f2)
  {
    typedef typename ::__gnu_cxx::__promote<_Tp>::__type __type;
    return __builtin_isunordered(__type(__f1), __type(__f2));
  }
}
using ::std::abs;
using ::std::acos;
using ::std::asin;
using ::std::atan;
using ::std::atan2;
using ::std::cos;
using ::std::sin;
using ::std::tan;
using ::std::cosh;
using ::std::sinh;
using ::std::tanh;
using ::std::exp;
using ::std::frexp;
using ::std::ldexp;
using ::std::log;
using ::std::log10;
using ::std::modf;
using ::std::pow;
using ::std::sqrt;
using ::std::ceil;
using ::std::fabs;
using ::std::floor;
using ::std::fmod;
using ::std::fpclassify;
using ::std::isfinite;
using ::std::isinf;
using ::std::isnan;
using ::std::isnormal;
using ::std::signbit;
using ::std::isgreater;
using ::std::isgreaterequal;
using ::std::isless;
using ::std::islessequal;
using ::std::islessgreater;
using ::std::isunordered;
typedef ::__sig_atomic_t sig_atomic_t;
union  sigval
{
    int sival_int;
    void *sival_ptr;
};
typedef ::sigval __sigval_t;
struct  siginfo_t
{
    int si_signo;
    int si_errno;
    int si_code;
    int __pad0;
    union  mcc_union_anon_214
    {
        int _pad[28L];
        struct  mcc_struct_anon_215
        {
            ::__pid_t si_pid;
            ::__uid_t si_uid;
        };
        ::siginfo_t::mcc_union_anon_214::mcc_struct_anon_215 _kill;
        struct  mcc_struct_anon_216
        {
            int si_tid;
            int si_overrun;
            ::__sigval_t si_sigval;
        };
        ::siginfo_t::mcc_union_anon_214::mcc_struct_anon_216 _timer;
        struct  mcc_struct_anon_217
        {
            ::__pid_t si_pid;
            ::__uid_t si_uid;
            ::__sigval_t si_sigval;
        };
        ::siginfo_t::mcc_union_anon_214::mcc_struct_anon_217 _rt;
        struct  mcc_struct_anon_218
        {
            ::__pid_t si_pid;
            ::__uid_t si_uid;
            int si_status;
            ::__clock_t si_utime;
            ::__clock_t si_stime;
        };
        ::siginfo_t::mcc_union_anon_214::mcc_struct_anon_218 _sigchld;
        struct  mcc_struct_anon_219
        {
            void *si_addr;
            short int si_addr_lsb;
            union  mcc_union_anon_220
            {
                struct  mcc_struct_anon_221
                {
                    void *_lower;
                    void *_upper;
                };
                ::siginfo_t::mcc_union_anon_214::mcc_struct_anon_219::mcc_union_anon_220::mcc_struct_anon_221 _addr_bnd;
                ::__uint32_t _pkey;
            };
            ::siginfo_t::mcc_union_anon_214::mcc_struct_anon_219::mcc_union_anon_220 _bounds;
        };
        ::siginfo_t::mcc_union_anon_214::mcc_struct_anon_219 _sigfault;
        struct  mcc_struct_anon_222
        {
            long int si_band;
            int si_fd;
        };
        ::siginfo_t::mcc_union_anon_214::mcc_struct_anon_222 _sigpoll;
        struct  mcc_struct_anon_223
        {
            void *_call_addr;
            int _syscall;
            unsigned int _arch;
        };
        ::siginfo_t::mcc_union_anon_214::mcc_struct_anon_223 _sigsys;
    };
    ::siginfo_t::mcc_union_anon_214 _sifields;
};
enum mcc_enum_anon_55
{
  SI_ASYNCNL =  -60,
  SI_TKILL =  -6,
  SI_SIGIO =  -5,
  SI_ASYNCIO =  -4,
  SI_MESGQ =  -3,
  SI_TIMER =  -2,
  SI_QUEUE =  -1,
  SI_USER = 0,
  SI_KERNEL = 128
};
enum mcc_enum_anon_56
{
  ILL_ILLOPC = 1,
  ILL_ILLOPN = 2,
  ILL_ILLADR = 3,
  ILL_ILLTRP = 4,
  ILL_PRVOPC = 5,
  ILL_PRVREG = 6,
  ILL_COPROC = 7,
  ILL_BADSTK = 8
};
enum mcc_enum_anon_57
{
  FPE_INTDIV = 1,
  FPE_INTOVF = 2,
  FPE_FLTDIV = 3,
  FPE_FLTOVF = 4,
  FPE_FLTUND = 5,
  FPE_FLTRES = 6,
  FPE_FLTINV = 7,
  FPE_FLTSUB = 8
};
enum mcc_enum_anon_58
{
  SEGV_MAPERR = 1,
  SEGV_ACCERR = 2,
  SEGV_BNDERR = 3,
  SEGV_PKUERR = 4
};
enum mcc_enum_anon_59
{
  BUS_ADRALN = 1,
  BUS_ADRERR = 2,
  BUS_OBJERR = 3,
  BUS_MCEERR_AR = 4,
  BUS_MCEERR_AO = 5
};
enum mcc_enum_anon_60
{
  TRAP_BRKPT = 1,
  TRAP_TRACE = 2
};
enum mcc_enum_anon_61
{
  CLD_EXITED = 1,
  CLD_KILLED = 2,
  CLD_DUMPED = 3,
  CLD_TRAPPED = 4,
  CLD_STOPPED = 5,
  CLD_CONTINUED = 6
};
enum mcc_enum_anon_62
{
  POLL_IN = 1,
  POLL_OUT = 2,
  POLL_MSG = 3,
  POLL_ERR = 4,
  POLL_PRI = 5,
  POLL_HUP = 6
};
typedef ::__sigval_t sigval_t;
struct  sigevent
{
    ::__sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;
    union  mcc_union_anon_224
    {
        int _pad[12L];
        ::__pid_t _tid;
        struct  mcc_struct_anon_225
        {
            void (*_function)(::__sigval_t);
            ::pthread_attr_t *_attribute;
        };
        ::sigevent::mcc_union_anon_224::mcc_struct_anon_225 _sigev_thread;
    };
    ::sigevent::mcc_union_anon_224 _sigev_un;
};
typedef ::sigevent sigevent_t;
enum mcc_enum_anon_63
{
  SIGEV_SIGNAL = 0,
  SIGEV_NONE = 1,
  SIGEV_THREAD = 2,
  SIGEV_THREAD_ID = 4
};
typedef void (*__sighandler_t)(int);
extern "C"
{
  extern ::__sighandler_t __sysv_signal(int __sig, ::__sighandler_t __handler) throw();
}
extern "C"
{
  extern ::__sighandler_t sysv_signal(int __sig, ::__sighandler_t __handler) throw();
}
extern "C"
{
  extern ::__sighandler_t signal(int __sig, ::__sighandler_t __handler) throw();
}
extern "C"
{
  extern int kill(::__pid_t __pid, int __sig) throw();
}
extern "C"
{
  extern int killpg(::__pid_t __pgrp, int __sig) throw();
}
extern "C"
{
  extern int raise(int __sig) throw();
}
extern "C"
{
  extern ::__sighandler_t ssignal(int __sig, ::__sighandler_t __handler) throw();
}
extern "C"
{
  extern int gsignal(int __sig) throw();
}
extern "C"
{
  extern void psignal(int __sig, const char *__s);
}
extern "C"
{
  extern void psiginfo(const ::siginfo_t *__pinfo, const char *__s);
}
extern "C"
{
  extern int sigpause(int __sig) __asm("__xpg_sigpause");
}
extern "C"
{
  extern int sigblock(int __mask) throw() __attribute__((__deprecated__));
}
extern "C"
{
  extern int sigsetmask(int __mask) throw() __attribute__((__deprecated__));
}
extern "C"
{
  extern int siggetmask() throw() __attribute__((__deprecated__));
}
typedef ::__sighandler_t sighandler_t;
typedef ::__sighandler_t sig_t;
extern "C"
{
  extern int sigemptyset(::sigset_t *__set) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int sigfillset(::sigset_t *__set) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int sigaddset(::sigset_t *__set, int __signo) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int sigdelset(::sigset_t *__set, int __signo) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int sigismember(const ::sigset_t *__set, int __signo) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int sigisemptyset(const ::sigset_t *__set) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int sigandset(::sigset_t *__set, const ::sigset_t *__left, const ::sigset_t *__right) throw() __attribute__((__nonnull__(1, 2, 3)));
}
extern "C"
{
  extern int sigorset(::sigset_t *__set, const ::sigset_t *__left, const ::sigset_t *__right) throw() __attribute__((__nonnull__(1, 2, 3)));
}
struct  sigaction
{
    union  mcc_union_anon_226
    {
        ::__sighandler_t sa_handler;
        void (*sa_sigaction)(int, ::siginfo_t *, void *);
    };
    ::sigaction::mcc_union_anon_226 __sigaction_handler;
    ::__sigset_t sa_mask;
    int sa_flags;
    void (*sa_restorer)();
};
extern "C"
{
  extern int sigprocmask(int __how, const ::sigset_t *__restrict __set, ::sigset_t *__restrict __oset) throw();
}
extern "C"
{
  extern int sigsuspend(const ::sigset_t *__set) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int sigaction(int __sig, const struct ::sigaction *__restrict __act, struct ::sigaction *__restrict __oact) throw();
}
extern "C"
{
  extern int sigpending(::sigset_t *__set) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int sigwait(const ::sigset_t *__restrict __set, int *__restrict __sig) __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int sigwaitinfo(const ::sigset_t *__restrict __set, ::siginfo_t *__restrict __info) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int sigtimedwait(const ::sigset_t *__restrict __set, ::siginfo_t *__restrict __info, const ::timespec *__restrict __timeout) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int sigqueue(::__pid_t __pid, int __sig, const ::sigval __val) throw();
}
extern "C"
{
  extern const char *const _sys_siglist[65L];
}
extern "C"
{
  extern const char *const sys_siglist[65L];
}
struct  _fpx_sw_bytes
{
    ::__uint32_t magic1;
    ::__uint32_t extended_size;
    ::__uint64_t xstate_bv;
    ::__uint32_t xstate_size;
    ::__uint32_t __glibc_reserved1[7L];
};
struct  _fpreg
{
    unsigned short int significand[4L];
    unsigned short int exponent;
};
struct  _fpxreg
{
    unsigned short int significand[4L];
    unsigned short int exponent;
    unsigned short int __glibc_reserved1[3L];
};
struct  _xmmreg
{
    ::__uint32_t element[4L];
};
struct  _fpstate
{
    ::__uint16_t cwd;
    ::__uint16_t swd;
    ::__uint16_t ftw;
    ::__uint16_t fop;
    ::__uint64_t rip;
    ::__uint64_t rdp;
    ::__uint32_t mxcsr;
    ::__uint32_t mxcr_mask;
    ::_fpxreg _st[8L];
    ::_xmmreg _xmm[16L];
    ::__uint32_t __glibc_reserved1[24L];
};
struct  sigcontext
{
    ::__uint64_t r8;
    ::__uint64_t r9;
    ::__uint64_t r10;
    ::__uint64_t r11;
    ::__uint64_t r12;
    ::__uint64_t r13;
    ::__uint64_t r14;
    ::__uint64_t r15;
    ::__uint64_t rdi;
    ::__uint64_t rsi;
    ::__uint64_t rbp;
    ::__uint64_t rbx;
    ::__uint64_t rdx;
    ::__uint64_t rax;
    ::__uint64_t rcx;
    ::__uint64_t rsp;
    ::__uint64_t rip;
    ::__uint64_t eflags;
    unsigned short int cs;
    unsigned short int gs;
    unsigned short int fs;
    unsigned short int __pad0;
    ::__uint64_t err;
    ::__uint64_t trapno;
    ::__uint64_t oldmask;
    ::__uint64_t cr2;
    __extension__ union 
    {
        __extension__ ::_fpstate *fpstate;
        __extension__ ::__uint64_t __fpstate_word;
    };
    ::__uint64_t __reserved1[8L];
};
struct  _xsave_hdr
{
    ::__uint64_t xstate_bv;
    ::__uint64_t __glibc_reserved1[2L];
    ::__uint64_t __glibc_reserved2[5L];
};
struct  _ymmh_state
{
    ::__uint32_t ymmh_space[64L];
};
struct  _xstate
{
    ::_fpstate fpstate;
    ::_xsave_hdr xstate_hdr;
    ::_ymmh_state ymmh;
};
extern "C"
{
  extern int sigreturn(::sigcontext *__scp) throw();
}
struct  stack_t
{
    void *ss_sp;
    int ss_flags;
    ::size_t ss_size;
};
__extension__ typedef long long int greg_t;
typedef ::greg_t gregset_t[23L];
enum mcc_enum_anon_64
{
  REG_R8 = 0,
  REG_R9 = 1,
  REG_R10 = 2,
  REG_R11 = 3,
  REG_R12 = 4,
  REG_R13 = 5,
  REG_R14 = 6,
  REG_R15 = 7,
  REG_RDI = 8,
  REG_RSI = 9,
  REG_RBP = 10,
  REG_RBX = 11,
  REG_RDX = 12,
  REG_RAX = 13,
  REG_RCX = 14,
  REG_RSP = 15,
  REG_RIP = 16,
  REG_EFL = 17,
  REG_CSGSFS = 18,
  REG_ERR = 19,
  REG_TRAPNO = 20,
  REG_OLDMASK = 21,
  REG_CR2 = 22
};
struct  _libc_fpxreg
{
    unsigned short int significand[4L];
    unsigned short int exponent;
    unsigned short int __glibc_reserved1[3L];
};
struct  _libc_xmmreg
{
    ::__uint32_t element[4L];
};
struct  _libc_fpstate
{
    ::__uint16_t cwd;
    ::__uint16_t swd;
    ::__uint16_t ftw;
    ::__uint16_t fop;
    ::__uint64_t rip;
    ::__uint64_t rdp;
    ::__uint32_t mxcsr;
    ::__uint32_t mxcr_mask;
    ::_libc_fpxreg _st[8L];
    ::_libc_xmmreg _xmm[16L];
    ::__uint32_t __glibc_reserved1[24L];
};
typedef ::_libc_fpstate *fpregset_t;
struct  mcontext_t
{
    ::gregset_t gregs;
    ::fpregset_t fpregs;
    __extension__ unsigned long long int __reserved1[8L];
};
struct ucontext_t;
struct  ucontext_t
{
    unsigned long int uc_flags;
    ::ucontext_t *uc_link;
    ::stack_t uc_stack;
    ::mcontext_t uc_mcontext;
    ::sigset_t uc_sigmask;
    ::_libc_fpstate __fpregs_mem;
};
extern "C"
{
  extern int siginterrupt(int __sig, int __interrupt) throw();
}
enum mcc_enum_anon_65
{
  SS_ONSTACK = 1,
  SS_DISABLE = 2
};
extern "C"
{
  extern int sigaltstack(const ::stack_t *__restrict __ss, ::stack_t *__restrict __oss) throw();
}
struct  sigstack
{
    void *ss_sp;
    int ss_onstack;
};
extern "C"
{
  extern int sigstack(struct ::sigstack *__ss, struct ::sigstack *__oss) throw() __attribute__((__deprecated__));
}
extern "C"
{
  extern int sighold(int __sig) throw();
}
extern "C"
{
  extern int sigrelse(int __sig) throw();
}
extern "C"
{
  extern int sigignore(int __sig) throw();
}
extern "C"
{
  extern ::__sighandler_t sigset(int __sig, ::__sighandler_t __disp) throw();
}
extern "C"
{
  extern int pthread_sigmask(int __how, const ::__sigset_t *__restrict __newmask, ::__sigset_t *__restrict __oldmask) throw();
}
extern "C"
{
  extern int pthread_kill(::pthread_t __threadid, int __signo) throw();
}
extern "C"
{
  extern int pthread_sigqueue(::pthread_t __threadid, int __signo, const ::sigval __value) throw();
}
extern "C"
{
  extern int __libc_current_sigrtmin() throw();
}
extern "C"
{
  extern int __libc_current_sigrtmax() throw();
}
namespace std __attribute__((__visibility__("default"))) {
  class  locale
  {
    public:
      typedef int category;
      class facet;
      class id;
      class _Impl;
      static const ::std::locale::category none = 0;
      static const ::std::locale::category ctype = 1L << 0;
      static const ::std::locale::category numeric = 1L << 1;
      static const ::std::locale::category collate = 1L << 2;
      static const ::std::locale::category time = 1L << 3;
      static const ::std::locale::category monetary = 1L << 4;
      static const ::std::locale::category messages = 1L << 5;
      static const ::std::locale::category all = ((((::std::locale::ctype | ::std::locale::numeric) | ::std::locale::collate) | ::std::locale::time) | ::std::locale::monetary) | ::std::locale::messages;
      locale() throw();
      locale(const ::std::locale &__other) throw();
      explicit locale(const char *__s);
      locale(const ::std::locale &__base, const char *__s, ::std::locale::category __cat);
      locale(const ::std::locale &__base, const ::std::locale &__add, ::std::locale::category __cat);
      template < typename _Facet >
      locale(const ::std::locale &__other, _Facet *__f);
      ~locale() throw();
      const ::std::locale &operator =(const ::std::locale &__other) throw();
      template < typename _Facet >
      ::std::locale combine(const ::std::locale &__other) const ;
      ::std::__cxx11::string name() const  __attribute__((__abi_tag__("cxx11")));
      bool operator ==(const ::std::locale &__other) const  throw();
      inline bool operator !=(const ::std::locale &__other) const  throw()
      {
        return !(*this).::std::locale::operator ==(__other);
      }
      template < typename _Char, typename _Traits, typename _Alloc >
      bool operator ()(const ::std::__cxx11::basic_string<_Char, _Traits, _Alloc> &__s1, const ::std::__cxx11::basic_string<_Char, _Traits, _Alloc> &__s2) const ;
      static ::std::locale global(const ::std::locale &__loc);
      static const ::std::locale &classic();
    private:
      ::std::locale::_Impl *_M_impl;
      static ::std::locale::_Impl *_S_classic;
      static ::std::locale::_Impl *_S_global;
      static const char *const *const _S_categories;
      enum mcc_enum_anon_66
      {
        _S_categories_size = 6 + 6
      };
      static ::__gthread_once_t _S_once;
      explicit locale(::std::locale::_Impl *) throw();
      static void _S_initialize();
      static void _S_initialize_once() throw();
      static ::std::locale::category _S_normalize_category(::std::locale::category);
      void _M_coalesce(const ::std::locale &__base, const ::std::locale &__add, ::std::locale::category __cat);
      static const ::std::locale::id *const _S_twinned_facets[];
    friend class ::std::locale::facet;
    friend class ::std::locale::_Impl;
    template < typename _Facet >
    friend bool (::std::has_facet)(const ::std::locale &) throw();
    template < typename _Facet >
    friend const _Facet &(::std::use_facet)(const ::std::locale &);
    template < typename _Cache >
    friend struct __use_cache;
  };
  class  locale::facet
  {
      mutable ::_Atomic_word _M_refcount;
      static ::std::__c_locale _S_c_locale;
      static const char _S_c_name[2L];
      static ::__gthread_once_t _S_once;
      static void _S_initialize_once();
    protected:
      inline explicit facet(::std::size_t __refs  = (0)) throw()
        : _M_refcount(__refs ? 1 : 0)
      {
      }
      virtual ~facet();
      static void _S_create_c_locale(::std::__c_locale &__cloc, const char *__s, ::std::__c_locale __old  = (0));
      static ::std::__c_locale _S_clone_c_locale(::std::__c_locale &__cloc) throw();
      static void _S_destroy_c_locale(::std::__c_locale &__cloc);
      static ::std::__c_locale _S_lc_ctype_c_locale(::std::__c_locale __cloc, const char *__s);
      static ::std::__c_locale _S_get_c_locale();
      static const char *_S_get_c_name() throw() __attribute__((__const__));
    private:
      facet(const ::std::locale::facet &);
      ::std::locale::facet &operator =(const ::std::locale::facet &);
      inline void _M_add_reference() const  throw()
      {
        __gnu_cxx::__atomic_add_dispatch(&(*this)._M_refcount, 1);
      }
      inline void _M_remove_reference() const  throw()
      {
        ;
        if (__gnu_cxx::__exchange_and_add_dispatch(&(*this)._M_refcount,  -1) == 1)
          {
            ;
            try
            {
              delete this;
            }
            catch (...)
            {
            }
          }
      }
      const ::std::locale::facet *_M_sso_shim(const ::std::locale::id *) const ;
      const ::std::locale::facet *_M_cow_shim(const ::std::locale::id *) const ;
    protected:
    friend class locale;
    friend class ::std::locale::_Impl;
  };
  class  locale::id
  {
      mutable ::std::size_t _M_index;
      static ::_Atomic_word _S_refcount;
      void operator =(const ::std::locale::id &);
      id(const ::std::locale::id &);
    public:
      inline id()
      {
      }
      ::std::size_t _M_id() const  throw();
    friend class locale;
    friend class ::std::locale::_Impl;
    template < typename _Facet >
    friend const _Facet &(::std::use_facet)(const ::std::locale &);
    template < typename _Facet >
    friend bool (::std::has_facet)(const ::std::locale &) throw();
  };
  class  locale::_Impl
  {
      ::_Atomic_word _M_refcount;
      const ::std::locale::facet **_M_facets;
      ::std::size_t _M_facets_size;
      const ::std::locale::facet **_M_caches;
      char **_M_names;
      static const ::std::locale::id *const _S_id_ctype[];
      static const ::std::locale::id *const _S_id_numeric[];
      static const ::std::locale::id *const _S_id_collate[];
      static const ::std::locale::id *const _S_id_time[];
      static const ::std::locale::id *const _S_id_monetary[];
      static const ::std::locale::id *const _S_id_messages[];
      static const ::std::locale::id *const *const _S_facet_categories[];
      inline void _M_add_reference() throw()
      {
        __gnu_cxx::__atomic_add_dispatch(&(*this)._M_refcount, 1);
      }
      inline void _M_remove_reference() throw()
      {
        ;
        if (__gnu_cxx::__exchange_and_add_dispatch(&(*this)._M_refcount,  -1) == 1)
          {
            ;
            try
            {
              delete this;
            }
            catch (...)
            {
            }
          }
      }
      _Impl(const ::std::locale::_Impl &, ::std::size_t);
      _Impl(const char *, ::std::size_t);
      _Impl(::std::size_t) throw();
      ~_Impl() throw();
      _Impl(const ::std::locale::_Impl &);
      void operator =(const ::std::locale::_Impl &);
      inline bool _M_check_same_name()
      {
        bool __ret(true);
        if ((*this)._M_names[1])
          {
            for (::std::size_t __i(0); __ret && __i < ::std::locale::_S_categories_size - 1;  ++__i)
              {
                __ret = __builtin_strcmp((*this)._M_names[__i], (*this)._M_names[__i + 1]) == 0;
              }
          }
        return __ret;
      }
      void _M_replace_categories(const ::std::locale::_Impl *, ::std::locale::category);
      void _M_replace_category(const ::std::locale::_Impl *, const ::std::locale::id *const *);
      void _M_replace_facet(const ::std::locale::_Impl *, const ::std::locale::id *);
      void _M_install_facet(const ::std::locale::id *, const ::std::locale::facet *);
      template < typename _Facet >
      inline void _M_init_facet(_Facet *__facet)
      {
        _M_install_facet(&_Facet::id, __facet);
      }
      template < typename _Facet >
      inline void _M_init_facet_unchecked(_Facet *__facet)
      {
        __facet->_M_add_reference();
        (*this)._M_facets[_Facet::id._M_id()] = __facet;
      }
      void _M_install_cache(const ::std::locale::facet *, ::std::size_t);
      void _M_init_extra(::std::locale::facet **);
      void _M_init_extra(void *, void *, const char *, const char *);
    friend class locale;
    friend class ::std::locale::facet;
    template < typename _Facet >
    friend bool (::std::has_facet)(const ::std::locale &) throw();
    template < typename _Facet >
    friend const _Facet &(::std::use_facet)(const ::std::locale &);
    template < typename _Cache >
    friend struct __use_cache;
  };
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    template < typename _CharT >
    class  collate : public ::std::locale::facet
    {
      public:
        typedef _CharT char_type;
        typedef ::std::__cxx11::basic_string<_CharT> string_type;
      protected:
        ::std::__c_locale _M_c_locale_collate;
      public:
        static ::std::locale::id id;
        inline explicit collate(::std::size_t __refs  = (0))
          : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
        {
        }
        inline explicit collate(::std::__c_locale __cloc, ::std::size_t __refs  = (0))
          : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
        {
        }
        inline int compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const 
        {
          return this->do_compare(__lo1, __hi1, __lo2, __hi2);
        }
        inline typename ::std::__cxx11::collate<_CharT>::string_type transform(const _CharT *__lo, const _CharT *__hi) const 
        {
          return this->do_transform(__lo, __hi);
        }
        inline long int hash(const _CharT *__lo, const _CharT *__hi) const 
        {
          return this->do_hash(__lo, __hi);
        }
        int _M_compare(const _CharT *, const _CharT *) const  throw();
        ::std::size_t _M_transform(_CharT *, const _CharT *, ::std::size_t) const  throw();
      protected:
        inline virtual ~collate()
        {
          _S_destroy_c_locale(::std::__cxx11::collate<_CharT>::_M_c_locale_collate);
        }
        virtual int do_compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const ;
        virtual typename ::std::__cxx11::collate<_CharT>::string_type do_transform(const _CharT *__lo, const _CharT *__hi) const ;
        virtual long int do_hash(const _CharT *__lo, const _CharT *__hi) const ;
    };
    template < typename _CharT >
    ::std::locale::id collate<_CharT>::id;
 /* Instantiation of class template '::std::__cxx11::collate<char>' */ 
    template <>
    int collate<char>::_M_compare(const char *, const char *) const  throw();
    template <>
    unsigned long int collate<char>::_M_transform(char *, const char *, unsigned long int) const  throw();
 /* Instantiation of class template '::std::__cxx11::collate<wchar_t>' */ 
    template <>
    int collate<wchar_t>::_M_compare(const wchar_t *, const wchar_t *) const  throw();
    template <>
    unsigned long int collate<wchar_t>::_M_transform(wchar_t *, const wchar_t *, unsigned long int) const  throw();
    template < typename _CharT >
    class  collate_byname : public ::std::__cxx11::collate<_CharT>
    {
      public:
        typedef _CharT char_type;
        typedef ::std::__cxx11::basic_string<_CharT> string_type;
        inline explicit collate_byname(const char *__s, ::std::size_t __refs  = (0))
          : collate<_CharT>(__refs)
        {
          if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0)
            {
              this->_S_destroy_c_locale(this->_M_c_locale_collate);
              this->_S_create_c_locale(this->_M_c_locale_collate, __s);
            }
        }
      protected:
        inline virtual ~collate_byname()
        {
        }
    };
  }
  template < typename _Facet >
  locale::locale(const ::std::locale &__other, _Facet *__f)
  {
    (*this)._M_impl = new (::std::locale::_Impl)((*__other._M_impl), (1));
    try
    {
      (*(*this)._M_impl)._M_install_facet(&_Facet::id, __f);
    }
    catch (...)
    {
      (*(*this)._M_impl).::std::locale::_Impl::_M_remove_reference();
      throw;
    }
    delete[] (*(*this)._M_impl)._M_names[0];
    (*(*this)._M_impl)._M_names[0] = 0;
  }
  template < typename _Facet >
  ::std::locale locale::combine(const ::std::locale &__other) const 
  {
    ::std::locale::_Impl *__tmp(new (::std::locale::_Impl)((*(*this)._M_impl), (1)));
    try
    {
      (*__tmp)._M_replace_facet(__other._M_impl, &_Facet::id);
    }
    catch (...)
    {
      (*__tmp).::std::locale::_Impl::_M_remove_reference();
      throw;
    }
    return ::std::locale(__tmp);
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  bool locale::operator ()(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__s1, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__s2) const 
  {
    typedef ::std::__cxx11::collate<_CharT> __collate_type;
    const __collate_type &__collate = use_facet<__collate_type>(*this);
    return __collate.compare(__s1.data(), __s1.data() + __s1.length(), __s2.data(), __s2.data() + __s2.length()) < 0;
  }
  template < typename _Facet >
  bool has_facet(const ::std::locale &__loc) throw()
  {
    const ::std::size_t __i = _Facet::id._M_id();
    const ::std::locale::facet **__facets((*__loc._M_impl)._M_facets);
    return __i < (*__loc._M_impl)._M_facets_size && dynamic_cast<const _Facet *>(__facets[__i]);
  }
  template < typename _Facet >
  const _Facet &use_facet(const ::std::locale &__loc)
  {
    const ::std::size_t __i = _Facet::id._M_id();
    const ::std::locale::facet **__facets((*__loc._M_impl)._M_facets);
    if (__i >= (*__loc._M_impl)._M_facets_size || !__facets[__i])
      {
        ::std::__throw_bad_cast();
      }
    return dynamic_cast<const _Facet &>(*__facets[__i]);
  }
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    template < typename _CharT >
    int collate<_CharT>::_M_compare(const _CharT *, const _CharT *) const  throw()
    {
      return 0;
    }
    template < typename _CharT >
    ::std::size_t collate<_CharT>::_M_transform(_CharT *, const _CharT *, ::std::size_t) const  throw()
    {
      return 0;
    }
    template < typename _CharT >
    int collate<_CharT>::do_compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const 
    {
      const typename ::std::__cxx11::collate<_CharT>::string_type __one(__lo1, __hi1);
      const typename ::std::__cxx11::collate<_CharT>::string_type __two(__lo2, __hi2);
      const _CharT *__p = __one.c_str();
      const _CharT *__pend = __one.data() + __one.length();
      const _CharT *__q = __two.c_str();
      const _CharT *__qend = __two.data() + __two.length();
      for (; ; )
        {
          const int __res = (*this)._M_compare(__p, __q);
          if (__res)
            {
              return __res;
            }
          __p += char_traits<_CharT>::length(__p);
          __q += char_traits<_CharT>::length(__q);
          if (__p == __pend && __q == __qend)
            {
              return 0;
            }
          else
            {
              if (__p == __pend)
                {
                  return  -1;
                }
              else
                {
                  if (__q == __qend)
                    {
                      return 1;
                    }
                }
            }
          __p++;
          __q++;
        }
    }
    template < typename _CharT >
    typename ::std::__cxx11::collate<_CharT>::string_type collate<_CharT>::do_transform(const _CharT *__lo, const _CharT *__hi) const 
    {
      typename ::std::__cxx11::collate<_CharT>::string_type __ret;
      const typename ::std::__cxx11::collate<_CharT>::string_type __str(__lo, __hi);
      const _CharT *__p = __str.c_str();
      const _CharT *__pend = __str.data() + __str.length();
      ::std::size_t __len = (__hi - __lo) * 2;
      _CharT *__c = new _CharT [__len];
      try
      {
        for (; ; )
          {
            ::std::size_t __res = (*this)._M_transform(__c, __p, __len);
            if (__res >= __len)
              {
                __len = __res + 1;
                (delete[] __c, __c = 0);
                __c = (new _CharT [__len]);
                __res = (*this)._M_transform(__c, __p, __len);
              }
            __ret.append(__c, __res);
            __p += char_traits<_CharT>::length(__p);
            if (__p == __pend)
              {
                break;
              }
            __p++;
            __ret.push_back(_CharT());
          }
      }
      catch (...)
      {
        delete[] __c;
        throw;
      }
      delete[] __c;
      return __ret;
    }
 /* Instantiation of class template '::__gnu_cxx::__conditional_type<true, ::__gnu_cxx::__numeric_traits_integer<unsigned long int>, ::__gnu_cxx::__numeric_traits_floating<unsigned long int> >' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits_integer<unsigned long int>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits<unsigned long int>' */ 
    template < typename _CharT >
    long int collate<_CharT>::do_hash(const _CharT *__lo, const _CharT *__hi) const 
    {
      unsigned long int __val(0);
      for (; __lo < __hi;  ++__lo)
        {
          __val = *__lo + (__val << 7 | __val >> (::__gnu_cxx::__numeric_traits_integer<unsigned long int>::__digits - 7));
        }
      return static_cast<long int>(__val);
    }
    extern template class ::std::__cxx11::collate<char>;
    extern template class ::std::__cxx11::collate_byname<char>;
  }
  extern template const ::std::__cxx11::collate<char> &use_facet< ::std::__cxx11::collate<char> >(const ::std::locale &);
  extern template bool has_facet< ::std::__cxx11::collate<char> >(const ::std::locale &);
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    extern template class ::std::__cxx11::collate<wchar_t>;
    extern template class ::std::__cxx11::collate_byname<wchar_t>;
  }
  extern template const ::std::__cxx11::collate<wchar_t> &use_facet< ::std::__cxx11::collate<wchar_t> >(const ::std::locale &);
  extern template bool has_facet< ::std::__cxx11::collate<wchar_t> >(const ::std::locale &);
  struct  __cow_string
  {
      union 
      {
          const char *_M_p;
          char _M_bytes[8L];
      };
      __cow_string();
      __cow_string(const ::std::__cxx11::string &);
      __cow_string(const char *, ::std::size_t);
      __cow_string(const ::std::__cow_string &) throw();
      ::std::__cow_string &operator =(const ::std::__cow_string &) throw();
      ~__cow_string();
  };
  typedef ::std::__cxx11::basic_string<char> __sso_string;
  class  logic_error : public ::std::exception
  {
      ::std::__cow_string _M_msg;
    public:
      explicit logic_error(const ::std::__cxx11::string &__arg);
      logic_error(const ::std::logic_error &) throw();
      ::std::logic_error &operator =(const ::std::logic_error &) throw();
      virtual ~logic_error() throw();
      virtual const char *what() const  throw();
  };
  class  domain_error : public ::std::logic_error
  {
    public:
      explicit domain_error(const ::std::__cxx11::string &__arg);
      virtual ~domain_error() throw();
  };
  class  invalid_argument : public ::std::logic_error
  {
    public:
      explicit invalid_argument(const ::std::__cxx11::string &__arg);
      virtual ~invalid_argument() throw();
  };
  class  length_error : public ::std::logic_error
  {
    public:
      explicit length_error(const ::std::__cxx11::string &__arg);
      virtual ~length_error() throw();
  };
  class  out_of_range : public ::std::logic_error
  {
    public:
      explicit out_of_range(const ::std::__cxx11::string &__arg);
      virtual ~out_of_range() throw();
  };
  class  runtime_error : public ::std::exception
  {
      ::std::__cow_string _M_msg;
    public:
      explicit runtime_error(const ::std::__cxx11::string &__arg);
      runtime_error(const ::std::runtime_error &) throw();
      ::std::runtime_error &operator =(const ::std::runtime_error &) throw();
      virtual ~runtime_error() throw();
      virtual const char *what() const  throw();
  };
  class  range_error : public ::std::runtime_error
  {
    public:
      explicit range_error(const ::std::__cxx11::string &__arg);
      virtual ~range_error() throw();
  };
  class  overflow_error : public ::std::runtime_error
  {
    public:
      explicit overflow_error(const ::std::__cxx11::string &__arg);
      virtual ~overflow_error() throw();
  };
  class  underflow_error : public ::std::runtime_error
  {
    public:
      explicit underflow_error(const ::std::__cxx11::string &__arg);
      virtual ~underflow_error() throw();
  };
  enum _Ios_Fmtflags
  {
    _S_boolalpha = 1L << 0,
    _S_dec = 1L << 1,
    _S_fixed = 1L << 2,
    _S_hex = 1L << 3,
    _S_internal = 1L << 4,
    _S_left = 1L << 5,
    _S_oct = 1L << 6,
    _S_right = 1L << 7,
    _S_scientific = 1L << 8,
    _S_showbase = 1L << 9,
    _S_showpoint = 1L << 10,
    _S_showpos = 1L << 11,
    _S_skipws = 1L << 12,
    _S_unitbuf = 1L << 13,
    _S_uppercase = 1L << 14,
    _S_adjustfield = (::std::_S_left | ::std::_S_right) | ::std::_S_internal,
    _S_basefield = (::std::_S_dec | ::std::_S_oct) | ::std::_S_hex,
    _S_floatfield = ::std::_S_scientific | ::std::_S_fixed,
    _S_ios_fmtflags_end = 1L << 16,
    _S_ios_fmtflags_max = 2147483647,
    _S_ios_fmtflags_min = ~2147483647
  };
  inline ::std::_Ios_Fmtflags operator &(::std::_Ios_Fmtflags __a, ::std::_Ios_Fmtflags __b)
  {
    return (::std::_Ios_Fmtflags)(static_cast<int>(__a) & static_cast<int>(__b));
  }
  inline ::std::_Ios_Fmtflags operator |(::std::_Ios_Fmtflags __a, ::std::_Ios_Fmtflags __b)
  {
    return (::std::_Ios_Fmtflags)(static_cast<int>(__a) | static_cast<int>(__b));
  }
  inline ::std::_Ios_Fmtflags operator ^(::std::_Ios_Fmtflags __a, ::std::_Ios_Fmtflags __b)
  {
    return (::std::_Ios_Fmtflags)(static_cast<int>(__a) ^ static_cast<int>(__b));
  }
  inline ::std::_Ios_Fmtflags operator ~(::std::_Ios_Fmtflags __a)
  {
    return (::std::_Ios_Fmtflags)~static_cast<int>(__a);
  }
  inline const ::std::_Ios_Fmtflags &operator |=(::std::_Ios_Fmtflags &__a, ::std::_Ios_Fmtflags __b)
  {
    return __a = __a | __b;
  }
  inline const ::std::_Ios_Fmtflags &operator &=(::std::_Ios_Fmtflags &__a, ::std::_Ios_Fmtflags __b)
  {
    return __a = __a & __b;
  }
  inline const ::std::_Ios_Fmtflags &operator ^=(::std::_Ios_Fmtflags &__a, ::std::_Ios_Fmtflags __b)
  {
    return __a = __a ^ __b;
  }
  enum _Ios_Openmode
  {
    _S_app = 1L << 0,
    _S_ate = 1L << 1,
    _S_bin = 1L << 2,
    _S_in = 1L << 3,
    _S_out = 1L << 4,
    _S_trunc = 1L << 5,
    _S_ios_openmode_end = 1L << 16,
    _S_ios_openmode_max = 2147483647,
    _S_ios_openmode_min = ~2147483647
  };
  inline ::std::_Ios_Openmode operator &(::std::_Ios_Openmode __a, ::std::_Ios_Openmode __b)
  {
    return (::std::_Ios_Openmode)(static_cast<int>(__a) & static_cast<int>(__b));
  }
  inline ::std::_Ios_Openmode operator |(::std::_Ios_Openmode __a, ::std::_Ios_Openmode __b)
  {
    return (::std::_Ios_Openmode)(static_cast<int>(__a) | static_cast<int>(__b));
  }
  inline ::std::_Ios_Openmode operator ^(::std::_Ios_Openmode __a, ::std::_Ios_Openmode __b)
  {
    return (::std::_Ios_Openmode)(static_cast<int>(__a) ^ static_cast<int>(__b));
  }
  inline ::std::_Ios_Openmode operator ~(::std::_Ios_Openmode __a)
  {
    return (::std::_Ios_Openmode)~static_cast<int>(__a);
  }
  inline const ::std::_Ios_Openmode &operator |=(::std::_Ios_Openmode &__a, ::std::_Ios_Openmode __b)
  {
    return __a = __a | __b;
  }
  inline const ::std::_Ios_Openmode &operator &=(::std::_Ios_Openmode &__a, ::std::_Ios_Openmode __b)
  {
    return __a = __a & __b;
  }
  inline const ::std::_Ios_Openmode &operator ^=(::std::_Ios_Openmode &__a, ::std::_Ios_Openmode __b)
  {
    return __a = __a ^ __b;
  }
  enum _Ios_Iostate
  {
    _S_goodbit = 0,
    _S_badbit = 1L << 0,
    _S_eofbit = 1L << 1,
    _S_failbit = 1L << 2,
    _S_ios_iostate_end = 1L << 16,
    _S_ios_iostate_max = 2147483647,
    _S_ios_iostate_min = ~2147483647
  };
  inline ::std::_Ios_Iostate operator &(::std::_Ios_Iostate __a, ::std::_Ios_Iostate __b)
  {
    return (::std::_Ios_Iostate)(static_cast<int>(__a) & static_cast<int>(__b));
  }
  inline ::std::_Ios_Iostate operator |(::std::_Ios_Iostate __a, ::std::_Ios_Iostate __b)
  {
    return (::std::_Ios_Iostate)(static_cast<int>(__a) | static_cast<int>(__b));
  }
  inline ::std::_Ios_Iostate operator ^(::std::_Ios_Iostate __a, ::std::_Ios_Iostate __b)
  {
    return (::std::_Ios_Iostate)(static_cast<int>(__a) ^ static_cast<int>(__b));
  }
  inline ::std::_Ios_Iostate operator ~(::std::_Ios_Iostate __a)
  {
    return (::std::_Ios_Iostate)~static_cast<int>(__a);
  }
  inline const ::std::_Ios_Iostate &operator |=(::std::_Ios_Iostate &__a, ::std::_Ios_Iostate __b)
  {
    return __a = __a | __b;
  }
  inline const ::std::_Ios_Iostate &operator &=(::std::_Ios_Iostate &__a, ::std::_Ios_Iostate __b)
  {
    return __a = __a & __b;
  }
  inline const ::std::_Ios_Iostate &operator ^=(::std::_Ios_Iostate &__a, ::std::_Ios_Iostate __b)
  {
    return __a = __a ^ __b;
  }
  enum _Ios_Seekdir
  {
    _S_beg = 0,
    _S_cur = 1,
    _S_end = 2,
    _S_ios_seekdir_end = 1L << 16
  };
  class  ios_base
  {
      struct  system_error : ::std::runtime_error
      {
          struct  error_code
          {
              inline error_code()
              {
              }
            private:
              int _M_value;
              const void *_M_cat;
            public:
          };
          ::std::ios_base::system_error::error_code _M_code;
      };
    public:
      class __attribute__((__abi_tag__("cxx11")))  failure : public ::std::ios_base::system_error
      {
        public:
          explicit failure(const ::std::__cxx11::string &__str);
          virtual ~failure() throw();
          virtual const char *what() const  throw();
      };
      typedef ::std::_Ios_Fmtflags fmtflags;
      static const ::std::ios_base::fmtflags boolalpha = ::std::_S_boolalpha;
      static const ::std::ios_base::fmtflags dec = ::std::_S_dec;
      static const ::std::ios_base::fmtflags fixed = ::std::_S_fixed;
      static const ::std::ios_base::fmtflags hex = ::std::_S_hex;
      static const ::std::ios_base::fmtflags internal = ::std::_S_internal;
      static const ::std::ios_base::fmtflags left = ::std::_S_left;
      static const ::std::ios_base::fmtflags oct = ::std::_S_oct;
      static const ::std::ios_base::fmtflags right = ::std::_S_right;
      static const ::std::ios_base::fmtflags scientific = ::std::_S_scientific;
      static const ::std::ios_base::fmtflags showbase = ::std::_S_showbase;
      static const ::std::ios_base::fmtflags showpoint = ::std::_S_showpoint;
      static const ::std::ios_base::fmtflags showpos = ::std::_S_showpos;
      static const ::std::ios_base::fmtflags skipws = ::std::_S_skipws;
      static const ::std::ios_base::fmtflags unitbuf = ::std::_S_unitbuf;
      static const ::std::ios_base::fmtflags uppercase = ::std::_S_uppercase;
      static const ::std::ios_base::fmtflags adjustfield = ::std::_S_adjustfield;
      static const ::std::ios_base::fmtflags basefield = ::std::_S_basefield;
      static const ::std::ios_base::fmtflags floatfield = ::std::_S_floatfield;
      typedef ::std::_Ios_Iostate iostate;
      static const ::std::ios_base::iostate badbit = ::std::_S_badbit;
      static const ::std::ios_base::iostate eofbit = ::std::_S_eofbit;
      static const ::std::ios_base::iostate failbit = ::std::_S_failbit;
      static const ::std::ios_base::iostate goodbit = ::std::_S_goodbit;
      typedef ::std::_Ios_Openmode openmode;
      static const ::std::ios_base::openmode app = ::std::_S_app;
      static const ::std::ios_base::openmode ate = ::std::_S_ate;
      static const ::std::ios_base::openmode binary = ::std::_S_bin;
      static const ::std::ios_base::openmode in = ::std::_S_in;
      static const ::std::ios_base::openmode out = ::std::_S_out;
      static const ::std::ios_base::openmode trunc = ::std::_S_trunc;
      typedef ::std::_Ios_Seekdir seekdir;
      static const ::std::ios_base::seekdir beg = ::std::_S_beg;
      static const ::std::ios_base::seekdir cur = ::std::_S_cur;
      static const ::std::ios_base::seekdir end = ::std::_S_end;
      typedef int io_state;
      typedef int open_mode;
      typedef int seek_dir;
      typedef ::std::streampos streampos;
      typedef ::std::streamoff streamoff;
      enum event
      {
        erase_event = 0,
        imbue_event = 1,
        copyfmt_event = 2
      };
      typedef void (*event_callback)(::std::ios_base::event, ::std::ios_base &, int);
      void register_callback(::std::ios_base::event_callback __fn, int __index);
    protected:
      ::std::streamsize _M_precision;
      ::std::streamsize _M_width;
      ::std::ios_base::fmtflags _M_flags;
      ::std::ios_base::iostate _M_exception;
      ::std::ios_base::iostate _M_streambuf_state;
      struct  _Callback_list
      {
          ::std::ios_base::_Callback_list *_M_next;
          ::std::ios_base::event_callback _M_fn;
          int _M_index;
          ::_Atomic_word _M_refcount;
          inline _Callback_list(::std::ios_base::event_callback __fn, int __index, ::std::ios_base::_Callback_list *__cb)
            : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0)
          {
          }
          inline void _M_add_reference()
          {
            __gnu_cxx::__atomic_add_dispatch(&(*this)._M_refcount, 1);
          }
          inline int _M_remove_reference()
          {
            ;
            int __res(__gnu_cxx::__exchange_and_add_dispatch(&(*this)._M_refcount,  -1));
            if (__res == 0)
              {
                ;
              }
            return __res;
          }
      };
      ::std::ios_base::_Callback_list *_M_callbacks;
      void _M_call_callbacks(::std::ios_base::event __ev) throw();
      void _M_dispose_callbacks() throw();
      struct  _Words
      {
          void *_M_pword;
          long int _M_iword;
          inline _Words()
            : _M_pword(0), _M_iword(0)
          {
          }
      };
      ::std::ios_base::_Words _M_word_zero;
      enum mcc_enum_anon_67
      {
        _S_local_word_size = 8
      };
      ::std::ios_base::_Words _M_local_word[8L];
      int _M_word_size;
      ::std::ios_base::_Words *_M_word;
      ::std::ios_base::_Words &_M_grow_words(int __index, bool __iword);
      ::std::locale _M_ios_locale;
      void _M_init() throw();
    public:
      class  Init
      {
        public:
          Init();
          ~Init();
        private:
          static ::_Atomic_word _S_refcount;
          static bool _S_synced_with_stdio;
        public:
        friend class ios_base;
      };
      inline ::std::ios_base::fmtflags flags() const 
      {
        return (*this)._M_flags;
      }
      inline ::std::ios_base::fmtflags flags(::std::ios_base::fmtflags __fmtfl)
      {
        ::std::ios_base::fmtflags __old((*this)._M_flags);
        (*this)._M_flags = __fmtfl;
        return __old;
      }
      inline ::std::ios_base::fmtflags setf(::std::ios_base::fmtflags __fmtfl)
      {
        ::std::ios_base::fmtflags __old((*this)._M_flags);
        (*this)._M_flags |= __fmtfl;
        return __old;
      }
      inline ::std::ios_base::fmtflags setf(::std::ios_base::fmtflags __fmtfl, ::std::ios_base::fmtflags __mask)
      {
        ::std::ios_base::fmtflags __old((*this)._M_flags);
        (*this)._M_flags &=  ~__mask;
        (*this)._M_flags |= __fmtfl & __mask;
        return __old;
      }
      inline void unsetf(::std::ios_base::fmtflags __mask)
      {
        (*this)._M_flags &=  ~__mask;
      }
      inline ::std::streamsize precision() const 
      {
        return (*this)._M_precision;
      }
      inline ::std::streamsize precision(::std::streamsize __prec)
      {
        ::std::streamsize __old((*this)._M_precision);
        (*this)._M_precision = __prec;
        return __old;
      }
      inline ::std::streamsize width() const 
      {
        return (*this)._M_width;
      }
      inline ::std::streamsize width(::std::streamsize __wide)
      {
        ::std::streamsize __old((*this)._M_width);
        (*this)._M_width = __wide;
        return __old;
      }
      static bool sync_with_stdio(bool __sync  = (true));
      ::std::locale imbue(const ::std::locale &__loc) throw();
      inline ::std::locale getloc() const 
      {
        return (*this)._M_ios_locale;
      }
      inline const ::std::locale &_M_getloc() const 
      {
        return (*this)._M_ios_locale;
      }
      static int xalloc() throw();
      inline long int &iword(int __ix)
      {
        ::std::ios_base::_Words &__word(__ix < (*this)._M_word_size ? (*this)._M_word[__ix] : (*this).::std::ios_base::_M_grow_words(__ix, true));
        return __word._M_iword;
      }
      inline void *&pword(int __ix)
      {
        ::std::ios_base::_Words &__word(__ix < (*this)._M_word_size ? (*this)._M_word[__ix] : (*this).::std::ios_base::_M_grow_words(__ix, false));
        return __word._M_pword;
      }
      virtual ~ios_base();
    protected:
      ios_base() throw();
    private:
      ios_base(const ::std::ios_base &);
      ::std::ios_base &operator =(const ::std::ios_base &);
  };
  inline ::std::ios_base &boolalpha(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::boolalpha);
    return __base;
  }
  inline ::std::ios_base &noboolalpha(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::boolalpha);
    return __base;
  }
  inline ::std::ios_base &showbase(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::showbase);
    return __base;
  }
  inline ::std::ios_base &noshowbase(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::showbase);
    return __base;
  }
  inline ::std::ios_base &showpoint(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::showpoint);
    return __base;
  }
  inline ::std::ios_base &noshowpoint(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::showpoint);
    return __base;
  }
  inline ::std::ios_base &showpos(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::showpos);
    return __base;
  }
  inline ::std::ios_base &noshowpos(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::showpos);
    return __base;
  }
  inline ::std::ios_base &skipws(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::skipws);
    return __base;
  }
  inline ::std::ios_base &noskipws(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::skipws);
    return __base;
  }
  inline ::std::ios_base &uppercase(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::uppercase);
    return __base;
  }
  inline ::std::ios_base &nouppercase(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::uppercase);
    return __base;
  }
  inline ::std::ios_base &unitbuf(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::unitbuf);
    return __base;
  }
  inline ::std::ios_base &nounitbuf(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::unitbuf);
    return __base;
  }
  inline ::std::ios_base &internal(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::internal, ::std::ios_base::adjustfield);
    return __base;
  }
  inline ::std::ios_base &left(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::left, ::std::ios_base::adjustfield);
    return __base;
  }
  inline ::std::ios_base &right(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::right, ::std::ios_base::adjustfield);
    return __base;
  }
  inline ::std::ios_base &dec(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::dec, ::std::ios_base::basefield);
    return __base;
  }
  inline ::std::ios_base &hex(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::hex, ::std::ios_base::basefield);
    return __base;
  }
  inline ::std::ios_base &oct(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::oct, ::std::ios_base::basefield);
    return __base;
  }
  inline ::std::ios_base &fixed(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::fixed, ::std::ios_base::floatfield);
    return __base;
  }
  inline ::std::ios_base &scientific(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::scientific, ::std::ios_base::floatfield);
    return __base;
  }
  template < typename _CharT, typename _Traits >
  ::std::streamsize __copy_streambufs_eof(::std::basic_streambuf<_CharT, _Traits> *__sbin, ::std::basic_streambuf<_CharT, _Traits> *__sbout, bool &__ineof);
  template < typename _CharT, typename _Traits >
  class  basic_streambuf
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef ::std::basic_streambuf<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, typename ::std::basic_streambuf<_CharT, _Traits>::traits_type> __streambuf_type;
    protected:
      typename ::std::basic_streambuf<_CharT, _Traits>::char_type *_M_in_beg;
      typename ::std::basic_streambuf<_CharT, _Traits>::char_type *_M_in_cur;
      typename ::std::basic_streambuf<_CharT, _Traits>::char_type *_M_in_end;
      typename ::std::basic_streambuf<_CharT, _Traits>::char_type *_M_out_beg;
      typename ::std::basic_streambuf<_CharT, _Traits>::char_type *_M_out_cur;
      typename ::std::basic_streambuf<_CharT, _Traits>::char_type *_M_out_end;
      ::std::locale _M_buf_locale;
    public:
      inline virtual ~basic_streambuf()
      {
      }
      inline ::std::locale pubimbue(const ::std::locale &__loc)
      {
        ::std::locale __tmp(this->getloc());
        this->imbue(__loc);
        ::std::basic_streambuf<_CharT, _Traits>::_M_buf_locale = __loc;
        return __tmp;
      }
      inline ::std::locale getloc() const 
      {
        return ::std::basic_streambuf<_CharT, _Traits>::_M_buf_locale;
      }
      inline ::std::basic_streambuf<_CharT, _Traits> *pubsetbuf(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
      {
        return this->setbuf(__s, __n);
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::pos_type pubseekoff(typename ::std::basic_streambuf<_CharT, _Traits>::off_type __off, ::std::ios_base::seekdir __way, ::std::ios_base::openmode __mode  = (::std::ios_base::in | ::std::ios_base::out))
      {
        return this->seekoff(__off, __way, __mode);
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::pos_type pubseekpos(typename ::std::basic_streambuf<_CharT, _Traits>::pos_type __sp, ::std::ios_base::openmode __mode  = (::std::ios_base::in | ::std::ios_base::out))
      {
        return this->seekpos(__sp, __mode);
      }
      inline int pubsync()
      {
        return this->sync();
      }
      inline ::std::streamsize in_avail()
      {
        const ::std::streamsize __ret = this->egptr() - this->gptr();
        return __ret ? __ret : this->showmanyc();
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::int_type snextc()
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret = traits_type::eof();
        if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(), __ret), true))
          {
            __ret = this->sgetc();
          }
        return __ret;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::int_type sbumpc()
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret;
        if (__builtin_expect(this->gptr() < this->egptr(), true))
          {
            __ret = traits_type::to_int_type(*this->gptr());
            this->gbump(1);
          }
        else
          {
            __ret = this->uflow();
          }
        return __ret;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::int_type sgetc()
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret;
        if (__builtin_expect(this->gptr() < this->egptr(), true))
          {
            __ret = traits_type::to_int_type(*this->gptr());
          }
        else
          {
            __ret = this->underflow();
          }
        return __ret;
      }
      inline ::std::streamsize sgetn(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
      {
        return this->xsgetn(__s, __n);
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::int_type sputbackc(typename ::std::basic_streambuf<_CharT, _Traits>::char_type __c)
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret;
        const bool __testpos = this->eback() < this->gptr();
        if (__builtin_expect(!__testpos || !traits_type::eq(__c, this->gptr()[ -1]), false))
          {
            __ret = this->pbackfail(traits_type::to_int_type(__c));
          }
        else
          {
            this->gbump( -1);
            __ret = traits_type::to_int_type(*this->gptr());
          }
        return __ret;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::int_type sungetc()
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret;
        if (__builtin_expect(this->eback() < this->gptr(), true))
          {
            this->gbump( -1);
            __ret = traits_type::to_int_type(*this->gptr());
          }
        else
          {
            __ret = this->pbackfail();
          }
        return __ret;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::int_type sputc(typename ::std::basic_streambuf<_CharT, _Traits>::char_type __c)
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret;
        if (__builtin_expect(this->pptr() < this->epptr(), true))
          {
            *this->pptr() = __c;
            this->pbump(1);
            __ret = traits_type::to_int_type(__c);
          }
        else
          {
            __ret = this->overflow(traits_type::to_int_type(__c));
          }
        return __ret;
      }
      inline ::std::streamsize sputn(const typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
      {
        return this->xsputn(__s, __n);
      }
    protected:
      inline basic_streambuf()
        : _M_in_beg(0), _M_in_cur(0), _M_in_end(0), _M_out_beg(0), _M_out_cur(0), _M_out_end(0), _M_buf_locale(::std::locale())
      {
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::char_type *eback() const 
      {
        return ::std::basic_streambuf<_CharT, _Traits>::_M_in_beg;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::char_type *gptr() const 
      {
        return ::std::basic_streambuf<_CharT, _Traits>::_M_in_cur;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::char_type *egptr() const 
      {
        return ::std::basic_streambuf<_CharT, _Traits>::_M_in_end;
      }
      inline void gbump(int __n)
      {
        ::std::basic_streambuf<_CharT, _Traits>::_M_in_cur += __n;
      }
      inline void setg(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__gbeg, typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__gnext, typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__gend)
      {
        ::std::basic_streambuf<_CharT, _Traits>::_M_in_beg = __gbeg;
        ::std::basic_streambuf<_CharT, _Traits>::_M_in_cur = __gnext;
        ::std::basic_streambuf<_CharT, _Traits>::_M_in_end = __gend;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::char_type *pbase() const 
      {
        return ::std::basic_streambuf<_CharT, _Traits>::_M_out_beg;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::char_type *pptr() const 
      {
        return ::std::basic_streambuf<_CharT, _Traits>::_M_out_cur;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::char_type *epptr() const 
      {
        return ::std::basic_streambuf<_CharT, _Traits>::_M_out_end;
      }
      inline void pbump(int __n)
      {
        ::std::basic_streambuf<_CharT, _Traits>::_M_out_cur += __n;
      }
      inline void setp(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__pbeg, typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__pend)
      {
        ::std::basic_streambuf<_CharT, _Traits>::_M_out_beg = ::std::basic_streambuf<_CharT, _Traits>::_M_out_cur = __pbeg;
        ::std::basic_streambuf<_CharT, _Traits>::_M_out_end = __pend;
      }
      inline virtual void imbue(const ::std::locale &__loc)
      {
      }
      inline virtual ::std::basic_streambuf<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, _Traits> *setbuf(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *, ::std::streamsize)
      {
        return this;
      }
      inline virtual typename ::std::basic_streambuf<_CharT, _Traits>::pos_type seekoff(typename ::std::basic_streambuf<_CharT, _Traits>::off_type, ::std::ios_base::seekdir, ::std::ios_base::openmode  = (::std::ios_base::in | ::std::ios_base::out))
      {
        return ((typename ::std::basic_streambuf<_CharT, _Traits>::pos_type(((typename ::std::basic_streambuf<_CharT, _Traits>::off_type( -1))))));
      }
      inline virtual typename ::std::basic_streambuf<_CharT, _Traits>::pos_type seekpos(typename ::std::basic_streambuf<_CharT, _Traits>::pos_type, ::std::ios_base::openmode  = (::std::ios_base::in | ::std::ios_base::out))
      {
        return ((typename ::std::basic_streambuf<_CharT, _Traits>::pos_type(((typename ::std::basic_streambuf<_CharT, _Traits>::off_type( -1))))));
      }
      inline virtual int sync()
      {
        return 0;
      }
      inline virtual ::std::streamsize showmanyc()
      {
        return 0;
      }
      virtual ::std::streamsize xsgetn(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n);
      inline virtual typename ::std::basic_streambuf<_CharT, _Traits>::int_type underflow()
      {
        return traits_type::eof();
      }
      inline virtual typename ::std::basic_streambuf<_CharT, _Traits>::int_type uflow()
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret = traits_type::eof();
        const bool __testeof = traits_type::eq_int_type(this->underflow(), __ret);
        if (!__testeof)
          {
            __ret = traits_type::to_int_type(*this->gptr());
            this->gbump(1);
          }
        return __ret;
      }
      inline virtual typename ::std::basic_streambuf<_CharT, _Traits>::int_type pbackfail(typename ::std::basic_streambuf<_CharT, _Traits>::int_type __c  = (traits_type::eof()))
      {
        return traits_type::eof();
      }
      virtual ::std::streamsize xsputn(const typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n);
      inline virtual typename ::std::basic_streambuf<_CharT, _Traits>::int_type overflow(typename ::std::basic_streambuf<_CharT, _Traits>::int_type __c  = (traits_type::eof()))
      {
        return traits_type::eof();
      }
    public:
      inline void stossc()
      {
        if (this->gptr() < this->egptr())
          {
            this->gbump(1);
          }
        else
          {
            this->uflow();
          }
      }
      inline void __safe_gbump(::std::streamsize __n)
      {
        ::std::basic_streambuf<_CharT, _Traits>::_M_in_cur += __n;
      }
      inline void __safe_pbump(::std::streamsize __n)
      {
        ::std::basic_streambuf<_CharT, _Traits>::_M_out_cur += __n;
      }
    private:
      basic_streambuf(const ::std::basic_streambuf<_CharT, _Traits> &);
      ::std::basic_streambuf<_CharT, _Traits> &operator =(const ::std::basic_streambuf<_CharT, _Traits> &);
    friend class ::std::basic_ios<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, typename ::std::basic_streambuf<_CharT, _Traits>::traits_type>;
    friend class ::std::basic_istream<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, typename ::std::basic_streambuf<_CharT, _Traits>::traits_type>;
    friend class ::std::basic_ostream<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, typename ::std::basic_streambuf<_CharT, _Traits>::traits_type>;
    friend class ::std::istreambuf_iterator<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, typename ::std::basic_streambuf<_CharT, _Traits>::traits_type>;
    friend class ::std::ostreambuf_iterator<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, typename ::std::basic_streambuf<_CharT, _Traits>::traits_type>;
    friend ::std::streamsize __copy_streambufs_eof<>(::std::basic_streambuf<_CharT, _Traits> *, ::std::basic_streambuf<_CharT, _Traits> *, bool &);
    template < bool _IsMove, typename _CharT2 >
    friend typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(::std::istreambuf_iterator<_CharT2>, ::std::istreambuf_iterator<_CharT2>, _CharT2 *);
    template < typename _CharT2 >
    friend typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ::std::istreambuf_iterator<_CharT2> >::__type find(::std::istreambuf_iterator<_CharT2>, ::std::istreambuf_iterator<_CharT2>, const _CharT2 &);
    template < typename _CharT2, typename _Traits2 >
    friend ::std::basic_istream<_CharT2, _Traits2> &operator >>(::std::basic_istream<_CharT2, _Traits2> &, _CharT2 *);
    template < typename _CharT2, typename _Traits2, typename _Alloc >
    friend ::std::basic_istream<_CharT2, _Traits2> &operator >>(::std::basic_istream<_CharT2, _Traits2> &, ::std::__cxx11::basic_string<_CharT2, _Traits2, _Alloc> &);
    template < typename _CharT2, typename _Traits2, typename _Alloc >
    friend ::std::basic_istream<_CharT2, _Traits2> &getline(::std::basic_istream<_CharT2, _Traits2> &, ::std::__cxx11::basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
  };
  template <>
  long int __copy_streambufs_eof<char, ::std::char_traits<char> >(::std::basic_streambuf<char> *__sbin, ::std::basic_streambuf<char> *__sbout, bool &__ineof);
  template <>
  long int __copy_streambufs_eof<wchar_t, ::std::char_traits<wchar_t> >(::std::basic_streambuf<wchar_t> *__sbin, ::std::basic_streambuf<wchar_t> *__sbout, bool &__ineof);
  template < typename _CharT, typename _Traits >
  ::std::streamsize basic_streambuf<_CharT, _Traits>::xsgetn(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
  {
    ::std::streamsize __ret(0);
    while (__ret < __n)
      {
        const ::std::streamsize __buf_len = this->egptr() - this->gptr();
        if (__buf_len)
          {
            const ::std::streamsize __remaining(__n - __ret);
            const ::std::streamsize __len = std::min(__buf_len, __remaining);
            traits_type::copy(__s, this->gptr(), __len);
            __ret += __len;
            __s += __len;
            this->__safe_gbump(__len);
          }
        if (__ret < __n)
          {
            const typename ::std::basic_streambuf<_CharT, _Traits>::int_type __c = this->uflow();
            if (!traits_type::eq_int_type(__c, traits_type::eof()))
              {
                traits_type::assign(*__s++, traits_type::to_char_type(__c));
                 ++__ret;
              }
            else
              {
                break;
              }
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  ::std::streamsize basic_streambuf<_CharT, _Traits>::xsputn(const typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
  {
    ::std::streamsize __ret(0);
    while (__ret < __n)
      {
        const ::std::streamsize __buf_len = this->epptr() - this->pptr();
        if (__buf_len)
          {
            const ::std::streamsize __remaining(__n - __ret);
            const ::std::streamsize __len = std::min(__buf_len, __remaining);
            traits_type::copy(this->pptr(), __s, __len);
            __ret += __len;
            __s += __len;
            this->__safe_pbump(__len);
          }
        if (__ret < __n)
          {
            typename ::std::basic_streambuf<_CharT, _Traits>::int_type __c = this->overflow(traits_type::to_int_type(*__s));
            if (!traits_type::eq_int_type(__c, traits_type::eof()))
              {
                 ++__ret;
                 ++__s;
              }
            else
              {
                break;
              }
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  ::std::streamsize __copy_streambufs_eof(::std::basic_streambuf<_CharT, _Traits> *__sbin, ::std::basic_streambuf<_CharT, _Traits> *__sbout, bool &__ineof)
  {
    ::std::streamsize __ret(0);
    __ineof = true;
    typename _Traits::int_type __c = __sbin->sgetc();
    while (!_Traits::eq_int_type(__c, _Traits::eof()))
      {
        __c = __sbout->sputc(_Traits::to_char_type(__c));
        if (_Traits::eq_int_type(__c, _Traits::eof()))
          {
            __ineof = false;
            break;
          }
         ++__ret;
        __c = __sbin->snextc();
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  inline ::std::streamsize __copy_streambufs(::std::basic_streambuf<_CharT, _Traits> *__sbin, ::std::basic_streambuf<_CharT, _Traits> *__sbout);
  template < typename _CharT, typename _Traits >
  inline ::std::streamsize __copy_streambufs(::std::basic_streambuf<_CharT, _Traits> *__sbin, ::std::basic_streambuf<_CharT, _Traits> *__sbout)
  {
    bool __ineof;
    return __copy_streambufs_eof(__sbin, __sbout, __ineof);
  }
  extern template class ::std::basic_streambuf<char>;
  extern template long int __copy_streambufs(::std::basic_streambuf<char> *, ::std::basic_streambuf<char> *);
  extern template long int __copy_streambufs_eof(::std::basic_streambuf<char> *, ::std::basic_streambuf<char> *, bool &);
  extern template class ::std::basic_streambuf<wchar_t>;
  extern template long int __copy_streambufs(::std::basic_streambuf<wchar_t> *, ::std::basic_streambuf<wchar_t> *);
  extern template long int __copy_streambufs_eof(::std::basic_streambuf<wchar_t> *, ::std::basic_streambuf<wchar_t> *, bool &);
}
typedef unsigned long int wctype_t;
enum mcc_enum_anon_68
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,
  _ISwupper = ::__ISwupper < 8 ? (int)(1LU << ::__ISwupper << 24) : ::__ISwupper < 16 ? (int)(1LU << ::__ISwupper << 8) : ::__ISwupper < 24 ? (int)(1LU << ::__ISwupper >> 8) : (int)(1LU << ::__ISwupper >> 24),
  _ISwlower = ::__ISwlower < 8 ? (int)(1LU << ::__ISwlower << 24) : ::__ISwlower < 16 ? (int)(1LU << ::__ISwlower << 8) : ::__ISwlower < 24 ? (int)(1LU << ::__ISwlower >> 8) : (int)(1LU << ::__ISwlower >> 24),
  _ISwalpha = ::__ISwalpha < 8 ? (int)(1LU << ::__ISwalpha << 24) : ::__ISwalpha < 16 ? (int)(1LU << ::__ISwalpha << 8) : ::__ISwalpha < 24 ? (int)(1LU << ::__ISwalpha >> 8) : (int)(1LU << ::__ISwalpha >> 24),
  _ISwdigit = ::__ISwdigit < 8 ? (int)(1LU << ::__ISwdigit << 24) : ::__ISwdigit < 16 ? (int)(1LU << ::__ISwdigit << 8) : ::__ISwdigit < 24 ? (int)(1LU << ::__ISwdigit >> 8) : (int)(1LU << ::__ISwdigit >> 24),
  _ISwxdigit = ::__ISwxdigit < 8 ? (int)(1LU << ::__ISwxdigit << 24) : ::__ISwxdigit < 16 ? (int)(1LU << ::__ISwxdigit << 8) : ::__ISwxdigit < 24 ? (int)(1LU << ::__ISwxdigit >> 8) : (int)(1LU << ::__ISwxdigit >> 24),
  _ISwspace = ::__ISwspace < 8 ? (int)(1LU << ::__ISwspace << 24) : ::__ISwspace < 16 ? (int)(1LU << ::__ISwspace << 8) : ::__ISwspace < 24 ? (int)(1LU << ::__ISwspace >> 8) : (int)(1LU << ::__ISwspace >> 24),
  _ISwprint = ::__ISwprint < 8 ? (int)(1LU << ::__ISwprint << 24) : ::__ISwprint < 16 ? (int)(1LU << ::__ISwprint << 8) : ::__ISwprint < 24 ? (int)(1LU << ::__ISwprint >> 8) : (int)(1LU << ::__ISwprint >> 24),
  _ISwgraph = ::__ISwgraph < 8 ? (int)(1LU << ::__ISwgraph << 24) : ::__ISwgraph < 16 ? (int)(1LU << ::__ISwgraph << 8) : ::__ISwgraph < 24 ? (int)(1LU << ::__ISwgraph >> 8) : (int)(1LU << ::__ISwgraph >> 24),
  _ISwblank = ::__ISwblank < 8 ? (int)(1LU << ::__ISwblank << 24) : ::__ISwblank < 16 ? (int)(1LU << ::__ISwblank << 8) : ::__ISwblank < 24 ? (int)(1LU << ::__ISwblank >> 8) : (int)(1LU << ::__ISwblank >> 24),
  _ISwcntrl = ::__ISwcntrl < 8 ? (int)(1LU << ::__ISwcntrl << 24) : ::__ISwcntrl < 16 ? (int)(1LU << ::__ISwcntrl << 8) : ::__ISwcntrl < 24 ? (int)(1LU << ::__ISwcntrl >> 8) : (int)(1LU << ::__ISwcntrl >> 24),
  _ISwpunct = ::__ISwpunct < 8 ? (int)(1LU << ::__ISwpunct << 24) : ::__ISwpunct < 16 ? (int)(1LU << ::__ISwpunct << 8) : ::__ISwpunct < 24 ? (int)(1LU << ::__ISwpunct >> 8) : (int)(1LU << ::__ISwpunct >> 24),
  _ISwalnum = ::__ISwalnum < 8 ? (int)(1LU << ::__ISwalnum << 24) : ::__ISwalnum < 16 ? (int)(1LU << ::__ISwalnum << 8) : ::__ISwalnum < 24 ? (int)(1LU << ::__ISwalnum >> 8) : (int)(1LU << ::__ISwalnum >> 24)
};
extern "C"
{
  extern int iswalnum(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswalpha(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswcntrl(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswdigit(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswgraph(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswlower(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswprint(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswpunct(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswspace(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswupper(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswxdigit(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswblank(::wint_t __wc) throw();
}
extern "C"
{
  extern ::wctype_t wctype(const char *__property) throw();
}
extern "C"
{
  extern int iswctype(::wint_t __wc, ::wctype_t __desc) throw();
}
extern "C"
{
  extern ::wint_t towlower(::wint_t __wc) throw();
}
extern "C"
{
  extern ::wint_t towupper(::wint_t __wc) throw();
}
typedef const ::__int32_t *wctrans_t;
extern "C"
{
  extern ::wctrans_t wctrans(const char *__property) throw();
}
extern "C"
{
  extern ::wint_t towctrans(::wint_t __wc, ::wctrans_t __desc) throw();
}
extern "C"
{
  extern int iswalnum_l(::wint_t __wc, ::locale_t __locale) throw();
}
extern "C"
{
  extern int iswalpha_l(::wint_t __wc, ::locale_t __locale) throw();
}
extern "C"
{
  extern int iswcntrl_l(::wint_t __wc, ::locale_t __locale) throw();
}
extern "C"
{
  extern int iswdigit_l(::wint_t __wc, ::locale_t __locale) throw();
}
extern "C"
{
  extern int iswgraph_l(::wint_t __wc, ::locale_t __locale) throw();
}
extern "C"
{
  extern int iswlower_l(::wint_t __wc, ::locale_t __locale) throw();
}
extern "C"
{
  extern int iswprint_l(::wint_t __wc, ::locale_t __locale) throw();
}
extern "C"
{
  extern int iswpunct_l(::wint_t __wc, ::locale_t __locale) throw();
}
extern "C"
{
  extern int iswspace_l(::wint_t __wc, ::locale_t __locale) throw();
}
extern "C"
{
  extern int iswupper_l(::wint_t __wc, ::locale_t __locale) throw();
}
extern "C"
{
  extern int iswxdigit_l(::wint_t __wc, ::locale_t __locale) throw();
}
extern "C"
{
  extern int iswblank_l(::wint_t __wc, ::locale_t __locale) throw();
}
extern "C"
{
  extern ::wctype_t wctype_l(const char *__property, ::locale_t __locale) throw();
}
extern "C"
{
  extern int iswctype_l(::wint_t __wc, ::wctype_t __desc, ::locale_t __locale) throw();
}
extern "C"
{
  extern ::wint_t towlower_l(::wint_t __wc, ::locale_t __locale) throw();
}
extern "C"
{
  extern ::wint_t towupper_l(::wint_t __wc, ::locale_t __locale) throw();
}
extern "C"
{
  extern ::wctrans_t wctrans_l(const char *__property, ::locale_t __locale) throw();
}
extern "C"
{
  extern ::wint_t towctrans_l(::wint_t __wc, ::wctrans_t __desc, ::locale_t __locale) throw();
}
namespace std __attribute__((__visibility__("default"))) {
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;
  using ::iswalnum;
  using ::iswalpha;
  using ::iswblank;
  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
  struct  ctype_base
  {
      typedef const int *__to_type;
      typedef unsigned short int mask;
      static const ::std::ctype_base::mask upper = ::_ISupper;
      static const ::std::ctype_base::mask lower = ::_ISlower;
      static const ::std::ctype_base::mask alpha = ::_ISalpha;
      static const ::std::ctype_base::mask digit = ::_ISdigit;
      static const ::std::ctype_base::mask xdigit = ::_ISxdigit;
      static const ::std::ctype_base::mask space = ::_ISspace;
      static const ::std::ctype_base::mask print = ::_ISprint;
      static const ::std::ctype_base::mask graph = (::_ISalpha | ::_ISdigit) | ::_ISpunct;
      static const ::std::ctype_base::mask cntrl = ::_IScntrl;
      static const ::std::ctype_base::mask punct = ::_ISpunct;
      static const ::std::ctype_base::mask alnum = ::_ISalpha | ::_ISdigit;
  };
  template < typename _CharT, typename _Traits >
  class  istreambuf_iterator : public ::std::iterator< ::std::input_iterator_tag, _CharT, typename _Traits::off_type, _CharT *, _CharT &>
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef ::std::basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef ::std::basic_istream<_CharT, _Traits> istream_type;
    private:
      mutable typename ::std::istreambuf_iterator<_CharT, _Traits>::streambuf_type *_M_sbuf;
      mutable typename ::std::istreambuf_iterator<_CharT, _Traits>::int_type _M_c;
    public:
      inline istreambuf_iterator() throw()
        : _M_sbuf(0), _M_c(traits_type::eof())
      {
      }
      inline istreambuf_iterator(typename ::std::istreambuf_iterator<_CharT, _Traits>::istream_type &__s) throw()
        : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof())
      {
      }
      inline istreambuf_iterator(typename ::std::istreambuf_iterator<_CharT, _Traits>::streambuf_type *__s) throw()
        : _M_sbuf(__s), _M_c(traits_type::eof())
      {
      }
      inline typename ::std::istreambuf_iterator<_CharT, _Traits>::char_type operator *() const 
      {
        return traits_type::to_char_type((*this)._M_get());
      }
      inline ::std::istreambuf_iterator<_CharT, _Traits> &operator ++()
      {
        ;
        if (::std::istreambuf_iterator<_CharT, _Traits>::_M_sbuf)
          {
            ::std::istreambuf_iterator<_CharT, _Traits>::_M_sbuf->sbumpc();
            ::std::istreambuf_iterator<_CharT, _Traits>::_M_c = traits_type::eof();
          }
        return *this;
      }
      inline ::std::istreambuf_iterator<_CharT, _Traits> operator ++(int)
      {
        ;
        ::std::istreambuf_iterator<_CharT, _Traits> __old = *this;
        if (::std::istreambuf_iterator<_CharT, _Traits>::_M_sbuf)
          {
            __old._M_c = ::std::istreambuf_iterator<_CharT, _Traits>::_M_sbuf->sbumpc();
            ::std::istreambuf_iterator<_CharT, _Traits>::_M_c = traits_type::eof();
          }
        return __old;
      }
      inline bool equal(const ::std::istreambuf_iterator<_CharT, _Traits> &__b) const 
      {
        return (*this)._M_at_eof() == __b._M_at_eof();
      }
    private:
      inline typename ::std::istreambuf_iterator<_CharT, _Traits>::int_type _M_get() const 
      {
        const typename ::std::istreambuf_iterator<_CharT, _Traits>::int_type __eof = traits_type::eof();
        typename ::std::istreambuf_iterator<_CharT, _Traits>::int_type __ret = __eof;
        if (::std::istreambuf_iterator<_CharT, _Traits>::_M_sbuf)
          {
            if (!traits_type::eq_int_type(::std::istreambuf_iterator<_CharT, _Traits>::_M_c, __eof))
              {
                __ret = ::std::istreambuf_iterator<_CharT, _Traits>::_M_c;
              }
            else
              {
                if (!traits_type::eq_int_type(__ret = ::std::istreambuf_iterator<_CharT, _Traits>::_M_sbuf->sgetc(), __eof))
                  {
                    ::std::istreambuf_iterator<_CharT, _Traits>::_M_c = __ret;
                  }
                else
                  {
                    ::std::istreambuf_iterator<_CharT, _Traits>::_M_sbuf = 0;
                  }
              }
          }
        return __ret;
      }
      inline bool _M_at_eof() const 
      {
        const typename ::std::istreambuf_iterator<_CharT, _Traits>::int_type __eof = traits_type::eof();
        return traits_type::eq_int_type((*this)._M_get(), __eof);
      }
    template < typename _CharT2 >
    friend typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ::std::ostreambuf_iterator<_CharT2> >::__type copy(::std::istreambuf_iterator<_CharT2>, ::std::istreambuf_iterator<_CharT2>, ::std::ostreambuf_iterator<_CharT2>);
    template < bool _IsMove, typename _CharT2 >
    friend typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(::std::istreambuf_iterator<_CharT2>, ::std::istreambuf_iterator<_CharT2>, _CharT2 *);
    template < typename _CharT2 >
    friend typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ::std::istreambuf_iterator<_CharT2> >::__type find(::std::istreambuf_iterator<_CharT2>, ::std::istreambuf_iterator<_CharT2>, const _CharT2 &);
  };
  template < typename _CharT, typename _Traits >
  inline bool operator ==(const ::std::istreambuf_iterator<_CharT, _Traits> &__a, const ::std::istreambuf_iterator<_CharT, _Traits> &__b);
  template < typename _CharT, typename _Traits >
  inline bool operator ==(const ::std::istreambuf_iterator<_CharT, _Traits> &__a, const ::std::istreambuf_iterator<_CharT, _Traits> &__b)
  {
    return __a.equal(__b);
  }
  template < typename _CharT, typename _Traits >
  inline bool operator !=(const ::std::istreambuf_iterator<_CharT, _Traits> &__a, const ::std::istreambuf_iterator<_CharT, _Traits> &__b);
  template < typename _CharT, typename _Traits >
  inline bool operator !=(const ::std::istreambuf_iterator<_CharT, _Traits> &__a, const ::std::istreambuf_iterator<_CharT, _Traits> &__b)
  {
    return !__a.equal(__b);
  }
  template < typename _CharT, typename _Traits >
  class  ostreambuf_iterator : public ::std::iterator< ::std::output_iterator_tag, void, void, void, void>
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef ::std::basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef ::std::basic_ostream<_CharT, _Traits> ostream_type;
    private:
      typename ::std::ostreambuf_iterator<_CharT, _Traits>::streambuf_type *_M_sbuf;
      bool _M_failed;
    public:
      inline ostreambuf_iterator(typename ::std::ostreambuf_iterator<_CharT, _Traits>::ostream_type &__s) throw()
        : _M_sbuf(__s.rdbuf()), _M_failed(!::std::ostreambuf_iterator<_CharT, _Traits>::_M_sbuf)
      {
      }
      inline ostreambuf_iterator(typename ::std::ostreambuf_iterator<_CharT, _Traits>::streambuf_type *__s) throw()
        : _M_sbuf(__s), _M_failed(!::std::ostreambuf_iterator<_CharT, _Traits>::_M_sbuf)
      {
      }
      inline ::std::ostreambuf_iterator<_CharT, _Traits> &operator =(_CharT __c)
      {
        if (!::std::ostreambuf_iterator<_CharT, _Traits>::_M_failed && _Traits::eq_int_type(::std::ostreambuf_iterator<_CharT, _Traits>::_M_sbuf->sputc(__c), _Traits::eof()))
          {
            ::std::ostreambuf_iterator<_CharT, _Traits>::_M_failed = true;
          }
        return *this;
      }
      inline ::std::ostreambuf_iterator<_CharT, _Traits> &operator *()
      {
        return *this;
      }
      inline ::std::ostreambuf_iterator<_CharT, _Traits> &operator ++(int)
      {
        return *this;
      }
      inline ::std::ostreambuf_iterator<_CharT, _Traits> &operator ++()
      {
        return *this;
      }
      inline bool failed() const  throw()
      {
        return ::std::ostreambuf_iterator<_CharT, _Traits>::_M_failed;
      }
      inline ::std::ostreambuf_iterator<_CharT, _Traits> &_M_put(const _CharT *__ws, ::std::streamsize __len)
      {
        if (__builtin_expect(!::std::ostreambuf_iterator<_CharT, _Traits>::_M_failed, true) && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len, false))
          {
            ::std::ostreambuf_iterator<_CharT, _Traits>::_M_failed = true;
          }
        return *this;
      }
    template < typename _CharT2 >
    friend typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ::std::ostreambuf_iterator<_CharT2> >::__type copy(::std::istreambuf_iterator<_CharT2>, ::std::istreambuf_iterator<_CharT2>, ::std::ostreambuf_iterator<_CharT2>);
  };
  template < typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::ostreambuf_iterator<_CharT> >::__type copy(::std::istreambuf_iterator<_CharT> __first, ::std::istreambuf_iterator<_CharT> __last, ::std::ostreambuf_iterator<_CharT> __result);
  template < typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::ostreambuf_iterator<_CharT> >::__type copy(::std::istreambuf_iterator<_CharT> __first, ::std::istreambuf_iterator<_CharT> __last, ::std::ostreambuf_iterator<_CharT> __result)
  {
    if ((__first._M_sbuf && !__last._M_sbuf) && !__result._M_failed)
      {
        bool __ineof;
        __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
        if (!__ineof)
          {
            __result._M_failed = true;
          }
      }
    return __result;
  }
  template < bool _IsMove, typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >::__type __copy_move_a2(_CharT *__first, _CharT *__last, ::std::ostreambuf_iterator<_CharT> __result)
  {
    const ::std::streamsize __num = __last - __first;
    if (__num > 0)
      {
        __result._M_put(__first, __num);
      }
    return __result;
  }
  template < bool _IsMove, typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >::__type __copy_move_a2(const _CharT *__first, const _CharT *__last, ::std::ostreambuf_iterator<_CharT> __result)
  {
    const ::std::streamsize __num = __last - __first;
    if (__num > 0)
      {
        __result._M_put(__first, __num);
      }
    return __result;
  }
  template < bool _IsMove, typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_move_a2(::std::istreambuf_iterator<_CharT> __first, ::std::istreambuf_iterator<_CharT> __last, _CharT *__result)
  {
    typedef ::std::istreambuf_iterator<_CharT> __is_iterator_type;
    typedef typename ::std::istreambuf_iterator<_CharT>::traits_type traits_type;
    typedef typename ::std::istreambuf_iterator<_CharT>::streambuf_type streambuf_type;
    typedef typename ::std::istreambuf_iterator<_CharT>::traits_type::int_type int_type;
    if (__first._M_sbuf && !__last._M_sbuf)
      {
        streambuf_type *__sb = __first._M_sbuf;
        int_type __c = __sb->sgetc();
        while (!traits_type::eq_int_type(__c, traits_type::eof()))
          {
            const ::std::streamsize __n = __sb->egptr() - __sb->gptr();
            if (__n > 1)
              {
                traits_type::copy(__result, __sb->gptr(), __n);
                __sb->__safe_gbump(__n);
                __result += __n;
                __c = __sb->underflow();
              }
            else
              {
                *__result++ = traits_type::to_char_type(__c);
                __c = __sb->snextc();
              }
          }
      }
    return __result;
  }
  template < typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::istreambuf_iterator<_CharT> >::__type find(::std::istreambuf_iterator<_CharT> __first, ::std::istreambuf_iterator<_CharT> __last, const _CharT &__val);
  template < typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::istreambuf_iterator<_CharT> >::__type find(::std::istreambuf_iterator<_CharT> __first, ::std::istreambuf_iterator<_CharT> __last, const _CharT &__val)
  {
    typedef ::std::istreambuf_iterator<_CharT> __is_iterator_type;
    typedef typename ::std::istreambuf_iterator<_CharT>::traits_type traits_type;
    typedef typename ::std::istreambuf_iterator<_CharT>::streambuf_type streambuf_type;
    typedef typename ::std::istreambuf_iterator<_CharT>::traits_type::int_type int_type;
    if (__first._M_sbuf && !__last._M_sbuf)
      {
        const int_type __ival = traits_type::to_int_type(__val);
        streambuf_type *__sb = __first._M_sbuf;
        int_type __c = __sb->sgetc();
        while (!traits_type::eq_int_type(__c, traits_type::eof()) && !traits_type::eq_int_type(__c, __ival))
          {
            ::std::streamsize __n = __sb->egptr() - __sb->gptr();
            if (__n > 1)
              {
                const _CharT *__p = traits_type::find(__sb->gptr(), __n, __val);
                if (__p)
                  {
                    __n = __p - __sb->gptr();
                  }
                __sb->__safe_gbump(__n);
                __c = __sb->sgetc();
              }
            else
              {
                __c = __sb->snextc();
              }
          }
        if (!traits_type::eq_int_type(__c, traits_type::eof()))
          {
            __first._M_c = __c;
          }
        else
          {
            __first._M_sbuf = 0;
          }
      }
    return __first;
  }
  template < typename _Tp >
  void __convert_to_v(const char *, _Tp &, ::std::ios_base::iostate &, const ::std::__c_locale &) throw();
  template <>
  void __convert_to_v<float>(const char *, float &, ::std::_Ios_Iostate &, ::__locale_struct *const &) throw();
  template <>
  void __convert_to_v<double>(const char *, double &, ::std::_Ios_Iostate &, ::__locale_struct *const &) throw();
  template <>
  void __convert_to_v<long double>(const char *, long double &, ::std::_Ios_Iostate &, ::__locale_struct *const &) throw();
  template < typename _CharT, typename _Traits >
  struct  __pad
  {
      static void _S_pad(::std::ios_base &__io, _CharT __fill, _CharT *__news, const _CharT *__olds, ::std::streamsize __newlen, ::std::streamsize __oldlen);
  };
  template < typename _CharT >
  _CharT *__add_grouping(_CharT *__s, _CharT __sep, const char *__gbeg, ::std::size_t __gsize, const _CharT *__first, const _CharT *__last);
  template < typename _CharT >
  inline ::std::ostreambuf_iterator<_CharT> __write(::std::ostreambuf_iterator<_CharT> __s, const _CharT *__ws, int __len);
  template < typename _CharT >
  inline ::std::ostreambuf_iterator<_CharT> __write(::std::ostreambuf_iterator<_CharT> __s, const _CharT *__ws, int __len)
  {
    __s._M_put(__ws, __len);
    return __s;
  }
  template < typename _CharT, typename _OutIter >
  inline _OutIter __write(_OutIter __s, const _CharT *__ws, int __len);
  template < typename _CharT, typename _OutIter >
  inline _OutIter __write(_OutIter __s, const _CharT *__ws, int __len)
  {
    for (int __j(0); __j < __len; (__j++,  ++__s))
      {
        *__s = __ws[__j];
      }
    return __s;
  }
  template < typename _CharT >
  class  __ctype_abstract_base : public ::std::locale::facet, public ::std::ctype_base
  {
    public:
      typedef _CharT char_type;
      inline bool is(::std::ctype_base::mask __m, typename ::std::__ctype_abstract_base<_CharT>::char_type __c) const 
      {
        return this->do_is(__m, __c);
      }
      inline const typename ::std::__ctype_abstract_base<_CharT>::char_type *is(const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi, ::std::ctype_base::mask *__vec) const 
      {
        return this->do_is(__lo, __hi, __vec);
      }
      inline const typename ::std::__ctype_abstract_base<_CharT>::char_type *scan_is(::std::ctype_base::mask __m, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const 
      {
        return this->do_scan_is(__m, __lo, __hi);
      }
      inline const typename ::std::__ctype_abstract_base<_CharT>::char_type *scan_not(::std::ctype_base::mask __m, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const 
      {
        return this->do_scan_not(__m, __lo, __hi);
      }
      inline typename ::std::__ctype_abstract_base<_CharT>::char_type toupper(typename ::std::__ctype_abstract_base<_CharT>::char_type __c) const 
      {
        return this->do_toupper(__c);
      }
      inline const typename ::std::__ctype_abstract_base<_CharT>::char_type *toupper(typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const 
      {
        return this->do_toupper(__lo, __hi);
      }
      inline typename ::std::__ctype_abstract_base<_CharT>::char_type tolower(typename ::std::__ctype_abstract_base<_CharT>::char_type __c) const 
      {
        return this->do_tolower(__c);
      }
      inline const typename ::std::__ctype_abstract_base<_CharT>::char_type *tolower(typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const 
      {
        return this->do_tolower(__lo, __hi);
      }
      inline typename ::std::__ctype_abstract_base<_CharT>::char_type widen(char __c) const 
      {
        return this->do_widen(__c);
      }
      inline const char *widen(const char *__lo, const char *__hi, typename ::std::__ctype_abstract_base<_CharT>::char_type *__to) const 
      {
        return this->do_widen(__lo, __hi, __to);
      }
      inline char narrow(typename ::std::__ctype_abstract_base<_CharT>::char_type __c, char __dfault) const 
      {
        return this->do_narrow(__c, __dfault);
      }
      inline const typename ::std::__ctype_abstract_base<_CharT>::char_type *narrow(const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi, char __dfault, char *__to) const 
      {
        return this->do_narrow(__lo, __hi, __dfault, __to);
      }
    protected:
      inline explicit __ctype_abstract_base(::std::size_t __refs  = (0))
        : facet(__refs)
      {
      }
      inline virtual ~__ctype_abstract_base()
      {
      }
      virtual bool do_is(::std::ctype_base::mask __m, typename ::std::__ctype_abstract_base<_CharT>::char_type __c) const  = 0 ;
      virtual const typename ::std::__ctype_abstract_base<_CharT>::char_type *do_is(const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi, ::std::ctype_base::mask *__vec) const  = 0 ;
      virtual const typename ::std::__ctype_abstract_base<_CharT>::char_type *do_scan_is(::std::ctype_base::mask __m, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const  = 0 ;
      virtual const typename ::std::__ctype_abstract_base<_CharT>::char_type *do_scan_not(::std::ctype_base::mask __m, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const  = 0 ;
      virtual typename ::std::__ctype_abstract_base<_CharT>::char_type do_toupper(typename ::std::__ctype_abstract_base<_CharT>::char_type __c) const  = 0 ;
      virtual const typename ::std::__ctype_abstract_base<_CharT>::char_type *do_toupper(typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const  = 0 ;
      virtual typename ::std::__ctype_abstract_base<_CharT>::char_type do_tolower(typename ::std::__ctype_abstract_base<_CharT>::char_type __c) const  = 0 ;
      virtual const typename ::std::__ctype_abstract_base<_CharT>::char_type *do_tolower(typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const  = 0 ;
      virtual typename ::std::__ctype_abstract_base<_CharT>::char_type do_widen(char __c) const  = 0 ;
      virtual const char *do_widen(const char *__lo, const char *__hi, typename ::std::__ctype_abstract_base<_CharT>::char_type *__to) const  = 0 ;
      virtual char do_narrow(typename ::std::__ctype_abstract_base<_CharT>::char_type __c, char __dfault) const  = 0 ;
      virtual const typename ::std::__ctype_abstract_base<_CharT>::char_type *do_narrow(const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi, char __dfault, char *__to) const  = 0 ;
  };
  template < typename _CharT >
  class  ctype : public ::std::__ctype_abstract_base<_CharT>
  {
    public:
      typedef _CharT char_type;
      typedef typename ::std::__ctype_abstract_base<_CharT>::mask mask;
      static ::std::locale::id id;
      inline explicit ctype(::std::size_t __refs  = (0))
        : __ctype_abstract_base<_CharT>(__refs)
      {
      }
    protected:
      virtual ~ctype();
      virtual bool do_is(typename ::std::ctype<_CharT>::mask __m, typename ::std::ctype<_CharT>::char_type __c) const ;
      virtual const typename ::std::ctype<_CharT>::char_type *do_is(const typename ::std::ctype<_CharT>::char_type *__lo, const typename ::std::ctype<_CharT>::char_type *__hi, typename ::std::ctype<_CharT>::mask *__vec) const ;
      virtual const typename ::std::ctype<_CharT>::char_type *do_scan_is(typename ::std::ctype<_CharT>::mask __m, const typename ::std::ctype<_CharT>::char_type *__lo, const typename ::std::ctype<_CharT>::char_type *__hi) const ;
      virtual const typename ::std::ctype<_CharT>::char_type *do_scan_not(typename ::std::ctype<_CharT>::mask __m, const typename ::std::ctype<_CharT>::char_type *__lo, const typename ::std::ctype<_CharT>::char_type *__hi) const ;
      virtual typename ::std::ctype<_CharT>::char_type do_toupper(typename ::std::ctype<_CharT>::char_type __c) const ;
      virtual const typename ::std::ctype<_CharT>::char_type *do_toupper(typename ::std::ctype<_CharT>::char_type *__lo, const typename ::std::ctype<_CharT>::char_type *__hi) const ;
      virtual typename ::std::ctype<_CharT>::char_type do_tolower(typename ::std::ctype<_CharT>::char_type __c) const ;
      virtual const typename ::std::ctype<_CharT>::char_type *do_tolower(typename ::std::ctype<_CharT>::char_type *__lo, const typename ::std::ctype<_CharT>::char_type *__hi) const ;
      virtual typename ::std::ctype<_CharT>::char_type do_widen(char __c) const ;
      virtual const char *do_widen(const char *__lo, const char *__hi, typename ::std::ctype<_CharT>::char_type *__dest) const ;
      virtual char do_narrow(typename ::std::ctype<_CharT>::char_type, char __dfault) const ;
      virtual const typename ::std::ctype<_CharT>::char_type *do_narrow(const typename ::std::ctype<_CharT>::char_type *__lo, const typename ::std::ctype<_CharT>::char_type *__hi, char __dfault, char *__to) const ;
  };
  template < typename _CharT >
  ::std::locale::id ctype<_CharT>::id;
  template <>
  class  ctype<char> : public ::std::locale::facet, public ::std::ctype_base
  {
    public:
      typedef char char_type;
    protected:
      ::std::__c_locale _M_c_locale_ctype;
      bool _M_del;
      ::std::ctype_base::__to_type _M_toupper;
      ::std::ctype_base::__to_type _M_tolower;
      const ::std::ctype_base::mask *_M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[256L];
      mutable char _M_narrow[256L];
      mutable char _M_narrow_ok;
    public:
      static ::std::locale::id id;
      static const ::std::size_t table_size = 1 + static_cast<unsigned char>( -1);
      explicit ctype(const ::std::ctype_base::mask *__table  = (0), bool __del  = (false), ::std::size_t __refs  = (0));
      explicit ctype(::std::__c_locale __cloc, const ::std::ctype_base::mask *__table  = (0), bool __del  = (false), ::std::size_t __refs  = (0));
      inline bool is(::std::ctype_base::mask __m, char __c) const ;
      inline const char *is(const char *__low, const char *__high, ::std::ctype_base::mask *__vec) const ;
      inline const char *scan_is(::std::ctype_base::mask __m, const char *__low, const char *__high) const ;
      inline const char *scan_not(::std::ctype_base::mask __m, const char *__low, const char *__high) const ;
      inline ::std::ctype<char>::char_type toupper(::std::ctype<char>::char_type __c) const 
      {
        return (*this).do_toupper(__c);
      }
      inline const ::std::ctype<char>::char_type *toupper(::std::ctype<char>::char_type *__lo, const ::std::ctype<char>::char_type *__hi) const 
      {
        return (*this).do_toupper(__lo, __hi);
      }
      inline ::std::ctype<char>::char_type tolower(::std::ctype<char>::char_type __c) const 
      {
        return (*this).do_tolower(__c);
      }
      inline const ::std::ctype<char>::char_type *tolower(::std::ctype<char>::char_type *__lo, const ::std::ctype<char>::char_type *__hi) const 
      {
        return (*this).do_tolower(__lo, __hi);
      }
      inline ::std::ctype<char>::char_type widen(char __c) const 
      {
        if ((*this)._M_widen_ok)
          {
            return (*this)._M_widen[static_cast<unsigned char>(__c)];
          }
        (*this).::std::ctype<char>::_M_widen_init();
        return (*this).do_widen(__c);
      }
      inline const char *widen(const char *__lo, const char *__hi, ::std::ctype<char>::char_type *__to) const 
      {
        if ((*this)._M_widen_ok == 1)
          {
            __builtin_memcpy(__to, __lo, __hi - __lo);
            return __hi;
          }
        if (!(*this)._M_widen_ok)
          {
            (*this).::std::ctype<char>::_M_widen_init();
          }
        return (*this).do_widen(__lo, __hi, __to);
      }
      inline char narrow(::std::ctype<char>::char_type __c, char __dfault) const 
      {
        if ((*this)._M_narrow[static_cast<unsigned char>(__c)])
          {
            return (*this)._M_narrow[static_cast<unsigned char>(__c)];
          }
        const char __t((*this).do_narrow(__c, __dfault));
        if (__t != __dfault)
          {
            (*this)._M_narrow[static_cast<unsigned char>(__c)] = __t;
          }
        return __t;
      }
      inline const ::std::ctype<char>::char_type *narrow(const ::std::ctype<char>::char_type *__lo, const ::std::ctype<char>::char_type *__hi, char __dfault, char *__to) const 
      {
        if (__builtin_expect((*this)._M_narrow_ok == 1, true))
          {
            __builtin_memcpy(__to, __lo, __hi - __lo);
            return __hi;
          }
        if (!(*this)._M_narrow_ok)
          {
            (*this).::std::ctype<char>::_M_narrow_init();
          }
        return (*this).do_narrow(__lo, __hi, __dfault, __to);
      }
      inline const ::std::ctype_base::mask *table() const  throw()
      {
        return (*this)._M_table;
      }
      static const ::std::ctype_base::mask *classic_table() throw();
    protected:
      virtual ~ctype();
      virtual ::std::ctype<char>::char_type do_toupper(::std::ctype<char>::char_type __c) const ;
      virtual const ::std::ctype<char>::char_type *do_toupper(::std::ctype<char>::char_type *__lo, const ::std::ctype<char>::char_type *__hi) const ;
      virtual ::std::ctype<char>::char_type do_tolower(::std::ctype<char>::char_type __c) const ;
      virtual const ::std::ctype<char>::char_type *do_tolower(::std::ctype<char>::char_type *__lo, const ::std::ctype<char>::char_type *__hi) const ;
      virtual inline ::std::ctype<char>::char_type do_widen(char __c) const 
      {
        return __c;
      }
      virtual inline const char *do_widen(const char *__lo, const char *__hi, ::std::ctype<char>::char_type *__to) const 
      {
        __builtin_memcpy(__to, __lo, __hi - __lo);
        return __hi;
      }
      virtual inline char do_narrow(::std::ctype<char>::char_type __c, char __dfault __attribute__((__unused__))) const 
      {
        return __c;
      }
      virtual inline const ::std::ctype<char>::char_type *do_narrow(const ::std::ctype<char>::char_type *__lo, const ::std::ctype<char>::char_type *__hi, char __dfault __attribute__((__unused__)), char *__to) const 
      {
        __builtin_memcpy(__to, __lo, __hi - __lo);
        return __hi;
      }
    private:
      void _M_narrow_init() const ;
      void _M_widen_init() const ;
    public:
  };
 /* Instantiation of class template '::std::__ctype_abstract_base<wchar_t>' */ 
  template <>
  class  ctype<wchar_t> : public ::std::__ctype_abstract_base<wchar_t>
  {
    public:
      typedef wchar_t char_type;
      typedef ::wctype_t __wmask_type;
    protected:
      ::std::__c_locale _M_c_locale_ctype;
      bool _M_narrow_ok;
      char _M_narrow[128L];
      ::wint_t _M_widen[256L];
      ::std::ctype_base::mask _M_bit[16L];
      ::std::ctype<wchar_t>::__wmask_type _M_wmask[16L];
    public:
      static ::std::locale::id id;
      explicit ctype(::std::size_t __refs  = (0));
      explicit ctype(::std::__c_locale __cloc, ::std::size_t __refs  = (0));
    protected:
      ::std::ctype<wchar_t>::__wmask_type _M_convert_to_wmask(const ::std::ctype_base::mask __m) const  throw();
      virtual ~ctype();
      virtual bool do_is(::std::ctype_base::mask __m, ::std::ctype<wchar_t>::char_type __c) const ;
      virtual const ::std::ctype<wchar_t>::char_type *do_is(const ::std::ctype<wchar_t>::char_type *__lo, const ::std::ctype<wchar_t>::char_type *__hi, ::std::ctype_base::mask *__vec) const ;
      virtual const ::std::ctype<wchar_t>::char_type *do_scan_is(::std::ctype_base::mask __m, const ::std::ctype<wchar_t>::char_type *__lo, const ::std::ctype<wchar_t>::char_type *__hi) const ;
      virtual const ::std::ctype<wchar_t>::char_type *do_scan_not(::std::ctype_base::mask __m, const ::std::ctype<wchar_t>::char_type *__lo, const ::std::ctype<wchar_t>::char_type *__hi) const ;
      virtual ::std::ctype<wchar_t>::char_type do_toupper(::std::ctype<wchar_t>::char_type __c) const ;
      virtual const ::std::ctype<wchar_t>::char_type *do_toupper(::std::ctype<wchar_t>::char_type *__lo, const ::std::ctype<wchar_t>::char_type *__hi) const ;
      virtual ::std::ctype<wchar_t>::char_type do_tolower(::std::ctype<wchar_t>::char_type __c) const ;
      virtual const ::std::ctype<wchar_t>::char_type *do_tolower(::std::ctype<wchar_t>::char_type *__lo, const ::std::ctype<wchar_t>::char_type *__hi) const ;
      virtual ::std::ctype<wchar_t>::char_type do_widen(char __c) const ;
      virtual const char *do_widen(const char *__lo, const char *__hi, ::std::ctype<wchar_t>::char_type *__to) const ;
      virtual char do_narrow(::std::ctype<wchar_t>::char_type __c, char __dfault) const ;
      virtual const ::std::ctype<wchar_t>::char_type *do_narrow(const ::std::ctype<wchar_t>::char_type *__lo, const ::std::ctype<wchar_t>::char_type *__hi, char __dfault, char *__to) const ;
      void _M_initialize_ctype() throw();
    public:
  };
  template < typename _CharT >
  class  ctype_byname : public ::std::ctype<_CharT>
  {
    public:
      typedef typename ::std::ctype<_CharT>::mask mask;
      explicit ctype_byname(const char *__s, ::std::size_t __refs  = (0));
    protected:
      inline virtual ~ctype_byname()
      {
      }
  };
  template <>
  class  ctype_byname<char> : public ::std::ctype<char>
  {
    public:
      explicit ctype_byname(const char *__s, ::std::size_t __refs  = (0));
    protected:
      virtual ~ctype_byname();
    public:
  };
  template <>
  class  ctype_byname<wchar_t> : public ::std::ctype<wchar_t>
  {
    public:
      explicit ctype_byname(const char *__s, ::std::size_t __refs  = (0));
    protected:
      virtual ~ctype_byname();
    public:
  };
  inline bool ctype<char>::is(::std::ctype_base::mask __m, char __c) const 
  {
    return (*this)._M_table[static_cast<unsigned char>(__c)] & __m;
  }
  inline const char *ctype<char>::is(const char *__low, const char *__high, ::std::ctype_base::mask *__vec) const 
  {
    while (__low < __high)
      {
        *__vec++ = (*this)._M_table[static_cast<unsigned char>(*__low++)];
      }
    return __high;
  }
  inline const char *ctype<char>::scan_is(::std::ctype_base::mask __m, const char *__low, const char *__high) const 
  {
    while (__low < __high && !((*this)._M_table[static_cast<unsigned char>(*__low)] & __m))
      {
         ++__low;
      }
    return __low;
  }
  inline const char *ctype<char>::scan_not(::std::ctype_base::mask __m, const char *__low, const char *__high) const 
  {
    while (__low < __high && ((*this)._M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      {
         ++__low;
      }
    return __low;
  }
  class  __num_base
  {
    public:
      enum mcc_enum_anon_69
      {
        _S_ominus = 0,
        _S_oplus = 1,
        _S_ox = 2,
        _S_oX = 3,
        _S_odigits = 4,
        _S_odigits_end = ::std::__num_base::_S_odigits + 16,
        _S_oudigits = ::std::__num_base::_S_odigits_end,
        _S_oudigits_end = ::std::__num_base::_S_oudigits + 16,
        _S_oe = ::std::__num_base::_S_odigits + 14,
        _S_oE = ::std::__num_base::_S_oudigits + 14,
        _S_oend = ::std::__num_base::_S_oudigits_end
      };
      static const char *_S_atoms_out;
      static const char *_S_atoms_in;
      enum mcc_enum_anon_70
      {
        _S_iminus = 0,
        _S_iplus = 1,
        _S_ix = 2,
        _S_iX = 3,
        _S_izero = 4,
        _S_ie = ::std::__num_base::_S_izero + 14,
        _S_iE = ::std::__num_base::_S_izero + 20,
        _S_iend = 26
      };
      static void _S_format_float(const ::std::ios_base &__io, char *__fptr, char __mod) throw();
  };
  template < typename _CharT >
  struct  __numpunct_cache : ::std::locale::facet
  {
      const char *_M_grouping;
      ::std::size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT *_M_truename;
      ::std::size_t _M_truename_size;
      const _CharT *_M_falsename;
      ::std::size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      _CharT _M_atoms_out[36L];
      _CharT _M_atoms_in[26L];
      bool _M_allocated;
      inline __numpunct_cache(::std::size_t __refs  = (0))
        : facet(__refs), _M_grouping(0), _M_grouping_size(0), _M_use_grouping(false), _M_truename(0), _M_truename_size(0), _M_falsename(0), _M_falsename_size(0), _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()), _M_allocated(false)
      {
      }
      virtual ~__numpunct_cache();
      void _M_cache(const ::std::locale &__loc);
    private:
      ::std::__numpunct_cache<_CharT> &operator =(const ::std::__numpunct_cache<_CharT> &);
      explicit __numpunct_cache(const ::std::__numpunct_cache<_CharT> &);
  };
  template < typename _CharT >
  __numpunct_cache<_CharT>::~__numpunct_cache()
  {
    if (::std::__numpunct_cache<_CharT>::_M_allocated)
      {
        delete[] ::std::__numpunct_cache<_CharT>::_M_grouping;
        delete[] ::std::__numpunct_cache<_CharT>::_M_truename;
        delete[] ::std::__numpunct_cache<_CharT>::_M_falsename;
      }
  }
 /* Instantiation of class template '::__gnu_cxx::new_allocator<char>' */ 
 /* Instantiation of class template '::std::allocator<char>' */ 
 /* Instantiation of class template '::__gnu_cxx::__alloc_traits< ::std::allocator<char> >' */ 
 /* Instantiation of class template '::std::allocator<char>::rebind<char>' */ 
 /* Instantiation of class template '::__gnu_cxx::__alloc_traits< ::std::allocator<char> >::rebind<char>' */ 
 /* Instantiation of class template '::std::__cxx11::basic_string<char>::' */ 
 /* Instantiation of class template '::std::__cxx11::basic_string<char>::_Alloc_hider' */ 
 /* Instantiation of class template '::std::__cxx11::basic_string<char>' */ 
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    template < typename _CharT >
    class  numpunct : public ::std::locale::facet
    {
      public:
        typedef _CharT char_type;
        typedef ::std::__cxx11::basic_string<_CharT> string_type;
        typedef ::std::__numpunct_cache<_CharT> __cache_type;
      protected:
        typename ::std::__cxx11::numpunct<_CharT>::__cache_type *_M_data;
      public:
        static ::std::locale::id id;
        inline explicit numpunct(::std::size_t __refs  = (0))
          : facet(__refs), _M_data(0)
        {
          (*this)._M_initialize_numpunct();
        }
        inline explicit numpunct(typename ::std::__cxx11::numpunct<_CharT>::__cache_type *__cache, ::std::size_t __refs  = (0))
          : facet(__refs), _M_data(__cache)
        {
          (*this)._M_initialize_numpunct();
        }
        inline explicit numpunct(::std::__c_locale __cloc, ::std::size_t __refs  = (0))
          : facet(__refs), _M_data(0)
        {
          (*this)._M_initialize_numpunct(__cloc);
        }
        inline typename ::std::__cxx11::numpunct<_CharT>::char_type decimal_point() const 
        {
          return this->do_decimal_point();
        }
        inline typename ::std::__cxx11::numpunct<_CharT>::char_type thousands_sep() const 
        {
          return this->do_thousands_sep();
        }
        inline ::std::__cxx11::string grouping() const 
        {
          return this->do_grouping();
        }
        inline typename ::std::__cxx11::numpunct<_CharT>::string_type truename() const 
        {
          return this->do_truename();
        }
        inline typename ::std::__cxx11::numpunct<_CharT>::string_type falsename() const 
        {
          return this->do_falsename();
        }
      protected:
        virtual ~numpunct();
        inline virtual typename ::std::__cxx11::numpunct<_CharT>::char_type do_decimal_point() const 
        {
          return ::std::__cxx11::numpunct<_CharT>::_M_data->_M_decimal_point;
        }
        inline virtual typename ::std::__cxx11::numpunct<_CharT>::char_type do_thousands_sep() const 
        {
          return ::std::__cxx11::numpunct<_CharT>::_M_data->_M_thousands_sep;
        }
        inline virtual ::std::__cxx11::string do_grouping() const 
        {
          return ::std::__cxx11::numpunct<_CharT>::_M_data->_M_grouping;
        }
        inline virtual typename ::std::__cxx11::numpunct<_CharT>::string_type do_truename() const 
        {
          return ::std::__cxx11::numpunct<_CharT>::_M_data->_M_truename;
        }
        inline virtual typename ::std::__cxx11::numpunct<_CharT>::string_type do_falsename() const 
        {
          return ::std::__cxx11::numpunct<_CharT>::_M_data->_M_falsename;
        }
        void _M_initialize_numpunct(::std::__c_locale __cloc  = (0));
    };
    template < typename _CharT >
    ::std::locale::id numpunct<_CharT>::id;
 /* Instantiation of class template '::std::__cxx11::numpunct<char>' */ 
    template <>
    numpunct<char>::~numpunct();
    template <>
    void numpunct<char>::_M_initialize_numpunct(::__locale_struct *__cloc);
 /* Instantiation of class template '::std::__cxx11::numpunct<wchar_t>' */ 
    template <>
    numpunct<wchar_t>::~numpunct();
    template <>
    void numpunct<wchar_t>::_M_initialize_numpunct(::__locale_struct *__cloc);
    template < typename _CharT >
    class  numpunct_byname : public ::std::__cxx11::numpunct<_CharT>
    {
      public:
        typedef _CharT char_type;
        typedef ::std::__cxx11::basic_string<_CharT> string_type;
        inline explicit numpunct_byname(const char *__s, ::std::size_t __refs  = (0))
          : numpunct<_CharT>(__refs)
        {
          if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0)
            {
              ::std::__c_locale __tmp;
              this->_S_create_c_locale(__tmp, __s);
              this->_M_initialize_numpunct(__tmp);
              this->_S_destroy_c_locale(__tmp);
            }
        }
      protected:
        inline virtual ~numpunct_byname()
        {
        }
    };
  }
  template < typename _CharT, typename _InIter >
  class  num_get : public ::std::locale::facet
  {
    public:
      typedef _CharT char_type;
      typedef _InIter iter_type;
      static ::std::locale::id id;
      inline explicit num_get(::std::size_t __refs  = (0))
        : facet(__refs)
      {
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, bool &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long int &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned short int &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned int &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned long int &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long long int &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned long long int &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, float &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, double &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long double &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, void *&__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
    protected:
      inline virtual ~num_get()
      {
      }
      typename ::std::num_get<_CharT, _InIter>::iter_type _M_extract_float(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::std::__cxx11::string &__xtrc) const  __attribute__((__abi_tag__("cxx11")));
      template < typename _ValueT >
      typename ::std::num_get<_CharT, _InIter>::iter_type _M_extract_int(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, _ValueT &__v) const  __attribute__((__abi_tag__("cxx11")));
      template < typename _CharT2 >
      inline typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, ::std::size_t __len, _CharT2 __c) const 
      {
        int __ret( -1);
        if (__len <= 10)
          {
            if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
              {
                __ret = __c - _CharT2('0');
              }
          }
        else
          {
            if (__c >= _CharT2('0') && __c <= _CharT2('9'))
              {
                __ret = __c - _CharT2('0');
              }
            else
              {
                if (__c >= _CharT2('a') && __c <= _CharT2('f'))
                  {
                    __ret = 10 + (__c - _CharT2('a'));
                  }
                else
                  {
                    if (__c >= _CharT2('A') && __c <= _CharT2('F'))
                      {
                        __ret = 10 + (__c - _CharT2('A'));
                      }
                  }
              }
          }
        return __ret;
      }
      template < typename _CharT2 >
      inline typename ::__gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, ::std::size_t __len, _CharT2 __c) const 
      {
        int __ret( -1);
        const typename ::std::num_get<_CharT, _InIter>::char_type *__q = char_traits<_CharT2>::find(__zero, __len, __c);
        if (__q)
          {
            __ret = __q - __zero;
            if (__ret > 15)
              {
                __ret -= 6;
              }
          }
        return __ret;
      }
      virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, bool &__v) const ;
      inline virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long int &__v) const 
      {
        return (*this)._M_extract_int(__beg, __end, __io, __err, __v);
      }
      inline virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned short int &__v) const 
      {
        return (*this)._M_extract_int(__beg, __end, __io, __err, __v);
      }
      inline virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned int &__v) const 
      {
        return (*this)._M_extract_int(__beg, __end, __io, __err, __v);
      }
      inline virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned long int &__v) const 
      {
        return (*this)._M_extract_int(__beg, __end, __io, __err, __v);
      }
      inline virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long long int &__v) const 
      {
        return (*this)._M_extract_int(__beg, __end, __io, __err, __v);
      }
      inline virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned long long int &__v) const 
      {
        return (*this)._M_extract_int(__beg, __end, __io, __err, __v);
      }
      virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, float &__v) const ;
      virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, double &__v) const ;
      virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long double &__v) const ;
      virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, void *&__v) const ;
  };
  template < typename _CharT, typename _InIter >
  ::std::locale::id num_get<_CharT, _InIter>::id;
  template < typename _CharT, typename _OutIter >
  class  num_put : public ::std::locale::facet
  {
    public:
      typedef _CharT char_type;
      typedef _OutIter iter_type;
      static ::std::locale::id id;
      inline explicit num_put(::std::size_t __refs  = (0))
        : facet(__refs)
      {
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, bool __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long int __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, unsigned long int __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long long int __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, unsigned long long int __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, double __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long double __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, const void *__v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
    protected:
      template < typename _ValueT >
      typename ::std::num_put<_CharT, _OutIter>::iter_type _M_insert_float(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, char __mod, _ValueT __v) const ;
      void _M_group_float(const char *__grouping, ::std::size_t __grouping_size, typename ::std::num_put<_CharT, _OutIter>::char_type __sep, const typename ::std::num_put<_CharT, _OutIter>::char_type *__p, typename ::std::num_put<_CharT, _OutIter>::char_type *__new, typename ::std::num_put<_CharT, _OutIter>::char_type *__cs, int &__len) const ;
      template < typename _ValueT >
      typename ::std::num_put<_CharT, _OutIter>::iter_type _M_insert_int(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, _ValueT __v) const ;
      void _M_group_int(const char *__grouping, ::std::size_t __grouping_size, typename ::std::num_put<_CharT, _OutIter>::char_type __sep, ::std::ios_base &, typename ::std::num_put<_CharT, _OutIter>::char_type *__new, typename ::std::num_put<_CharT, _OutIter>::char_type *__cs, int &__len) const ;
      void _M_pad(typename ::std::num_put<_CharT, _OutIter>::char_type __fill, ::std::streamsize __w, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type *__new, const typename ::std::num_put<_CharT, _OutIter>::char_type *__cs, int &__len) const ;
      inline virtual ~num_put()
      {
      }
      virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, bool __v) const ;
      inline virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long int __v) const 
      {
        return (*this)._M_insert_int(__s, __io, __fill, __v);
      }
      inline virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, unsigned long int __v) const 
      {
        return (*this)._M_insert_int(__s, __io, __fill, __v);
      }
      inline virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long long int __v) const 
      {
        return (*this)._M_insert_int(__s, __io, __fill, __v);
      }
      inline virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, unsigned long long int __v) const 
      {
        return (*this)._M_insert_int(__s, __io, __fill, __v);
      }
      virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, double __v) const ;
      virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long double __v) const ;
      virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, const void *__v) const ;
  };
  template < typename _CharT, typename _OutIter >
  ::std::locale::id num_put<_CharT, _OutIter>::id;
  template < typename _CharT >
  inline bool isspace(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::space, __c);
  }
  template < typename _CharT >
  inline bool isprint(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::print, __c);
  }
  template < typename _CharT >
  inline bool iscntrl(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::cntrl, __c);
  }
  template < typename _CharT >
  inline bool isupper(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::upper, __c);
  }
  template < typename _CharT >
  inline bool islower(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::lower, __c);
  }
  template < typename _CharT >
  inline bool isalpha(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::alpha, __c);
  }
  template < typename _CharT >
  inline bool isdigit(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::digit, __c);
  }
  template < typename _CharT >
  inline bool ispunct(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::punct, __c);
  }
  template < typename _CharT >
  inline bool isxdigit(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::xdigit, __c);
  }
  template < typename _CharT >
  inline bool isalnum(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::alnum, __c);
  }
  template < typename _CharT >
  inline bool isgraph(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::graph, __c);
  }
  template < typename _CharT >
  inline _CharT toupper(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).toupper(__c);
  }
  template < typename _CharT >
  inline _CharT tolower(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).tolower(__c);
  }
  template < typename _Facet >
  struct  __use_cache
  {
      const _Facet *operator ()(const ::std::locale &__loc) const ;
  };
  template < typename _CharT >
  struct  __use_cache< ::std::__numpunct_cache<_CharT> >
  {
      inline const ::std::__numpunct_cache<_CharT> *operator ()(const ::std::locale &__loc) const 
      {
        const ::std::size_t __i = numpunct<_CharT>::id._M_id();
        const ::std::locale::facet **__caches((*__loc._M_impl)._M_caches);
        if (!__caches[__i])
          {
            ::std::__numpunct_cache<_CharT> *__tmp = 0;
            try
            {
              __tmp = (new ::std::__numpunct_cache<_CharT>());
              __tmp->_M_cache(__loc);
            }
            catch (...)
            {
              delete __tmp;
              throw;
            }
            (*__loc._M_impl)._M_install_cache(__tmp, __i);
          }
        return static_cast<const ::std::__numpunct_cache<_CharT> *>(__caches[__i]);
      }
  };
 /* Instantiation of class template '::__gnu_cxx::__conditional_type<true, ::__gnu_cxx::__numeric_traits_integer<char>, ::__gnu_cxx::__numeric_traits_floating<char> >' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits_integer<char>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits<char>' */ 
  template < typename _CharT >
  void __numpunct_cache<_CharT>::_M_cache(const ::std::locale &__loc)
  {
    const ::std::__cxx11::numpunct<_CharT> &__np = use_facet< ::std::__cxx11::numpunct<_CharT> >(__loc);
    char *__grouping(0);
    _CharT *__truename = 0;
    _CharT *__falsename = 0;
    try
    {
      const ::std::__cxx11::string &__g = __np.grouping();
      ::std::__numpunct_cache<_CharT>::_M_grouping_size = __g.::std::__cxx11::basic_string<char>::size();
      __grouping = (new char [::std::__numpunct_cache<_CharT>::_M_grouping_size]);
      __g.copy(__grouping, ::std::__numpunct_cache<_CharT>::_M_grouping_size);
      ::std::__numpunct_cache<_CharT>::_M_use_grouping = (::std::__numpunct_cache<_CharT>::_M_grouping_size && static_cast<signed char>(__grouping[0]) > 0) && __grouping[0] != ::__gnu_cxx::__numeric_traits_integer<char>::__max;
      const ::std::__cxx11::basic_string<_CharT> &__tn = __np.truename();
      ::std::__numpunct_cache<_CharT>::_M_truename_size = __tn.size();
      __truename = (new _CharT [::std::__numpunct_cache<_CharT>::_M_truename_size]);
      __tn.copy(__truename, ::std::__numpunct_cache<_CharT>::_M_truename_size);
      const ::std::__cxx11::basic_string<_CharT> &__fn = __np.falsename();
      ::std::__numpunct_cache<_CharT>::_M_falsename_size = __fn.size();
      __falsename = (new _CharT [::std::__numpunct_cache<_CharT>::_M_falsename_size]);
      __fn.copy(__falsename, ::std::__numpunct_cache<_CharT>::_M_falsename_size);
      ::std::__numpunct_cache<_CharT>::_M_decimal_point = __np.decimal_point();
      ::std::__numpunct_cache<_CharT>::_M_thousands_sep = __np.thousands_sep();
      const ::std::ctype<_CharT> &__ct = use_facet< ::std::ctype<_CharT> >(__loc);
      __ct.widen(::std::__num_base::_S_atoms_out, ::std::__num_base::_S_atoms_out + ::std::__num_base::_S_oend, ::std::__numpunct_cache<_CharT>::_M_atoms_out);
      __ct.widen(::std::__num_base::_S_atoms_in, ::std::__num_base::_S_atoms_in + ::std::__num_base::_S_iend, ::std::__numpunct_cache<_CharT>::_M_atoms_in);
      ::std::__numpunct_cache<_CharT>::_M_grouping = __grouping;
      ::std::__numpunct_cache<_CharT>::_M_truename = __truename;
      ::std::__numpunct_cache<_CharT>::_M_falsename = __falsename;
      ::std::__numpunct_cache<_CharT>::_M_allocated = true;
    }
    catch (...)
    {
      delete[] __grouping;
      delete[] __truename;
      delete[] __falsename;
      throw;
    }
  }
  bool __verify_grouping(const char *__grouping, ::std::size_t __grouping_size, const ::std::__cxx11::string &__grouping_tmp) throw() __attribute__((__pure__));
  template < typename _CharT, typename _InIter >
  __attribute__((__abi_tag__("cxx11"))) typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::_M_extract_float(_InIter __beg, _InIter __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::std::__cxx11::string &__xtrc) const 
  {
    typedef ::std::char_traits<_CharT> __traits_type;
    typedef ::std::__numpunct_cache<_CharT> __cache_type;
    ::std::__use_cache<__cache_type> __uc;
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const __cache_type *__lc = __uc(__loc);
    const _CharT *__lit = __lc->_M_atoms_in;
    typename ::std::num_get<_CharT, _InIter>::char_type __c = ((typename ::std::num_get<_CharT, _InIter>::char_type()));
    bool __testeof = __beg == __end;
    if (!__testeof)
      {
        __c = *__beg;
        const bool __plus = __c == __lit[::std::__num_base::_S_iplus];
        if (((__plus || __c == __lit[::std::__num_base::_S_iminus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)) && !(__c == __lc->_M_decimal_point))
          {
            __xtrc += __plus ? '+' : '-';
            if ( ++__beg != __end)
              {
                __c = *__beg;
              }
            else
              {
                __testeof = true;
              }
          }
      }
    bool __found_mantissa(false);
    int __sep_pos(0);
    while (!__testeof)
      {
        if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) || __c == __lc->_M_decimal_point)
          {
            break;
          }
        else
          {
            if (__c == __lit[::std::__num_base::_S_izero])
              {
                if (!__found_mantissa)
                  {
                    __xtrc += '0';
                    __found_mantissa = true;
                  }
                 ++__sep_pos;
                if ( ++__beg != __end)
                  {
                    __c = *__beg;
                  }
                else
                  {
                    __testeof = true;
                  }
              }
            else
              {
                break;
              }
          }
      }
    bool __found_dec(false);
    bool __found_sci(false);
    ::std::__cxx11::string __found_grouping /* () */ ;
    if (__lc->_M_use_grouping)
      {
        __found_grouping.::std::__cxx11::basic_string<char>::reserve(32);
      }
    const typename ::std::num_get<_CharT, _InIter>::char_type *__lit_zero = __lit + ::std::__num_base::_S_izero;
    if (!__lc->_M_allocated)
      {
        while (!__testeof)
          {
            const int __digit = (*this)._M_find(__lit_zero, 10, __c);
            if (__digit !=  -1)
              {
                __xtrc += '0' + __digit;
                __found_mantissa = true;
              }
            else
              {
                if ((__c == __lc->_M_decimal_point && !__found_dec) && !__found_sci)
                  {
                    __xtrc += '.';
                    __found_dec = true;
                  }
                else
                  {
                    if (((__c == __lit[::std::__num_base::_S_ie] || __c == __lit[::std::__num_base::_S_iE]) && !__found_sci) && __found_mantissa)
                      {
                        __xtrc += 'e';
                        __found_sci = true;
                        if ( ++__beg != __end)
                          {
                            __c = *__beg;
                            const bool __plus = __c == __lit[::std::__num_base::_S_iplus];
                            if (__plus || __c == __lit[::std::__num_base::_S_iminus])
                              {
                                __xtrc += __plus ? '+' : '-';
                              }
                            else
                              {
                                continue;
                              }
                          }
                        else
                          {
                            __testeof = true;
                            break;
                          }
                      }
                    else
                      {
                        break;
                      }
                  }
              }
            if ( ++__beg != __end)
              {
                __c = *__beg;
              }
            else
              {
                __testeof = true;
              }
          }
      }
    else
      {
        while (!__testeof)
          {
            if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
              {
                if (!__found_dec && !__found_sci)
                  {
                    if (__sep_pos)
                      {
                        __found_grouping += static_cast<char>(__sep_pos);
                        __sep_pos = 0;
                      }
                    else
                      {
                        __xtrc.::std::__cxx11::basic_string<char>::clear();
                        break;
                      }
                  }
                else
                  {
                    break;
                  }
              }
            else
              {
                if (__c == __lc->_M_decimal_point)
                  {
                    if (!__found_dec && !__found_sci)
                      {
                        if (__found_grouping.::std::__cxx11::basic_string<char>::size())
                          {
                            __found_grouping += static_cast<char>(__sep_pos);
                          }
                        __xtrc += '.';
                        __found_dec = true;
                      }
                    else
                      {
                        break;
                      }
                  }
                else
                  {
                    const typename ::std::num_get<_CharT, _InIter>::char_type *__q = __traits_type::find(__lit_zero, 10, __c);
                    if (__q)
                      {
                        __xtrc += '0' + (__q - __lit_zero);
                        __found_mantissa = true;
                         ++__sep_pos;
                      }
                    else
                      {
                        if (((__c == __lit[::std::__num_base::_S_ie] || __c == __lit[::std::__num_base::_S_iE]) && !__found_sci) && __found_mantissa)
                          {
                            if (__found_grouping.::std::__cxx11::basic_string<char>::size() && !__found_dec)
                              {
                                __found_grouping += static_cast<char>(__sep_pos);
                              }
                            __xtrc += 'e';
                            __found_sci = true;
                            if ( ++__beg != __end)
                              {
                                __c = *__beg;
                                const bool __plus = __c == __lit[::std::__num_base::_S_iplus];
                                if (((__plus || __c == __lit[::std::__num_base::_S_iminus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)) && !(__c == __lc->_M_decimal_point))
                                  {
                                    __xtrc += __plus ? '+' : '-';
                                  }
                                else
                                  {
                                    continue;
                                  }
                              }
                            else
                              {
                                __testeof = true;
                                break;
                              }
                          }
                        else
                          {
                            break;
                          }
                      }
                  }
              }
            if ( ++__beg != __end)
              {
                __c = *__beg;
              }
            else
              {
                __testeof = true;
              }
          }
      }
    if (__found_grouping.::std::__cxx11::basic_string<char>::size())
      {
        if (!__found_dec && !__found_sci)
          {
            __found_grouping += static_cast<char>(__sep_pos);
          }
        if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size, __found_grouping))
          {
            __err = ::std::ios_base::failbit;
          }
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  template < typename _ValueT >
  __attribute__((__abi_tag__("cxx11"))) typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::_M_extract_int(_InIter __beg, _InIter __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, _ValueT &__v) const 
  {
    typedef ::std::char_traits<_CharT> __traits_type;
    using ::__gnu_cxx::__add_unsigned;
    typedef typename ::__gnu_cxx::__add_unsigned<_ValueT>::__type __unsigned_type;
    typedef ::std::__numpunct_cache<_CharT> __cache_type;
    ::std::__use_cache<__cache_type> __uc;
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const __cache_type *__lc = __uc(__loc);
    const _CharT *__lit = __lc->_M_atoms_in;
    typename ::std::num_get<_CharT, _InIter>::char_type __c = ((typename ::std::num_get<_CharT, _InIter>::char_type()));
    const ::std::ios_base::fmtflags __basefield(__io.::std::ios_base::flags() & ::std::ios_base::basefield);
    const bool __oct(__basefield == ::std::ios_base::oct);
    int __base(__oct ? 8 : __basefield == ::std::ios_base::hex ? 16 : 10);
    bool __testeof = __beg == __end;
    bool __negative(false);
    if (!__testeof)
      {
        __c = *__beg;
        __negative = __c == __lit[::std::__num_base::_S_iminus];
        if (((__negative || __c == __lit[::std::__num_base::_S_iplus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)) && !(__c == __lc->_M_decimal_point))
          {
            if ( ++__beg != __end)
              {
                __c = *__beg;
              }
            else
              {
                __testeof = true;
              }
          }
      }
    bool __found_zero(false);
    int __sep_pos(0);
    while (!__testeof)
      {
        if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) || __c == __lc->_M_decimal_point)
          {
            break;
          }
        else
          {
            if (__c == __lit[::std::__num_base::_S_izero] && (!__found_zero || __base == 10))
              {
                __found_zero = true;
                 ++__sep_pos;
                if (__basefield == 0)
                  {
                    __base = 8;
                  }
                if (__base == 8)
                  {
                    __sep_pos = 0;
                  }
              }
            else
              {
                if (__found_zero && (__c == __lit[::std::__num_base::_S_ix] || __c == __lit[::std::__num_base::_S_iX]))
                  {
                    if (__basefield == 0)
                      {
                        __base = 16;
                      }
                    if (__base == 16)
                      {
                        __found_zero = false;
                        __sep_pos = 0;
                      }
                    else
                      {
                        break;
                      }
                  }
                else
                  {
                    break;
                  }
              }
          }
        if ( ++__beg != __end)
          {
            __c = *__beg;
            if (!__found_zero)
              {
                break;
              }
          }
        else
          {
            __testeof = true;
          }
      }
    const ::std::size_t __len(__base == 16 ? ::std::__num_base::_S_iend - ::std::__num_base::_S_izero : __base);
    ::std::__cxx11::string __found_grouping /* () */ ;
    if (__lc->_M_use_grouping)
      {
        __found_grouping.::std::__cxx11::basic_string<char>::reserve(32);
      }
    bool __testfail(false);
    bool __testoverflow(false);
    const __unsigned_type __max = __negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed ?  -__gnu_cxx::__numeric_traits<_ValueT>::__min : __gnu_cxx::__numeric_traits<_ValueT>::__max;
    const __unsigned_type __smax = __max / __base;
    __unsigned_type __result = 0;
    int __digit(0);
    const typename ::std::num_get<_CharT, _InIter>::char_type *__lit_zero = __lit + ::std::__num_base::_S_izero;
    if (!__lc->_M_allocated)
      {
        while (!__testeof)
          {
            __digit = (*this)._M_find(__lit_zero, __len, __c);
            if (__digit ==  -1)
              {
                break;
              }
            if (__result > __smax)
              {
                __testoverflow = true;
              }
            else
              {
                __result *= __base;
                __testoverflow |= __result > __max - __digit;
                __result += __digit;
                 ++__sep_pos;
              }
            if ( ++__beg != __end)
              {
                __c = *__beg;
              }
            else
              {
                __testeof = true;
              }
          }
      }
    else
      {
        while (!__testeof)
          {
            if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
              {
                if (__sep_pos)
                  {
                    __found_grouping += static_cast<char>(__sep_pos);
                    __sep_pos = 0;
                  }
                else
                  {
                    __testfail = true;
                    break;
                  }
              }
            else
              {
                if (__c == __lc->_M_decimal_point)
                  {
                    break;
                  }
                else
                  {
                    const typename ::std::num_get<_CharT, _InIter>::char_type *__q = __traits_type::find(__lit_zero, __len, __c);
                    if (!__q)
                      {
                        break;
                      }
                    __digit = __q - __lit_zero;
                    if (__digit > 15)
                      {
                        __digit -= 6;
                      }
                    if (__result > __smax)
                      {
                        __testoverflow = true;
                      }
                    else
                      {
                        __result *= __base;
                        __testoverflow |= __result > __max - __digit;
                        __result += __digit;
                         ++__sep_pos;
                      }
                  }
              }
            if ( ++__beg != __end)
              {
                __c = *__beg;
              }
            else
              {
                __testeof = true;
              }
          }
      }
    if (__found_grouping.::std::__cxx11::basic_string<char>::size())
      {
        __found_grouping += static_cast<char>(__sep_pos);
        if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size, __found_grouping))
          {
            __err = ::std::ios_base::failbit;
          }
      }
    if (((!__sep_pos && !__found_zero) && !__found_grouping.::std::__cxx11::basic_string<char>::size()) || __testfail)
      {
        __v = 0;
        __err = ::std::ios_base::failbit;
      }
    else
      {
        if (__testoverflow)
          {
            if (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
              {
                __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
              }
            else
              {
                __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
              }
            __err = ::std::ios_base::failbit;
          }
        else
          {
            __v = __negative ?  -__result : __result;
          }
      }
    if (__testeof)
      {
        __err |= ::std::ios_base::eofbit;
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, bool &__v) const 
  {
    if (!(__io.::std::ios_base::flags() & ::std::ios_base::boolalpha))
      {
        long int __l( -1);
        __beg = (*this)._M_extract_int(__beg, __end, __io, __err, __l);
        if (__l == 0 || __l == 1)
          {
            __v = (bool)__l;
          }
        else
          {
            __v = true;
            __err = ::std::ios_base::failbit;
            if (__beg == __end)
              {
                __err |= ::std::ios_base::eofbit;
              }
          }
      }
    else
      {
        typedef ::std::__numpunct_cache<_CharT> __cache_type;
        ::std::__use_cache<__cache_type> __uc;
        const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
        const __cache_type *__lc = __uc(__loc);
        bool __testf(true);
        bool __testt(true);
        bool __donef = __lc->_M_falsename_size == 0;
        bool __donet = __lc->_M_truename_size == 0;
        bool __testeof(false);
        ::std::size_t __n(0);
        while (!__donef || !__donet)
          {
            if (__beg == __end)
              {
                __testeof = true;
                break;
              }
            const typename ::std::num_get<_CharT, _InIter>::char_type __c = *__beg;
            if (!__donef)
              {
                __testf = __c == __lc->_M_falsename[__n];
              }
            if (!__testf && __donet)
              {
                break;
              }
            if (!__donet)
              {
                __testt = __c == __lc->_M_truename[__n];
              }
            if (!__testt && __donef)
              {
                break;
              }
            if (!__testt && !__testf)
              {
                break;
              }
             ++__n;
             ++__beg;
            __donef = !__testf || __n >= __lc->_M_falsename_size;
            __donet = !__testt || __n >= __lc->_M_truename_size;
          }
        if ((__testf && __n == __lc->_M_falsename_size) && __n)
          {
            __v = false;
            if (__testt && __n == __lc->_M_truename_size)
              {
                __err = ::std::ios_base::failbit;
              }
            else
              {
                __err = __testeof ? ::std::ios_base::eofbit : ::std::ios_base::goodbit;
              }
          }
        else
          {
            if ((__testt && __n == __lc->_M_truename_size) && __n)
              {
                __v = true;
                __err = __testeof ? ::std::ios_base::eofbit : ::std::ios_base::goodbit;
              }
            else
              {
                __v = false;
                __err = ::std::ios_base::failbit;
                if (__testeof)
                  {
                    __err |= ::std::ios_base::eofbit;
                  }
              }
          }
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, float &__v) const 
  {
    ::std::__cxx11::string __xtrc /* () */ ;
    __xtrc.::std::__cxx11::basic_string<char>::reserve(32);
    __beg = (*this)._M_extract_float(__beg, __end, __io, __err, __xtrc);
    std::__convert_to_v(__xtrc.::std::__cxx11::basic_string<char>::c_str(), __v, __err, _S_get_c_locale());
    if (__beg == __end)
      {
        __err |= ::std::ios_base::eofbit;
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, double &__v) const 
  {
    ::std::__cxx11::string __xtrc /* () */ ;
    __xtrc.::std::__cxx11::basic_string<char>::reserve(32);
    __beg = (*this)._M_extract_float(__beg, __end, __io, __err, __xtrc);
    std::__convert_to_v(__xtrc.::std::__cxx11::basic_string<char>::c_str(), __v, __err, _S_get_c_locale());
    if (__beg == __end)
      {
        __err |= ::std::ios_base::eofbit;
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long double &__v) const 
  {
    ::std::__cxx11::string __xtrc /* () */ ;
    __xtrc.::std::__cxx11::basic_string<char>::reserve(32);
    __beg = (*this)._M_extract_float(__beg, __end, __io, __err, __xtrc);
    std::__convert_to_v(__xtrc.::std::__cxx11::basic_string<char>::c_str(), __v, __err, _S_get_c_locale());
    if (__beg == __end)
      {
        __err |= ::std::ios_base::eofbit;
      }
    return __beg;
  }
 /* Instantiation of class template '::__gnu_cxx::__conditional_type<true, unsigned long int, unsigned long long int>' */ 
  template < typename _CharT, typename _InIter >
  typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, void *&__v) const 
  {
    typedef ::std::ios_base::fmtflags fmtflags;
    const fmtflags __fmt(__io.::std::ios_base::flags());
    __io.::std::ios_base::flags(__fmt &  ~::std::ios_base::basefield | ::std::ios_base::hex);
    typedef ::__gnu_cxx::__conditional_type<true, unsigned long int, unsigned long long int>::__type _UIntPtrType;
    _UIntPtrType __ul;
    __beg = (*this)._M_extract_int(__beg, __end, __io, __err, __ul);
    __io.::std::ios_base::flags(__fmt);
    __v = reinterpret_cast<void *>(__ul);
    return __beg;
  }
  template < typename _CharT, typename _OutIter >
  void num_put<_CharT, _OutIter>::_M_pad(_CharT __fill, ::std::streamsize __w, ::std::ios_base &__io, _CharT *__new, const _CharT *__cs, int &__len) const 
  {
    __pad<_CharT, ::std::char_traits<_CharT> >::_S_pad(__io, __fill, __new, __cs, __w, __len);
    __len = static_cast<int>(__w);
  }
  template < typename _CharT, typename _ValueT >
  int __int_to_char(_CharT *__bufend, _ValueT __v, const _CharT *__lit, ::std::ios_base::fmtflags __flags, bool __dec);
  template < typename _CharT, typename _ValueT >
  int __int_to_char(_CharT *__bufend, _ValueT __v, const _CharT *__lit, ::std::ios_base::fmtflags __flags, bool __dec)
  {
    _CharT *__buf = __bufend;
    if (__builtin_expect(__dec, true))
      {
        do
          {
            * --__buf = __lit[__v % 10 + ::std::__num_base::_S_odigits];
            __v /= 10;
          }
        while (__v != 0);
      }
    else
      {
        if ((__flags & ::std::ios_base::basefield) == ::std::ios_base::oct)
          {
            do
              {
                * --__buf = __lit[(__v & 7) + ::std::__num_base::_S_odigits];
                __v >>= 3;
              }
            while (__v != 0);
          }
        else
          {
            const bool __uppercase(__flags & ::std::ios_base::uppercase);
            const int __case_offset(__uppercase ? ::std::__num_base::_S_oudigits : ::std::__num_base::_S_odigits);
            do
              {
                * --__buf = __lit[(__v & 15) + __case_offset];
                __v >>= 4;
              }
            while (__v != 0);
          }
      }
    return __bufend - __buf;
  }
  template < typename _CharT, typename _OutIter >
  void num_put<_CharT, _OutIter>::_M_group_int(const char *__grouping, ::std::size_t __grouping_size, _CharT __sep, ::std::ios_base &, _CharT *__new, _CharT *__cs, int &__len) const 
  {
    _CharT *__p = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __len);
    __len = __p - __new;
  }
  template < typename _CharT, typename _OutIter >
  template < typename _ValueT >
  typename ::std::num_put<_CharT, _OutIter>::iter_type num_put<_CharT, _OutIter>::_M_insert_int(_OutIter __s, ::std::ios_base &__io, _CharT __fill, _ValueT __v) const 
  {
    using ::__gnu_cxx::__add_unsigned;
    typedef typename ::__gnu_cxx::__add_unsigned<_ValueT>::__type __unsigned_type;
    typedef ::std::__numpunct_cache<_CharT> __cache_type;
    ::std::__use_cache<__cache_type> __uc;
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const __cache_type *__lc = __uc(__loc);
    const _CharT *__lit = __lc->_M_atoms_out;
    const ::std::ios_base::fmtflags __flags(__io.::std::ios_base::flags());
    const int __ilen = 5 * sizeof(_ValueT);
    _CharT *__cs = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __ilen));
    const ::std::ios_base::fmtflags __basefield(__flags & ::std::ios_base::basefield);
    const bool __dec(__basefield != ::std::ios_base::oct && __basefield != ::std::ios_base::hex);
    const __unsigned_type __u = (__v > 0 || !__dec ? __unsigned_type(__v) :  -__unsigned_type(__v));
    int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
    __cs += __ilen - __len;
    if (__lc->_M_use_grouping)
      {
        _CharT *__cs2 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * (__len + 1) * 2));
        (*this)._M_group_int(__lc->_M_grouping, __lc->_M_grouping_size, __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
        __cs = __cs2 + 2;
      }
    if (__builtin_expect(__dec, true))
      {
        if (__v >= 0)
          {
            if ((bool)(__flags & ::std::ios_base::showpos) && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
              {
                (* --__cs = __lit[::std::__num_base::_S_oplus],  ++__len);
              }
          }
        else
          {
            (* --__cs = __lit[::std::__num_base::_S_ominus],  ++__len);
          }
      }
    else
      {
        if ((bool)(__flags & ::std::ios_base::showbase) && __v)
          {
            if (__basefield == ::std::ios_base::oct)
              {
                (* --__cs = __lit[::std::__num_base::_S_odigits],  ++__len);
              }
            else
              {
                const bool __uppercase(__flags & ::std::ios_base::uppercase);
                * --__cs = __lit[::std::__num_base::_S_ox + __uppercase];
                * --__cs = __lit[::std::__num_base::_S_odigits];
                __len += 2;
              }
          }
      }
    const ::std::streamsize __w(__io.::std::ios_base::width());
    if (__w > static_cast< ::std::streamsize>(__len))
      {
        _CharT *__cs3 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __w));
        (*this)._M_pad(__fill, __w, __io, __cs3, __cs, __len);
        __cs = __cs3;
      }
    __io.::std::ios_base::width(0);
    return std::__write(__s, __cs, __len);
  }
  template < typename _CharT, typename _OutIter >
  void num_put<_CharT, _OutIter>::_M_group_float(const char *__grouping, ::std::size_t __grouping_size, _CharT __sep, const _CharT *__p, _CharT *__new, _CharT *__cs, int &__len) const 
  {
    const int __declen = __p ? __p - __cs : __len;
    _CharT *__p2 = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __declen);
    int __newlen = __p2 - __new;
    if (__p)
      {
        char_traits<_CharT>::copy(__p2, __p, __len - __declen);
        __newlen += __len - __declen;
      }
    __len = __newlen;
  }
  template < typename _CharT, typename _OutIter >
  template < typename _ValueT >
  typename ::std::num_put<_CharT, _OutIter>::iter_type num_put<_CharT, _OutIter>::_M_insert_float(_OutIter __s, ::std::ios_base &__io, _CharT __fill, char __mod, _ValueT __v) const 
  {
    typedef ::std::__numpunct_cache<_CharT> __cache_type;
    ::std::__use_cache<__cache_type> __uc;
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const __cache_type *__lc = __uc(__loc);
    const ::std::streamsize __prec(__io.::std::ios_base::precision() < 0 ? 6 : __io.::std::ios_base::precision());
    const int __max_digits = __gnu_cxx::__numeric_traits<_ValueT>::__digits10;
    int __len;
    char __fbuf[16L];
    __num_base::_S_format_float(__io, __fbuf, __mod);
    const bool __use_prec((__io.::std::ios_base::flags() & ::std::ios_base::floatfield) != ::std::ios_base::floatfield);
    int __cs_size = __max_digits * 3;
    char *__cs(static_cast<char *>(__builtin_alloca(__cs_size)));
    if (__use_prec)
      {
        __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v);
      }
    else
      {
        __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __v);
      }
    if (__len >= __cs_size)
      {
        __cs_size = __len + 1;
        __cs = static_cast<char *>(__builtin_alloca(__cs_size));
        if (__use_prec)
          {
            __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v);
          }
        else
          {
            __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __v);
          }
      }
    const ::std::ctype<_CharT> &__ctype = use_facet< ::std::ctype<_CharT> >(__loc);
    _CharT *__ws = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __len));
    __ctype.widen(__cs, __cs + __len, __ws);
    _CharT *__wp = 0;
    const char *__p = char_traits<char>::find(__cs, __len, '.');
    if (__p)
      {
        __wp = __ws + (__p - __cs);
        *__wp = __lc->_M_decimal_point;
      }
    if (__lc->_M_use_grouping && ((__wp || __len < 3) || (((__cs[1] <= '9' && __cs[2] <= '9') && __cs[1] >= '0') && __cs[2] >= '0')))
      {
        _CharT *__ws2 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __len * 2));
        ::std::streamsize __off(0);
        if (__cs[0] == '-' || __cs[0] == '+')
          {
            __off = 1;
            __ws2[0] = __ws[0];
            __len -= 1;
          }
        (*this)._M_group_float(__lc->_M_grouping, __lc->_M_grouping_size, __lc->_M_thousands_sep, __wp, __ws2 + __off, __ws + __off, __len);
        __len += __off;
        __ws = __ws2;
      }
    const ::std::streamsize __w(__io.::std::ios_base::width());
    if (__w > static_cast< ::std::streamsize>(__len))
      {
        _CharT *__ws3 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __w));
        (*this)._M_pad(__fill, __w, __io, __ws3, __ws, __len);
        __ws = __ws3;
      }
    __io.::std::ios_base::width(0);
    return std::__write(__s, __ws, __len);
  }
  template < typename _CharT, typename _OutIter >
  typename ::std::num_put<_CharT, _OutIter>::iter_type num_put<_CharT, _OutIter>::do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, bool __v) const 
  {
    const ::std::ios_base::fmtflags __flags(__io.::std::ios_base::flags());
    if ((__flags & ::std::ios_base::boolalpha) == 0)
      {
        const long int __l(__v);
        __s = (*this)._M_insert_int(__s, __io, __fill, __l);
      }
    else
      {
        typedef ::std::__numpunct_cache<_CharT> __cache_type;
        ::std::__use_cache<__cache_type> __uc;
        const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
        const __cache_type *__lc = __uc(__loc);
        const _CharT *__name = __v ? __lc->_M_truename : __lc->_M_falsename;
        int __len = __v ? __lc->_M_truename_size : __lc->_M_falsename_size;
        const ::std::streamsize __w(__io.::std::ios_base::width());
        if (__w > static_cast< ::std::streamsize>(__len))
          {
            const ::std::streamsize __plen = __w - __len;
            _CharT *__ps = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __plen));
            char_traits<_CharT>::assign(__ps, __plen, __fill);
            __io.::std::ios_base::width(0);
            if ((__flags & ::std::ios_base::adjustfield) == ::std::ios_base::left)
              {
                __s = std::__write(__s, __name, __len);
                __s = std::__write(__s, __ps, __plen);
              }
            else
              {
                __s = std::__write(__s, __ps, __plen);
                __s = std::__write(__s, __name, __len);
              }
            return __s;
          }
        __io.::std::ios_base::width(0);
        __s = std::__write(__s, __name, __len);
      }
    return __s;
  }
  template < typename _CharT, typename _OutIter >
  typename ::std::num_put<_CharT, _OutIter>::iter_type num_put<_CharT, _OutIter>::do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, double __v) const 
  {
    return (*this)._M_insert_float(__s, __io, __fill, char(), __v);
  }
  template < typename _CharT, typename _OutIter >
  typename ::std::num_put<_CharT, _OutIter>::iter_type num_put<_CharT, _OutIter>::do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long double __v) const 
  {
    return (*this)._M_insert_float(__s, __io, __fill, 'L', __v);
  }
  template < typename _CharT, typename _OutIter >
  typename ::std::num_put<_CharT, _OutIter>::iter_type num_put<_CharT, _OutIter>::do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, const void *__v) const 
  {
    const ::std::ios_base::fmtflags __flags(__io.::std::ios_base::flags());
    const ::std::ios_base::fmtflags __fmt( ~(::std::ios_base::basefield | ::std::ios_base::uppercase));
    __io.::std::ios_base::flags(__flags & __fmt | (::std::ios_base::hex | ::std::ios_base::showbase));
    typedef ::__gnu_cxx::__conditional_type<true, unsigned long int, unsigned long long int>::__type _UIntPtrType;
    __s = (*this)._M_insert_int(__s, __io, __fill, reinterpret_cast<_UIntPtrType>(__v));
    __io.::std::ios_base::flags(__flags);
    return __s;
  }
  template < typename _CharT, typename _Traits >
  void __pad<_CharT, _Traits>::_S_pad(::std::ios_base &__io, _CharT __fill, _CharT *__news, const _CharT *__olds, ::std::streamsize __newlen, ::std::streamsize __oldlen)
  {
    const ::std::size_t __plen(static_cast< ::std::size_t>(__newlen - __oldlen));
    const ::std::ios_base::fmtflags __adjust(__io.::std::ios_base::flags() & ::std::ios_base::adjustfield);
    if (__adjust == ::std::ios_base::left)
      {
        _Traits::copy(__news, __olds, __oldlen);
        _Traits::assign(__news + __oldlen, __plen, __fill);
        return ;
      }
    ::std::size_t __mod(0);
    if (__adjust == ::std::ios_base::internal)
      {
        const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
        const ::std::ctype<_CharT> &__ctype = use_facet< ::std::ctype<_CharT> >(__loc);
        if (__ctype.widen('-') == __olds[0] || __ctype.widen('+') == __olds[0])
          {
            __news[0] = __olds[0];
            __mod = 1;
             ++__news;
          }
        else
          {
            if ((__ctype.widen('0') == __olds[0] && __oldlen > 1) && (__ctype.widen('x') == __olds[1] || __ctype.widen('X') == __olds[1]))
              {
                __news[0] = __olds[0];
                __news[1] = __olds[1];
                __mod = 2;
                __news += 2;
              }
          }
      }
    _Traits::assign(__news, __plen, __fill);
    _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
  }
  template < typename _CharT >
  _CharT *__add_grouping(_CharT *__s, _CharT __sep, const char *__gbeg, ::std::size_t __gsize, const _CharT *__first, const _CharT *__last)
  {
    ::std::size_t __idx(0);
    ::std::size_t __ctr(0);
    while ((__last - __first > __gbeg[__idx] && static_cast<signed char>(__gbeg[__idx]) > 0) && __gbeg[__idx] != ::__gnu_cxx::__numeric_traits_integer<char>::__max)
      {
        __last -= __gbeg[__idx];
        __idx < __gsize - 1 ?  ++__idx :  ++__ctr;
      }
    while (__first != __last)
      {
        *__s++ = *__first++;
      }
    while (__ctr--)
      {
        *__s++ = __sep;
        for (char __i(__gbeg[__idx]); __i > 0;  --__i)
          {
            *__s++ = *__first++;
          }
      }
    while (__idx--)
      {
        *__s++ = __sep;
        for (char __i(__gbeg[__idx]); __i > 0;  --__i)
          {
            *__s++ = *__first++;
          }
      }
    return __s;
  }
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    extern template class ::std::__cxx11::numpunct<char>;
    extern template class ::std::__cxx11::numpunct_byname<char>;
  }
  extern template class ::std::num_get<char>;
  extern template class ::std::num_put<char>;
  extern template class ::std::ctype_byname<char>;
  extern template const ::std::ctype<char> &use_facet< ::std::ctype<char> >(const ::std::locale &);
  extern template const ::std::__cxx11::numpunct<char> &use_facet< ::std::__cxx11::numpunct<char> >(const ::std::locale &);
  extern template const ::std::num_put<char> &use_facet< ::std::num_put<char> >(const ::std::locale &);
  extern template const ::std::num_get<char> &use_facet< ::std::num_get<char> >(const ::std::locale &);
  extern template bool has_facet< ::std::ctype<char> >(const ::std::locale &);
  extern template bool has_facet< ::std::__cxx11::numpunct<char> >(const ::std::locale &);
  extern template bool has_facet< ::std::num_put<char> >(const ::std::locale &);
  extern template bool has_facet< ::std::num_get<char> >(const ::std::locale &);
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    extern template class ::std::__cxx11::numpunct<wchar_t>;
    extern template class ::std::__cxx11::numpunct_byname<wchar_t>;
  }
  extern template class ::std::num_get<wchar_t>;
  extern template class ::std::num_put<wchar_t>;
  extern template class ::std::ctype_byname<wchar_t>;
  extern template const ::std::ctype<wchar_t> &use_facet< ::std::ctype<wchar_t> >(const ::std::locale &);
  extern template const ::std::__cxx11::numpunct<wchar_t> &use_facet< ::std::__cxx11::numpunct<wchar_t> >(const ::std::locale &);
  extern template const ::std::num_put<wchar_t> &use_facet< ::std::num_put<wchar_t> >(const ::std::locale &);
  extern template const ::std::num_get<wchar_t> &use_facet< ::std::num_get<wchar_t> >(const ::std::locale &);
  extern template bool has_facet< ::std::ctype<wchar_t> >(const ::std::locale &);
  extern template bool has_facet< ::std::__cxx11::numpunct<wchar_t> >(const ::std::locale &);
  extern template bool has_facet< ::std::num_put<wchar_t> >(const ::std::locale &);
  extern template bool has_facet< ::std::num_get<wchar_t> >(const ::std::locale &);
  template < typename _Facet >
  inline const _Facet &__check_facet(const _Facet *__f);
  template < typename _Facet >
  inline const _Facet &__check_facet(const _Facet *__f)
  {
    if (!__f)
      {
        ::std::__throw_bad_cast();
      }
    return *__f;
  }
  template < typename _CharT, typename _Traits >
  class  basic_ios : public ::std::ios_base
  {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef ::std::ctype<_CharT> __ctype_type;
      typedef ::std::num_put<_CharT, ::std::ostreambuf_iterator<_CharT, _Traits> > __num_put_type;
      typedef ::std::num_get<_CharT, ::std::istreambuf_iterator<_CharT, _Traits> > __num_get_type;
    protected:
      ::std::basic_ostream<_CharT, _Traits> *_M_tie;
      mutable typename ::std::basic_ios<_CharT, _Traits>::char_type _M_fill;
      mutable bool _M_fill_init;
      ::std::basic_streambuf<_CharT, _Traits> *_M_streambuf;
      const typename ::std::basic_ios<_CharT, _Traits>::__ctype_type *_M_ctype;
      const typename ::std::basic_ios<_CharT, _Traits>::__num_put_type *_M_num_put;
      const typename ::std::basic_ios<_CharT, _Traits>::__num_get_type *_M_num_get;
    public:
      inline operator void *() const 
      {
        return this->fail() ? 0 : const_cast< ::std::basic_ios<_CharT, _Traits> *>(this);
      }
      inline bool operator !() const 
      {
        return this->fail();
      }
      inline ::std::ios_base::iostate rdstate() const 
      {
        return (*this)._M_streambuf_state;
      }
      void clear(::std::ios_base::iostate __state  = (::std::ios_base::goodbit));
      inline void setstate(::std::ios_base::iostate __state)
      {
        this->clear(this->rdstate() | __state);
      }
      inline void _M_setstate(::std::ios_base::iostate __state)
      {
        (*this)._M_streambuf_state |= __state;
        if (this->exceptions() & __state)
          {
            throw;
          }
      }
      inline bool good() const 
      {
        return this->rdstate() == 0;
      }
      inline bool eof() const 
      {
        return (this->rdstate() & ::std::ios_base::eofbit) != 0;
      }
      inline bool fail() const 
      {
        return (this->rdstate() & (::std::ios_base::badbit | ::std::ios_base::failbit)) != 0;
      }
      inline bool bad() const 
      {
        return (this->rdstate() & ::std::ios_base::badbit) != 0;
      }
      inline ::std::ios_base::iostate exceptions() const 
      {
        return (*this)._M_exception;
      }
      inline void exceptions(::std::ios_base::iostate __except)
      {
        (*this)._M_exception = __except;
        this->clear((*this)._M_streambuf_state);
      }
      inline explicit basic_ios(::std::basic_streambuf<_CharT, _Traits> *__sb)
        : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      {
        this->init(__sb);
      }
      inline virtual ~basic_ios()
      {
      }
      inline ::std::basic_ostream<_CharT, _Traits> *tie() const 
      {
        return ::std::basic_ios<_CharT, _Traits>::_M_tie;
      }
      inline ::std::basic_ostream<_CharT, _Traits> *tie(::std::basic_ostream<_CharT, _Traits> *__tiestr)
      {
        ::std::basic_ostream<_CharT, _Traits> *__old = ::std::basic_ios<_CharT, _Traits>::_M_tie;
        ::std::basic_ios<_CharT, _Traits>::_M_tie = __tiestr;
        return __old;
      }
      inline ::std::basic_streambuf<_CharT, _Traits> *rdbuf() const 
      {
        return ::std::basic_ios<_CharT, _Traits>::_M_streambuf;
      }
      ::std::basic_streambuf<_CharT, _Traits> *rdbuf(::std::basic_streambuf<_CharT, _Traits> *__sb);
      ::std::basic_ios<_CharT, _Traits> &copyfmt(const ::std::basic_ios<_CharT, _Traits> &__rhs);
      inline typename ::std::basic_ios<_CharT, _Traits>::char_type fill() const 
      {
        if (!::std::basic_ios<_CharT, _Traits>::_M_fill_init)
          {
            ::std::basic_ios<_CharT, _Traits>::_M_fill = this->widen(' ');
            ::std::basic_ios<_CharT, _Traits>::_M_fill_init = true;
          }
        return ::std::basic_ios<_CharT, _Traits>::_M_fill;
      }
      inline typename ::std::basic_ios<_CharT, _Traits>::char_type fill(typename ::std::basic_ios<_CharT, _Traits>::char_type __ch)
      {
        typename ::std::basic_ios<_CharT, _Traits>::char_type __old = this->fill();
        ::std::basic_ios<_CharT, _Traits>::_M_fill = __ch;
        return __old;
      }
      ::std::locale imbue(const ::std::locale &__loc);
      inline char narrow(typename ::std::basic_ios<_CharT, _Traits>::char_type __c, char __dfault) const 
      {
        return __check_facet(::std::basic_ios<_CharT, _Traits>::_M_ctype).narrow(__c, __dfault);
      }
      inline typename ::std::basic_ios<_CharT, _Traits>::char_type widen(char __c) const 
      {
        return __check_facet(::std::basic_ios<_CharT, _Traits>::_M_ctype).widen(__c);
      }
    protected:
      inline basic_ios()
        : ios_base(), _M_tie(0), _M_fill(((typename ::std::basic_ios<_CharT, _Traits>::char_type()))), _M_fill_init(false), _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      {
      }
      void init(::std::basic_streambuf<_CharT, _Traits> *__sb);
      void _M_cache_locale(const ::std::locale &__loc);
  };
  template < typename _CharT, typename _Traits >
  void basic_ios<_CharT, _Traits>::clear(::std::ios_base::iostate __state)
  {
    if (this->rdbuf())
      {
        (*this)._M_streambuf_state = __state;
      }
    else
      {
        (*this)._M_streambuf_state = __state | ::std::ios_base::badbit;
      }
    if (this->exceptions() & this->rdstate())
      {
        ::std::__throw_ios_failure("basic_ios::clear");
      }
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_streambuf<_CharT, _Traits> *basic_ios<_CharT, _Traits>::rdbuf(::std::basic_streambuf<_CharT, _Traits> *__sb)
  {
    ::std::basic_streambuf<_CharT, _Traits> *__old = ::std::basic_ios<_CharT, _Traits>::_M_streambuf;
    ::std::basic_ios<_CharT, _Traits>::_M_streambuf = __sb;
    this->clear();
    return __old;
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_ios<_CharT, _Traits> &basic_ios<_CharT, _Traits>::copyfmt(const ::std::basic_ios<_CharT, _Traits> &__rhs)
  {
    if (this != &__rhs)
      {
        ::std::ios_base::_Words *__words = __rhs._M_word_size <= ::std::ios_base::_S_local_word_size ? (*this)._M_local_word : new ::std::ios_base::_Words [__rhs._M_word_size];
        ::std::ios_base::_Callback_list *__cb = __rhs._M_callbacks;
        if (__cb)
          {
            (*__cb).::std::ios_base::_Callback_list::_M_add_reference();
          }
        (*this)._M_call_callbacks(::std::ios_base::erase_event);
        if ((*this)._M_word != (*this)._M_local_word)
          {
            delete[] (*this)._M_word;
            (*this)._M_word = 0;
          }
        (*this)._M_dispose_callbacks();
        (*this)._M_callbacks = __cb;
        for (int __i(0); __i < __rhs._M_word_size;  ++__i)
          {
            __words[__i] = __rhs._M_word[__i];
          }
        (*this)._M_word = __words;
        (*this)._M_word_size = __rhs._M_word_size;
        this->flags(__rhs.flags());
        this->width(__rhs.width());
        this->precision(__rhs.precision());
        this->tie(__rhs.tie());
        this->fill(__rhs.fill());
        (*this)._M_ios_locale = __rhs.getloc();
        (*this)._M_cache_locale((*this)._M_ios_locale);
        (*this)._M_call_callbacks(::std::ios_base::copyfmt_event);
        this->exceptions(__rhs.exceptions());
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  ::std::locale basic_ios<_CharT, _Traits>::imbue(const ::std::locale &__loc)
  {
    ::std::locale __old(this->getloc());
    ios_base::imbue(__loc);
    (*this)._M_cache_locale(__loc);
    if (this->rdbuf() != 0)
      {
        this->rdbuf()->pubimbue(__loc);
      }
    return __old;
  }
  template < typename _CharT, typename _Traits >
  void basic_ios<_CharT, _Traits>::init(::std::basic_streambuf<_CharT, _Traits> *__sb)
  {
    ios_base::_M_init();
    (*this)._M_cache_locale((*this)._M_ios_locale);
    ::std::basic_ios<_CharT, _Traits>::_M_fill = _CharT();
    ::std::basic_ios<_CharT, _Traits>::_M_fill_init = false;
    ::std::basic_ios<_CharT, _Traits>::_M_tie = 0;
    (*this)._M_exception = ::std::ios_base::goodbit;
    ::std::basic_ios<_CharT, _Traits>::_M_streambuf = __sb;
    (*this)._M_streambuf_state = __sb ? ::std::ios_base::goodbit : ::std::ios_base::badbit;
  }
  template < typename _CharT, typename _Traits >
  void basic_ios<_CharT, _Traits>::_M_cache_locale(const ::std::locale &__loc)
  {
    if (__builtin_expect(has_facet<typename ::std::basic_ios<_CharT, _Traits>::__ctype_type>(__loc), true))
      {
        ::std::basic_ios<_CharT, _Traits>::_M_ctype = std::__addressof(use_facet<typename ::std::basic_ios<_CharT, _Traits>::__ctype_type>(__loc));
      }
    else
      {
        ::std::basic_ios<_CharT, _Traits>::_M_ctype = 0;
      }
    if (__builtin_expect(has_facet<typename ::std::basic_ios<_CharT, _Traits>::__num_put_type>(__loc), true))
      {
        ::std::basic_ios<_CharT, _Traits>::_M_num_put = std::__addressof(use_facet<typename ::std::basic_ios<_CharT, _Traits>::__num_put_type>(__loc));
      }
    else
      {
        ::std::basic_ios<_CharT, _Traits>::_M_num_put = 0;
      }
    if (__builtin_expect(has_facet<typename ::std::basic_ios<_CharT, _Traits>::__num_get_type>(__loc), true))
      {
        ::std::basic_ios<_CharT, _Traits>::_M_num_get = std::__addressof(use_facet<typename ::std::basic_ios<_CharT, _Traits>::__num_get_type>(__loc));
      }
    else
      {
        ::std::basic_ios<_CharT, _Traits>::_M_num_get = 0;
      }
  }
  extern template class ::std::basic_ios<char>;
  extern template class ::std::basic_ios<wchar_t>;
  template < typename _CharT, typename _Traits >
  class  basic_ostream : virtual public ::std::basic_ios<_CharT, _Traits>
  {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef ::std::basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef ::std::basic_ios<_CharT, _Traits> __ios_type;
      typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef ::std::num_put<_CharT, ::std::ostreambuf_iterator<_CharT, _Traits> > __num_put_type;
      typedef ::std::ctype<_CharT> __ctype_type;
      inline explicit basic_ostream(typename ::std::basic_ostream<_CharT, _Traits>::__streambuf_type *__sb)
      {
        this->init(__sb);
      }
      inline virtual ~basic_ostream()
      {
      }
      class sentry;
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &(*__pf)(typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &))
      {
        return __pf(*this);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(typename ::std::basic_ostream<_CharT, _Traits>::__ios_type &(*__pf)(typename ::std::basic_ostream<_CharT, _Traits>::__ios_type &))
      {
        __pf(*this);
        return *this;
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(::std::ios_base &(*__pf)(::std::ios_base &))
      {
        __pf(*this);
        return *this;
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(long int __n)
      {
        return (*this)._M_insert(__n);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(unsigned long int __n)
      {
        return (*this)._M_insert(__n);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(bool __n)
      {
        return (*this)._M_insert(__n);
      }
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(short int __n);
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(unsigned short int __n)
      {
        return (*this)._M_insert(static_cast<unsigned long int>(__n));
      }
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(int __n);
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(unsigned int __n)
      {
        return (*this)._M_insert(static_cast<unsigned long int>(__n));
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(long long int __n)
      {
        return (*this)._M_insert(__n);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(unsigned long long int __n)
      {
        return (*this)._M_insert(__n);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(double __f)
      {
        return (*this)._M_insert(__f);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(float __f)
      {
        return (*this)._M_insert(static_cast<double>(__f));
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(long double __f)
      {
        return (*this)._M_insert(__f);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(const void *__p)
      {
        return (*this)._M_insert(__p);
      }
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(typename ::std::basic_ostream<_CharT, _Traits>::__streambuf_type *__sbin);
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &put(typename ::std::basic_ostream<_CharT, _Traits>::char_type __c);
      inline void _M_write(const typename ::std::basic_ostream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
      {
        const ::std::streamsize __put = this->rdbuf()->sputn(__s, __n);
        if (__put != __n)
          {
            this->setstate(::std::ios_base::badbit);
          }
      }
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &write(const typename ::std::basic_ostream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n);
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &flush();
      typename ::std::basic_ostream<_CharT, _Traits>::pos_type tellp();
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &seekp(typename ::std::basic_ostream<_CharT, _Traits>::pos_type __pos);
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &seekp(typename ::std::basic_ostream<_CharT, _Traits>::off_type __off, ::std::ios_base::seekdir __dir);
    protected:
      inline basic_ostream()
      {
        this->init(0);
      }
      template < typename _ValueT >
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &_M_insert(_ValueT __v);
    friend class sentry;
  };
  template < typename _CharT, typename _Traits >
  class  basic_ostream<_CharT, _Traits>::sentry
  {
      bool _M_ok;
      ::std::basic_ostream<_CharT, _Traits> &_M_os;
    public:
      explicit sentry(::std::basic_ostream<_CharT, _Traits> &__os);
      inline ~sentry()
      {
        if (bool(::std::basic_ostream<_CharT, _Traits>::sentry::_M_os.flags() & ::std::ios_base::unitbuf) && !::std::uncaught_exception())
          {
            if (::std::basic_ostream<_CharT, _Traits>::sentry::_M_os.rdbuf() && ::std::basic_ostream<_CharT, _Traits>::sentry::_M_os.rdbuf()->pubsync() ==  -1)
              {
                ::std::basic_ostream<_CharT, _Traits>::sentry::_M_os.setstate(::std::ios_base::badbit);
              }
          }
      }
      inline operator bool() const 
      {
        return ::std::basic_ostream<_CharT, _Traits>::sentry::_M_ok;
      }
  };
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, _CharT __c);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, _CharT __c)
  {
    return __ostream_insert(__out, &__c, 1);
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, char __c);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, char __c)
  {
    return __out << __out.widen(__c);
  }
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, char __c);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, char __c)
  {
    return __ostream_insert(__out, &__c, 1);
  }
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, signed char __c);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, signed char __c)
  {
    return __out << static_cast<char>(__c);
  }
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, unsigned char __c);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, unsigned char __c)
  {
    return __out << static_cast<char>(__c);
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, const _CharT *__s);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, const _CharT *__s)
  {
    if (!__s)
      {
        __out.setstate(::std::ios_base::badbit);
      }
    else
      {
        __ostream_insert(__out, __s, static_cast< ::std::streamsize>(_Traits::length(__s)));
      }
    return __out;
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, const char *__s);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, const char *__s);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, const char *__s)
  {
    if (!__s)
      {
        __out.setstate(::std::ios_base::badbit);
      }
    else
      {
        __ostream_insert(__out, __s, static_cast< ::std::streamsize>(_Traits::length(__s)));
      }
    return __out;
  }
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, const signed char *__s);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, const signed char *__s)
  {
    return __out << reinterpret_cast<const char *>(__s);
  }
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, const unsigned char *__s);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, const unsigned char *__s)
  {
    return __out << reinterpret_cast<const char *>(__s);
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &endl(::std::basic_ostream<_CharT, _Traits> &__os);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &endl(::std::basic_ostream<_CharT, _Traits> &__os)
  {
    return flush(__os.put(__os.widen('\n')));
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &ends(::std::basic_ostream<_CharT, _Traits> &__os);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &ends(::std::basic_ostream<_CharT, _Traits> &__os)
  {
    return __os.put(_CharT());
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &flush(::std::basic_ostream<_CharT, _Traits> &__os);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &flush(::std::basic_ostream<_CharT, _Traits> &__os)
  {
    return __os.flush();
  }
  template < typename _CharT, typename _Traits >
  basic_ostream<_CharT, _Traits>::sentry::sentry(::std::basic_ostream<_CharT, _Traits> &__os)
    : _M_ok(false), _M_os(__os)
  {
    if (__os.tie() && __os.good())
      {
        __os.tie()->flush();
      }
    if (__os.good())
      {
        ::std::basic_ostream<_CharT, _Traits>::sentry::_M_ok = true;
      }
    else
      {
        __os.setstate(::std::ios_base::failbit);
      }
  }
  template < typename _CharT, typename _Traits >
  template < typename _ValueT >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::_M_insert(_ValueT __v)
  {
    typename ::std::basic_ostream<_CharT, _Traits>::sentry __cerb(*this);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_ostream<_CharT, _Traits>::__num_put_type &__np = __check_facet(this->_M_num_put);
          if (__np.put(*this, *this, this->fill(), __v).failed())
            {
              __err |= ::std::ios_base::badbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::operator <<(short int __n)
  {
    const ::std::ios_base::fmtflags __fmt = this->flags() & ::std::ios_base::basefield;
    if (__fmt == ::std::ios_base::oct || __fmt == ::std::ios_base::hex)
      {
        return (*this)._M_insert(static_cast<long int>(static_cast<unsigned short int>(__n)));
      }
    else
      {
        return (*this)._M_insert(static_cast<long int>(__n));
      }
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::operator <<(int __n)
  {
    const ::std::ios_base::fmtflags __fmt = this->flags() & ::std::ios_base::basefield;
    if (__fmt == ::std::ios_base::oct || __fmt == ::std::ios_base::hex)
      {
        return (*this)._M_insert(static_cast<long int>(static_cast<unsigned int>(__n)));
      }
    else
      {
        return (*this)._M_insert(static_cast<long int>(__n));
      }
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::operator <<(typename ::std::basic_ostream<_CharT, _Traits>::__streambuf_type *__sbin)
  {
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_ostream<_CharT, _Traits>::sentry __cerb(*this);
    if (__cerb && __sbin)
      {
        try
        {
          if (!__copy_streambufs(__sbin, this->rdbuf()))
            {
              __err |= ::std::ios_base::failbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::failbit);
        }
      }
    else
      {
        if (!__sbin)
          {
            __err |= ::std::ios_base::badbit;
          }
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::put(typename ::std::basic_ostream<_CharT, _Traits>::char_type __c)
  {
    typename ::std::basic_ostream<_CharT, _Traits>::sentry __cerb(*this);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_ostream<_CharT, _Traits>::int_type __put = this->rdbuf()->sputc(__c);
          if (traits_type::eq_int_type(__put, traits_type::eof()))
            {
              __err |= ::std::ios_base::badbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::write(const _CharT *__s, ::std::streamsize __n)
  {
    typename ::std::basic_ostream<_CharT, _Traits>::sentry __cerb(*this);
    if (__cerb)
      {
        try
        {
          (*this)._M_write(__s, __n);
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::flush()
  {
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    try
    {
      if (this->rdbuf() && this->rdbuf()->pubsync() ==  -1)
        {
          __err |= ::std::ios_base::badbit;
        }
    }
    catch (::__cxxabiv1::__forced_unwind &)
    {
      this->_M_setstate(::std::ios_base::badbit);
      throw;
    }
    catch (...)
    {
      this->_M_setstate(::std::ios_base::badbit);
    }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::pos_type basic_ostream<_CharT, _Traits>::tellp()
  {
    typename ::std::basic_ostream<_CharT, _Traits>::pos_type __ret = ((typename ::std::basic_ostream<_CharT, _Traits>::pos_type( -1)));
    try
    {
      if (!this->fail())
        {
          __ret = this->rdbuf()->pubseekoff(0, ::std::ios_base::cur, ::std::ios_base::out);
        }
    }
    catch (::__cxxabiv1::__forced_unwind &)
    {
      this->_M_setstate(::std::ios_base::badbit);
      throw;
    }
    catch (...)
    {
      this->_M_setstate(::std::ios_base::badbit);
    }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::seekp(typename ::std::basic_ostream<_CharT, _Traits>::pos_type __pos)
  {
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    try
    {
      if (!this->fail())
        {
          const typename ::std::basic_ostream<_CharT, _Traits>::pos_type __p = this->rdbuf()->pubseekpos(__pos, ::std::ios_base::out);
          if (__p == ((typename ::std::basic_ostream<_CharT, _Traits>::pos_type(((typename ::std::basic_ostream<_CharT, _Traits>::off_type( -1)))))))
            {
              __err |= ::std::ios_base::failbit;
            }
        }
    }
    catch (::__cxxabiv1::__forced_unwind &)
    {
      this->_M_setstate(::std::ios_base::badbit);
      throw;
    }
    catch (...)
    {
      this->_M_setstate(::std::ios_base::badbit);
    }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::seekp(typename ::std::basic_ostream<_CharT, _Traits>::off_type __off, ::std::ios_base::seekdir __dir)
  {
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    try
    {
      if (!this->fail())
        {
          const typename ::std::basic_ostream<_CharT, _Traits>::pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, ::std::ios_base::out);
          if (__p == ((typename ::std::basic_ostream<_CharT, _Traits>::pos_type(((typename ::std::basic_ostream<_CharT, _Traits>::off_type( -1)))))))
            {
              __err |= ::std::ios_base::failbit;
            }
        }
    }
    catch (::__cxxabiv1::__forced_unwind &)
    {
      this->_M_setstate(::std::ios_base::badbit);
      throw;
    }
    catch (...)
    {
      this->_M_setstate(::std::ios_base::badbit);
    }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, const char *__s)
  {
    if (!__s)
      {
        __out.setstate(::std::ios_base::badbit);
      }
    else
      {
        const ::std::size_t __clen(char_traits<char>::length(__s));
        try
        {
          struct  __ptr_guard
          {
              _CharT *__p;
              inline __ptr_guard(_CharT *__ip)
                : __p(__ip)
              {
              }
              inline ~__ptr_guard()
              {
                delete[] __ptr_guard::__p;
              }
              inline _CharT *__get()
              {
                return __ptr_guard::__p;
              }
          };
          __ptr_guard __pg(new _CharT [__clen]);
          _CharT *__ws = __pg.__get();
          for (::std::size_t __i(0); __i < __clen;  ++__i)
            {
              __ws[__i] = __out.widen(__s[__i]);
            }
          __ostream_insert(__out, __ws, __clen);
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __out._M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __out._M_setstate(::std::ios_base::badbit);
        }
      }
    return __out;
  }
  extern template class ::std::basic_ostream<char>;
  extern template ::std::basic_ostream<char> &endl(::std::basic_ostream<char> &);
  extern template ::std::basic_ostream<char> &ends(::std::basic_ostream<char> &);
  extern template ::std::basic_ostream<char> &flush(::std::basic_ostream<char> &);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, char);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, unsigned char);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, signed char);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, const char *);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, const unsigned char *);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, const signed char *);
 /* Instantiation of class template '::std::basic_ios<char>' */ 
 /* Instantiation of class template '::std::basic_ostream<char>' */ 
  extern template ::std::basic_ostream<char> &ostream::_M_insert(long int);
  extern template ::std::basic_ostream<char> &ostream::_M_insert(unsigned long int);
  extern template ::std::basic_ostream<char> &ostream::_M_insert(bool);
  extern template ::std::basic_ostream<char> &ostream::_M_insert(long long int);
  extern template ::std::basic_ostream<char> &ostream::_M_insert(unsigned long long int);
  extern template ::std::basic_ostream<char> &ostream::_M_insert(double);
  extern template ::std::basic_ostream<char> &ostream::_M_insert(long double);
  extern template ::std::basic_ostream<char> &ostream::_M_insert(const void *);
  extern template class ::std::basic_ostream<wchar_t>;
  extern template ::std::basic_ostream<wchar_t> &endl(::std::basic_ostream<wchar_t> &);
  extern template ::std::basic_ostream<wchar_t> &ends(::std::basic_ostream<wchar_t> &);
  extern template ::std::basic_ostream<wchar_t> &flush(::std::basic_ostream<wchar_t> &);
  extern template ::std::basic_ostream<wchar_t> &operator <<(::std::basic_ostream<wchar_t> &, wchar_t);
  extern template ::std::basic_ostream<wchar_t> &operator <<(::std::basic_ostream<wchar_t> &, char);
  extern template ::std::basic_ostream<wchar_t> &operator <<(::std::basic_ostream<wchar_t> &, const wchar_t *);
  extern template ::std::basic_ostream<wchar_t> &operator <<(::std::basic_ostream<wchar_t> &, const char *);
 /* Instantiation of class template '::std::basic_ios<wchar_t>' */ 
 /* Instantiation of class template '::std::basic_ostream<wchar_t>' */ 
  extern template ::std::basic_ostream<wchar_t> &wostream::_M_insert(long int);
  extern template ::std::basic_ostream<wchar_t> &wostream::_M_insert(unsigned long int);
  extern template ::std::basic_ostream<wchar_t> &wostream::_M_insert(bool);
  extern template ::std::basic_ostream<wchar_t> &wostream::_M_insert(long long int);
  extern template ::std::basic_ostream<wchar_t> &wostream::_M_insert(unsigned long long int);
  extern template ::std::basic_ostream<wchar_t> &wostream::_M_insert(double);
  extern template ::std::basic_ostream<wchar_t> &wostream::_M_insert(long double);
  extern template ::std::basic_ostream<wchar_t> &wostream::_M_insert(const void *);
  template < typename _CharT, typename _Traits >
  class  basic_istream : virtual public ::std::basic_ios<_CharT, _Traits>
  {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef ::std::basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef ::std::basic_ios<_CharT, _Traits> __ios_type;
      typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
      typedef ::std::num_get<_CharT, ::std::istreambuf_iterator<_CharT, _Traits> > __num_get_type;
      typedef ::std::ctype<_CharT> __ctype_type;
    protected:
      ::std::streamsize _M_gcount;
    public:
      inline explicit basic_istream(typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb)
        : _M_gcount((long int)0)
      {
        this->init(__sb);
      }
      inline virtual ~basic_istream()
      {
        ::std::basic_istream<_CharT, _Traits>::_M_gcount = (long int)0;
      }
      class sentry;
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(typename ::std::basic_istream<_CharT, _Traits>::__istream_type &(*__pf)(typename ::std::basic_istream<_CharT, _Traits>::__istream_type &))
      {
        return __pf(*this);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(typename ::std::basic_istream<_CharT, _Traits>::__ios_type &(*__pf)(typename ::std::basic_istream<_CharT, _Traits>::__ios_type &))
      {
        __pf(*this);
        return *this;
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(::std::ios_base &(*__pf)(::std::ios_base &))
      {
        __pf(*this);
        return *this;
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(bool &__n)
      {
        return (*this)._M_extract(__n);
      }
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(short int &__n);
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(unsigned short int &__n)
      {
        return (*this)._M_extract(__n);
      }
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(int &__n);
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(unsigned int &__n)
      {
        return (*this)._M_extract(__n);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(long int &__n)
      {
        return (*this)._M_extract(__n);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(unsigned long int &__n)
      {
        return (*this)._M_extract(__n);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(long long int &__n)
      {
        return (*this)._M_extract(__n);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(unsigned long long int &__n)
      {
        return (*this)._M_extract(__n);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(float &__f)
      {
        return (*this)._M_extract(__f);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(double &__f)
      {
        return (*this)._M_extract(__f);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(long double &__f)
      {
        return (*this)._M_extract(__f);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(void *&__p)
      {
        return (*this)._M_extract(__p);
      }
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sbout);
      inline ::std::streamsize gcount() const 
      {
        return ::std::basic_istream<_CharT, _Traits>::_M_gcount;
      }
      typename ::std::basic_istream<_CharT, _Traits>::int_type get();
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &get(typename ::std::basic_istream<_CharT, _Traits>::char_type &__c);
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &get(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n, typename ::std::basic_istream<_CharT, _Traits>::char_type __delim);
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &get(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
      {
        return this->get(__s, __n, this->widen('\n'));
      }
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &get(typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type &__sb, typename ::std::basic_istream<_CharT, _Traits>::char_type __delim);
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &get(typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type &__sb)
      {
        return this->get(__sb, this->widen('\n'));
      }
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &getline(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n, typename ::std::basic_istream<_CharT, _Traits>::char_type __delim);
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &getline(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
      {
        return this->getline(__s, __n, this->widen('\n'));
      }
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &ignore(::std::streamsize __n, typename ::std::basic_istream<_CharT, _Traits>::int_type __delim);
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &ignore(::std::streamsize __n);
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &ignore();
      typename ::std::basic_istream<_CharT, _Traits>::int_type peek();
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &read(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n);
      ::std::streamsize readsome(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n);
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &putback(typename ::std::basic_istream<_CharT, _Traits>::char_type __c);
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &unget();
      int sync();
      typename ::std::basic_istream<_CharT, _Traits>::pos_type tellg();
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &seekg(typename ::std::basic_istream<_CharT, _Traits>::pos_type __pos);
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &seekg(typename ::std::basic_istream<_CharT, _Traits>::off_type __off, ::std::ios_base::seekdir __dir);
    protected:
      inline basic_istream()
        : _M_gcount((long int)0)
      {
        this->init(0);
      }
      template < typename _ValueT >
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &_M_extract(_ValueT &__v);
    friend class sentry;
  };
 /* Instantiation of class template '::std::basic_istream<char>' */ 
  template <>
  ::std::basic_istream<char> &basic_istream<char>::getline(char *__s, long int __n, char __delim);
  template <>
  ::std::basic_istream<char> &basic_istream<char>::ignore(long int __n);
  template <>
  ::std::basic_istream<char> &basic_istream<char>::ignore(long int __n, ::std::char_traits<char>::int_type __delim);
 /* Instantiation of class template '::std::basic_istream<wchar_t>' */ 
  template <>
  ::std::basic_istream<wchar_t> &basic_istream<wchar_t>::getline(wchar_t *__s, long int __n, wchar_t __delim);
  template <>
  ::std::basic_istream<wchar_t> &basic_istream<wchar_t>::ignore(long int __n);
  template <>
  ::std::basic_istream<wchar_t> &basic_istream<wchar_t>::ignore(long int __n, ::std::char_traits<wchar_t>::int_type __delim);
  template < typename _CharT, typename _Traits >
  class  basic_istream<_CharT, _Traits>::sentry
  {
      bool _M_ok;
    public:
      typedef _Traits traits_type;
      typedef ::std::basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename ::std::basic_istream<_CharT, _Traits>::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
      explicit sentry(::std::basic_istream<_CharT, _Traits> &__in, bool __noskip  = (false));
      inline operator bool() const 
      {
        return ::std::basic_istream<_CharT, _Traits>::sentry::_M_ok;
      }
  };
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__in, _CharT &__c);
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, unsigned char &__c);
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, unsigned char &__c)
  {
    return __in >> reinterpret_cast<char &>(__c);
  }
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, signed char &__c);
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, signed char &__c)
  {
    return __in >> reinterpret_cast<char &>(__c);
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__in, _CharT *__s);
  template <>
  ::std::basic_istream<char> &operator >><char, ::std::char_traits<char> >(::std::basic_istream<char> &__in, char *__s);
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, unsigned char *__s);
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, unsigned char *__s)
  {
    return __in >> reinterpret_cast<char *>(__s);
  }
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, signed char *__s);
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, signed char *__s)
  {
    return __in >> reinterpret_cast<char *>(__s);
  }
  template < typename _CharT, typename _Traits >
  class  basic_iostream : public ::std::basic_istream<_CharT, _Traits>, public ::std::basic_ostream<_CharT, _Traits>
  {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
      typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
      inline explicit basic_iostream(::std::basic_streambuf<_CharT, _Traits> *__sb)
        : __istream_type(__sb), __ostream_type(__sb)
      {
      }
      inline virtual ~basic_iostream()
      {
      }
    protected:
      inline basic_iostream()
        : __istream_type(), __ostream_type()
      {
      }
  };
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &ws(::std::basic_istream<_CharT, _Traits> &__in);
  template < typename _CharT, typename _Traits >
  basic_istream<_CharT, _Traits>::sentry::sentry(::std::basic_istream<_CharT, _Traits> &__in, bool __noskip)
    : _M_ok(false)
  {
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    if (__in.good())
      {
        try
        {
          if (__in.tie())
            {
              __in.tie()->flush();
            }
          if (!__noskip && bool(__in.flags() & ::std::ios_base::skipws))
            {
              const typename ::std::basic_istream<_CharT, _Traits>::sentry::__int_type __eof = traits_type::eof();
              typename ::std::basic_istream<_CharT, _Traits>::sentry::__streambuf_type *__sb = __in.rdbuf();
              typename ::std::basic_istream<_CharT, _Traits>::sentry::__int_type __c = __sb->sgetc();
              const typename ::std::basic_istream<_CharT, _Traits>::sentry::__ctype_type &__ct = __check_facet(__in._M_ctype);
              while (!traits_type::eq_int_type(__c, __eof) && __ct.is(::std::ctype_base::space, traits_type::to_char_type(__c)))
                {
                  __c = __sb->snextc();
                }
              if (traits_type::eq_int_type(__c, __eof))
                {
                  __err |= ::std::ios_base::eofbit;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __in._M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __in._M_setstate(::std::ios_base::badbit);
        }
      }
    if (__in.good() && __err == ::std::ios_base::goodbit)
      {
        ::std::basic_istream<_CharT, _Traits>::sentry::_M_ok = true;
      }
    else
      {
        __err |= ::std::ios_base::failbit;
        __in.setstate(__err);
      }
  }
  template < typename _CharT, typename _Traits >
  template < typename _ValueT >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::_M_extract(_ValueT &__v)
  {
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, false);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::__num_get_type &__ng = __check_facet(this->_M_num_get);
          __ng.get(*this, 0, *this, __err, __v);
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
 /* Instantiation of class template '::__gnu_cxx::__conditional_type<true, ::__gnu_cxx::__numeric_traits_integer<short int>, ::__gnu_cxx::__numeric_traits_floating<short int> >' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits_integer<short int>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits<short int>' */ 
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::operator >>(short int &__n)
  {
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, false);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          long int __l;
          const typename ::std::basic_istream<_CharT, _Traits>::__num_get_type &__ng = __check_facet(this->_M_num_get);
          __ng.get(*this, 0, *this, __err, __l);
          if (__l < ::__gnu_cxx::__numeric_traits_integer<short int>::__min)
            {
              __err |= ::std::ios_base::failbit;
              __n = ::__gnu_cxx::__numeric_traits_integer<short int>::__min;
            }
          else
            {
              if (__l > ::__gnu_cxx::__numeric_traits_integer<short int>::__max)
                {
                  __err |= ::std::ios_base::failbit;
                  __n = ::__gnu_cxx::__numeric_traits_integer<short int>::__max;
                }
              else
                {
                  __n = (short int)__l;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::operator >>(int &__n)
  {
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, false);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          long int __l;
          const typename ::std::basic_istream<_CharT, _Traits>::__num_get_type &__ng = __check_facet(this->_M_num_get);
          __ng.get(*this, 0, *this, __err, __l);
          if (__l < ::__gnu_cxx::__numeric_traits_integer<int>::__min)
            {
              __err |= ::std::ios_base::failbit;
              __n = ::__gnu_cxx::__numeric_traits_integer<int>::__min;
            }
          else
            {
              if (__l > ::__gnu_cxx::__numeric_traits_integer<int>::__max)
                {
                  __err |= ::std::ios_base::failbit;
                  __n = ::__gnu_cxx::__numeric_traits_integer<int>::__max;
                }
              else
                {
                  __n = (int)__l;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::operator >>(typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sbout)
  {
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, false);
    if (__cerb && __sbout)
      {
        try
        {
          bool __ineof;
          if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
            {
              __err |= ::std::ios_base::failbit;
            }
          if (__ineof)
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::failbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::failbit);
        }
      }
    else
      {
        if (!__sbout)
          {
            __err |= ::std::ios_base::failbit;
          }
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::int_type basic_istream<_CharT, _Traits>::get()
  {
    const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
    typename ::std::basic_istream<_CharT, _Traits>::int_type __c = __eof;
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        try
        {
          __c = this->rdbuf()->sbumpc();
          if (!traits_type::eq_int_type(__c, __eof))
            {
              ::std::basic_istream<_CharT, _Traits>::_M_gcount = 1;
            }
          else
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    if (!::std::basic_istream<_CharT, _Traits>::_M_gcount)
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return __c;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::get(typename ::std::basic_istream<_CharT, _Traits>::char_type &__c)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __cb = this->rdbuf()->sbumpc();
          if (!traits_type::eq_int_type(__cb, traits_type::eof()))
            {
              ::std::basic_istream<_CharT, _Traits>::_M_gcount = 1;
              __c = traits_type::to_char_type(__cb);
            }
          else
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    if (!::std::basic_istream<_CharT, _Traits>::_M_gcount)
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::get(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n, typename ::std::basic_istream<_CharT, _Traits>::char_type __delim)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __idelim = traits_type::to_int_type(__delim);
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          typename ::std::basic_istream<_CharT, _Traits>::int_type __c = __sb->sgetc();
          while ((::std::basic_istream<_CharT, _Traits>::_M_gcount + 1 < __n && !traits_type::eq_int_type(__c, __eof)) && !traits_type::eq_int_type(__c, __idelim))
            {
              *__s++ = traits_type::to_char_type(__c);
               ++::std::basic_istream<_CharT, _Traits>::_M_gcount;
              __c = __sb->snextc();
            }
          if (traits_type::eq_int_type(__c, __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    if (__n > 0)
      {
        *__s = ((typename ::std::basic_istream<_CharT, _Traits>::char_type()));
      }
    if (!::std::basic_istream<_CharT, _Traits>::_M_gcount)
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::get(typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type &__sb, typename ::std::basic_istream<_CharT, _Traits>::char_type __delim)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __idelim = traits_type::to_int_type(__delim);
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__this_sb = this->rdbuf();
          typename ::std::basic_istream<_CharT, _Traits>::int_type __c = __this_sb->sgetc();
          typename ::std::basic_istream<_CharT, _Traits>::char_type __c2 = traits_type::to_char_type(__c);
          while ((!traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __idelim)) && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
            {
               ++::std::basic_istream<_CharT, _Traits>::_M_gcount;
              __c = __this_sb->snextc();
              __c2 = traits_type::to_char_type(__c);
            }
          if (traits_type::eq_int_type(__c, __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    if (!::std::basic_istream<_CharT, _Traits>::_M_gcount)
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::getline(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n, typename ::std::basic_istream<_CharT, _Traits>::char_type __delim)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __idelim = traits_type::to_int_type(__delim);
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          typename ::std::basic_istream<_CharT, _Traits>::int_type __c = __sb->sgetc();
          while ((::std::basic_istream<_CharT, _Traits>::_M_gcount + 1 < __n && !traits_type::eq_int_type(__c, __eof)) && !traits_type::eq_int_type(__c, __idelim))
            {
              *__s++ = traits_type::to_char_type(__c);
              __c = __sb->snextc();
               ++::std::basic_istream<_CharT, _Traits>::_M_gcount;
            }
          if (traits_type::eq_int_type(__c, __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
          else
            {
              if (traits_type::eq_int_type(__c, __idelim))
                {
                  __sb->sbumpc();
                   ++::std::basic_istream<_CharT, _Traits>::_M_gcount;
                }
              else
                {
                  __err |= ::std::ios_base::failbit;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    if (__n > 0)
      {
        *__s = ((typename ::std::basic_istream<_CharT, _Traits>::char_type()));
      }
    if (!::std::basic_istream<_CharT, _Traits>::_M_gcount)
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::ignore()
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
          else
            {
              ::std::basic_istream<_CharT, _Traits>::_M_gcount = 1;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::ignore(::std::streamsize __n)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb && __n > 0)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          typename ::std::basic_istream<_CharT, _Traits>::int_type __c = __sb->sgetc();
          bool __large_ignore(false);
          while (true)
            {
              while (::std::basic_istream<_CharT, _Traits>::_M_gcount < __n && !traits_type::eq_int_type(__c, __eof))
                {
                   ++::std::basic_istream<_CharT, _Traits>::_M_gcount;
                  __c = __sb->snextc();
                }
              if (__n == ::__gnu_cxx::__numeric_traits_integer<long int>::__max && !traits_type::eq_int_type(__c, __eof))
                {
                  ::std::basic_istream<_CharT, _Traits>::_M_gcount = ::__gnu_cxx::__numeric_traits_integer<long int>::__min;
                  __large_ignore = true;
                }
              else
                {
                  break;
                }
            }
          if (__large_ignore)
            {
              ::std::basic_istream<_CharT, _Traits>::_M_gcount = ::__gnu_cxx::__numeric_traits_integer<long int>::__max;
            }
          if (traits_type::eq_int_type(__c, __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::ignore(::std::streamsize __n, typename ::std::basic_istream<_CharT, _Traits>::int_type __delim)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb && __n > 0)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          typename ::std::basic_istream<_CharT, _Traits>::int_type __c = __sb->sgetc();
          bool __large_ignore(false);
          while (true)
            {
              while ((::std::basic_istream<_CharT, _Traits>::_M_gcount < __n && !traits_type::eq_int_type(__c, __eof)) && !traits_type::eq_int_type(__c, __delim))
                {
                   ++::std::basic_istream<_CharT, _Traits>::_M_gcount;
                  __c = __sb->snextc();
                }
              if ((__n == ::__gnu_cxx::__numeric_traits_integer<long int>::__max && !traits_type::eq_int_type(__c, __eof)) && !traits_type::eq_int_type(__c, __delim))
                {
                  ::std::basic_istream<_CharT, _Traits>::_M_gcount = ::__gnu_cxx::__numeric_traits_integer<long int>::__min;
                  __large_ignore = true;
                }
              else
                {
                  break;
                }
            }
          if (__large_ignore)
            {
              ::std::basic_istream<_CharT, _Traits>::_M_gcount = ::__gnu_cxx::__numeric_traits_integer<long int>::__max;
            }
          if (traits_type::eq_int_type(__c, __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
          else
            {
              if (traits_type::eq_int_type(__c, __delim))
                {
                  if (::std::basic_istream<_CharT, _Traits>::_M_gcount < ::__gnu_cxx::__numeric_traits_integer<long int>::__max)
                    {
                       ++::std::basic_istream<_CharT, _Traits>::_M_gcount;
                    }
                  __sb->sbumpc();
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::int_type basic_istream<_CharT, _Traits>::peek()
  {
    typename ::std::basic_istream<_CharT, _Traits>::int_type __c = traits_type::eof();
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          __c = this->rdbuf()->sgetc();
          if (traits_type::eq_int_type(__c, traits_type::eof()))
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return __c;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::read(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          ::std::basic_istream<_CharT, _Traits>::_M_gcount = this->rdbuf()->sgetn(__s, __n);
          if (::std::basic_istream<_CharT, _Traits>::_M_gcount != __n)
            {
              __err |= ::std::ios_base::eofbit | ::std::ios_base::failbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  ::std::streamsize basic_istream<_CharT, _Traits>::readsome(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const ::std::streamsize __num = this->rdbuf()->in_avail();
          if (__num > 0)
            {
              ::std::basic_istream<_CharT, _Traits>::_M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
            }
          else
            {
              if (__num ==  -1)
                {
                  __err |= ::std::ios_base::eofbit;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return ::std::basic_istream<_CharT, _Traits>::_M_gcount;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::putback(typename ::std::basic_istream<_CharT, _Traits>::char_type __c)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    this->clear(this->rdstate() &  ~::std::ios_base::eofbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          if (!__sb || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
            {
              __err |= ::std::ios_base::badbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::unget()
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    this->clear(this->rdstate() &  ~::std::ios_base::eofbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          if (!__sb || traits_type::eq_int_type(__sb->sungetc(), __eof))
            {
              __err |= ::std::ios_base::badbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  int basic_istream<_CharT, _Traits>::sync()
  {
    int __ret( -1);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          if (__sb)
            {
              if (__sb->pubsync() ==  -1)
                {
                  __err |= ::std::ios_base::badbit;
                }
              else
                {
                  __ret = 0;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::pos_type basic_istream<_CharT, _Traits>::tellg()
  {
    typename ::std::basic_istream<_CharT, _Traits>::pos_type __ret = ((typename ::std::basic_istream<_CharT, _Traits>::pos_type( -1)));
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        try
        {
          if (!this->fail())
            {
              __ret = this->rdbuf()->pubseekoff(0, ::std::ios_base::cur, ::std::ios_base::in);
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::seekg(typename ::std::basic_istream<_CharT, _Traits>::pos_type __pos)
  {
    this->clear(this->rdstate() &  ~::std::ios_base::eofbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          if (!this->fail())
            {
              const typename ::std::basic_istream<_CharT, _Traits>::pos_type __p = this->rdbuf()->pubseekpos(__pos, ::std::ios_base::in);
              if (__p == ((typename ::std::basic_istream<_CharT, _Traits>::pos_type(((typename ::std::basic_istream<_CharT, _Traits>::off_type( -1)))))))
                {
                  __err |= ::std::ios_base::failbit;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::seekg(typename ::std::basic_istream<_CharT, _Traits>::off_type __off, ::std::ios_base::seekdir __dir)
  {
    this->clear(this->rdstate() &  ~::std::ios_base::eofbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          if (!this->fail())
            {
              const typename ::std::basic_istream<_CharT, _Traits>::pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, ::std::ios_base::in);
              if (__p == ((typename ::std::basic_istream<_CharT, _Traits>::pos_type(((typename ::std::basic_istream<_CharT, _Traits>::off_type( -1)))))))
                {
                  __err |= ::std::ios_base::failbit;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__in, _CharT &__c)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::int_type __int_type;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(__in, false);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const __int_type __cb = __in.rdbuf()->sbumpc();
          if (!_Traits::eq_int_type(__cb, _Traits::eof()))
            {
              __c = _Traits::to_char_type(__cb);
            }
          else
            {
              __err |= ::std::ios_base::eofbit | ::std::ios_base::failbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __in._M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __in._M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            __in.setstate(__err);
          }
      }
    return __in;
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__in, _CharT *__s)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef ::std::basic_streambuf<_CharT, _Traits> __streambuf_type;
    typedef typename _Traits::int_type int_type;
    typedef _CharT char_type;
    typedef ::std::ctype<_CharT> __ctype_type;
    ::std::streamsize __extracted(0);
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(__in, false);
    if (__cerb)
      {
        try
        {
          ::std::streamsize __num = __in.width();
          if (__num <= 0)
            {
              __num = ::__gnu_cxx::__numeric_traits_integer<long int>::__max;
            }
          const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
          const int_type __eof = _Traits::eof();
          __streambuf_type *__sb = __in.rdbuf();
          int_type __c = __sb->sgetc();
          while ((__extracted < __num - 1 && !_Traits::eq_int_type(__c, __eof)) && !__ct.is(::std::ctype_base::space, _Traits::to_char_type(__c)))
            {
              *__s++ = _Traits::to_char_type(__c);
               ++__extracted;
              __c = __sb->snextc();
            }
          if (_Traits::eq_int_type(__c, __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
          *__s = char_type();
          __in.width(0);
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __in._M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __in._M_setstate(::std::ios_base::badbit);
        }
      }
    if (!__extracted)
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__err)
      {
        __in.setstate(__err);
      }
    return __in;
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &ws(::std::basic_istream<_CharT, _Traits> &__in)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef ::std::basic_streambuf<_CharT, _Traits> __streambuf_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::int_type __int_type;
    typedef ::std::ctype<_CharT> __ctype_type;
    const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
    const __int_type __eof = _Traits::eof();
    __streambuf_type *__sb = __in.rdbuf();
    __int_type __c = __sb->sgetc();
    while (!_Traits::eq_int_type(__c, __eof) && __ct.is(::std::ctype_base::space, _Traits::to_char_type(__c)))
      {
        __c = __sb->snextc();
      }
    if (_Traits::eq_int_type(__c, __eof))
      {
        __in.setstate(::std::ios_base::eofbit);
      }
    return __in;
  }
  extern template class ::std::basic_istream<char>;
  extern template ::std::basic_istream<char> &ws(::std::basic_istream<char> &);
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, char &);
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, char *);
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, unsigned char &);
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, signed char &);
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, unsigned char *);
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, signed char *);
  extern template ::std::basic_istream<char> &istream::_M_extract(unsigned short int &);
  extern template ::std::basic_istream<char> &istream::_M_extract(unsigned int &);
  extern template ::std::basic_istream<char> &istream::_M_extract(long int &);
  extern template ::std::basic_istream<char> &istream::_M_extract(unsigned long int &);
  extern template ::std::basic_istream<char> &istream::_M_extract(bool &);
  extern template ::std::basic_istream<char> &istream::_M_extract(long long int &);
  extern template ::std::basic_istream<char> &istream::_M_extract(unsigned long long int &);
  extern template ::std::basic_istream<char> &istream::_M_extract(float &);
  extern template ::std::basic_istream<char> &istream::_M_extract(double &);
  extern template ::std::basic_istream<char> &istream::_M_extract(long double &);
  extern template ::std::basic_istream<char> &istream::_M_extract(void *&);
  extern template class ::std::basic_iostream<char>;
  extern template class ::std::basic_istream<wchar_t>;
  extern template ::std::basic_istream<wchar_t> &ws(::std::basic_istream<wchar_t> &);
  extern template ::std::basic_istream<wchar_t> &operator >>(::std::basic_istream<wchar_t> &, wchar_t &);
  extern template ::std::basic_istream<wchar_t> &operator >>(::std::basic_istream<wchar_t> &, wchar_t *);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(unsigned short int &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(unsigned int &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(long int &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(unsigned long int &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(bool &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(long long int &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(unsigned long long int &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(float &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(double &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(long double &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(void *&);
  extern template class ::std::basic_iostream<wchar_t>;
  extern ::std::istream cin;
  extern ::std::ostream cout;
  extern ::std::ostream cerr;
  extern ::std::ostream clog;
  extern ::std::wistream wcin;
  extern ::std::wostream wcout;
  extern ::std::wostream wcerr;
  extern ::std::wostream wclog;
  static ::std::ios_base::Init __ioinit /* () */ ;
}
using namespace ::std;
::starpu_codelet cl /* () */ ;
struct  CpuParams
{
    int bx;
    int by;
    int i0;
    int j0;
    int i1;
    int j1;
    int dispatchThisSpecialRows;
    ::StarPuAligner *func;
};
StarPuAligner::StarPuAligner(::AbstractBlockProcessor *blockProcessor)
  : ::AbstractBlockAligner(blockProcessor, new (::StarPuAlignerParameters)())
{
  static const char __MERCURIUM_PRETTY_FUNCTION__[59L] = "::StarPuAligner::StarPuAligner(::AbstractBlockProcessor *)";
  int ret;
  ret = ::starpu_init(0L);
  if (ret ==  -19)
    {
      do
        {
          if (!::getenv("STARPU_SSILENT"))
            {
              ::fprintf(::stderr, "Erro 77");
            }
        }
      while (0);
    }
  {
    if (__builtin_expect(!!(ret != 0), 0))
      {
        char xmessage[256L];
        do
          {
            char *const _user_buf(xmessage);
            const ::size_t _user_buflen(256);
            do
              {
                if (__builtin_expect(!!!(xmessage != 0L), 0))
                  {
                    do
                      {
                        void *__ptrs[32L];
                        int __n(::backtrace(__ptrs, 32));
                        ::backtrace_symbols_fd(__ptrs, __n, 2);
                      }
                    while (0);
                    static_cast<bool>(xmessage != 0L) ? (void)0 : ::__assert_fail("(xmessage) != __null", "./src/StarPuAligner.cpp", 62, __MERCURIUM_PRETTY_FUNCTION__);
                  }
              }
            while (0);
            char *_tmp_buf(::strerror_r( -ret, _user_buf, _user_buflen));
            if (_tmp_buf != _user_buf)
              {
                if (_user_buflen > 0)
                  {
                    ::strncpy(_user_buf, _tmp_buf, _user_buflen);
                    _user_buf[_user_buflen - 1] = '\000';
                  }
              }
          }
        while (0);
        ::fprintf(::stderr, "[starpu] Unexpected value: <%d:%s> returned for starpu_init\n", ret, xmessage);
        do
          {
            do
              {
                void *__ptrs[32L];
                int __n(::backtrace(__ptrs, 32));
                ::backtrace_symbols_fd(__ptrs, __n, 2);
              }
            while (0);
            ::fprintf(::stderr, "[starpu][abort][%s()@%s:%d]\n", __func__, "./src/StarPuAligner.cpp", 62);
            ::abort();
          }
        while (0);
      }
  }
  ;
  unsigned int ncpus(::starpu_cpu_worker_get_count());
  ::starpu_codelet_init(&::cl);
  ::cl.cpu_funcs[0] = ::StarPuAligner::callBack;
  ::cl.cpu_funcs_name[0] = "processBlock";
  (*this).::AbstractBlockAligner::setPreferredSizes(1024, ::starpu_cpu_worker_get_count() * 2);
}
StarPuAligner::~StarPuAligner()
{
}
 /* Instantiation of template function '::std::basic_ostream<char> &::std::operator <<< ::std::char_traits<char> >(::std::basic_ostream<char> &, const char *)' */ 
 /* Instantiation of template function '::std::basic_ostream<char> &::std::basic_ostream<char>::operator <<(::std::basic_ostream<char> &(*)(::std::basic_ostream<char> &))' */ 
void StarPuAligner::scheduleBlocks(int grid_width, int grid_height)
{
  int ret;
  if ((*this).::AbstractAligner::mustDispatchLastColumn())
    {
      for (int d(0); d < grid_height + grid_width + 1 && (*this).::AbstractAligner::mustContinue(); d++)
        {
          for (int bx(0); (bx <= d && bx < grid_width) && (*this).::AbstractAligner::mustContinue(); bx++)
            {
              int by(d - bx);
              if (by >= grid_height)
                {
                  continue;
                }
              (*this).AbstractBlockAligner::alignBlock(bx, by);
            }
        }
    }
  else
    {
      int maxThreads(::starpu_cpu_worker_get_count());
      for (int jj(0); jj < grid_height || jj < grid_width; jj += maxThreads)
        {
          for (int d(0); d < jj + (2 * maxThreads - 1); d++)
            {
              for (int k(0); k < maxThreads && k <= d; k++)
                {
                  ::std::cout << "oi1" << ::std::endl<char, ::std::char_traits<char> >;
                  int i(d - k);
                  int j(jj + k);
                  if ((i < grid_width && j < grid_height) && i <= j)
                    {
                      (*this).AbstractBlockAligner::alignBlock(i, j);
                    }
                  if ((j < grid_width && i < grid_height) && j > i)
                    {
                      (*this).AbstractBlockAligner::alignBlock(j, i);
                    }
                }
            }
        }
    }
  ::starpu_task_wait_for_all();
}
void StarPuAligner::callBack(void **descr, void *_args)
{
  ::CpuParams *params(static_cast< ::CpuParams *>(_args));
  (*(*params).func).::StarPuAligner::processBlock((*params).bx, (*params).by, (*params).i0, (*params).j0, (*params).i1, (*params).j1, (*params).dispatchThisSpecialRows);
}
 /* Instantiation of template function '::cell_t *::std::copy< ::cell_t *, ::cell_t *>(::cell_t *, ::cell_t *, ::cell_t *)' */ 
void StarPuAligner::processBlock(int bx, int by, int i0, int j0, int i1, int j1, int dispatchThisSpecialRows)
{
  if (!(*this).::AbstractAligner::mustContinue())
    {
      return ;
    }
  (*this).AbstractBlockAligner::processBlock(bx, by, i0, j0, i1, j1);
  if (dispatchThisSpecialRows)
    {
      std::copy(&(*this).row[bx][0], &(*this).row[bx][j1 - j0], &(*this).renamedRow[bx][0]);
    }
}
 /* Instantiation of template function 'const int &::std::min<int>(const int &, const int &)' */ 
void StarPuAligner::alignBlock(int bx, int by, int i0, int j0, int i1, int j1)
{
  if (by == 0)
    {
      (*this).::AbstractAligner::receiveFirstRow((*this).row[bx], j1 - j0);
    }
  if (bx == 0)
    {
      (*this).col[by][0] = (*this).::AbstractAligner::getFirstColumnTail();
      (*this).::AbstractAligner::receiveFirstColumn((*this).col[by] + 1, i1 - i0);
    }
  if (!(*this).::AbstractAligner::mustContinue())
    {
      return ;
    }
  long long int priority(0);
  int grid_width((*(*this).getGrid()).::Grid::getGridWidth());
  int grid_height((*(*this).getGrid()).::Grid::getGridHeight());
  if ((*this).::AbstractAligner::mustDispatchLastColumn())
    {
      priority = grid_width - bx;
    }
  else
    {
      priority = std::min( -i0,  -j0);
    }
  int dispatchThisSpecialRows((*this).::AbstractBlockAligner::isSpecialRow(by));
  if (!(*this).::AbstractBlockAligner::isBlockPruned(bx, by))
    {
      ::CpuParams *params;
      (*params).bx = bx;
      (*params).by = by;
      (*params).i0 = i0;
      (*params).j0 = j0;
      (*params).i1 = i1;
      (*params).j1 = j1;
      ::starpu_task *task(::starpu_task_create());
      (*task).cl = &::cl;
      (*task).cl_arg = params;
      (*task).use_tag = 1;
    }
  else
    {
      (*this).AbstractBlockAligner::ignoreBlock(bx, by);
    }
}
void StarPuAligner::increaseBlockStat(const bool pruned)
{
}
void StarPuAligner::printInitialStatistics(::FILE *file)
{
}
void StarPuAligner::allocateStructures()
{
  (*this).AbstractBlockAligner::allocateStructures();
}
void StarPuAligner::deallocateStructures()
{
}
